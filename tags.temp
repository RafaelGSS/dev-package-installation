!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
NVM_DIR	Makefile	/^NVM_DIR := $(HOME)\/.nvm$/;"	m
RVM_DIR	Makefile	/^RVM_DIR := $(HOME)\/.rvm$/;"	m
ASDF_DIR	Makefile	/^ASDF_DIR := $(HOME)\/.asdf$/;"	m
-channel	Makefile	/^		sudo snap install spt --channel=edge$/;"	m
g:colors_name	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:colors_name='gruvbox'$/;"	v
g:gruvbox_bold	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_bold=1$/;"	v
g:gruvbox_italic	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let g:gruvbox_italic=1$/;"	v
g:gruvbox_italic	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let g:gruvbox_italic=0$/;"	v
g:gruvbox_undercurl	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_undercurl=1$/;"	v
g:gruvbox_underline	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_underline=1$/;"	v
g:gruvbox_inverse	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_inverse=1$/;"	v
g:gruvbox_guisp_fallback	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_guisp_fallback='NONE'$/;"	v
g:gruvbox_improved_strings	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_improved_strings=0$/;"	v
g:gruvbox_improved_warnings	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_improved_warnings=0$/;"	v
g:gruvbox_termcolors	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_termcolors=256$/;"	v
g:gruvbox_invert_indent_guides	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_invert_indent_guides=0$/;"	v
g:gruvbox_contrast_dark	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_contrast_dark='medium'$/;"	v
g:gruvbox_contrast_light	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gruvbox_contrast_light='medium'$/;"	v
s:is_dark	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:is_dark=(&background == 'dark')$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb = {}$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark0       = ['#282828', 235]     " 40-40-40$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark2       = ['#504945', 239]     " 80-73-69$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark3       = ['#665c54', 241]     " 102-92-84$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.gray_245    = ['#928374', 245]     " 146-131-116$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.gray_244    = ['#928374', 244]     " 146-131-116$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light3      = ['#bdae93', 248]     " 189-174-147$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light4      = ['#a89984', 246]     " 168-153-132$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3$/;"	v
s:bold	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:bold = 'bold,'$/;"	v
s:bold	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bold = ''$/;"	v
s:italic	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:italic = 'italic,'$/;"	v
s:italic	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:italic = ''$/;"	v
s:underline	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:underline = 'underline,'$/;"	v
s:underline	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:underline = ''$/;"	v
s:undercurl	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:undercurl = 'undercurl,'$/;"	v
s:undercurl	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:undercurl = ''$/;"	v
s:inverse	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:inverse = 'inverse,'$/;"	v
s:inverse	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:inverse = ''$/;"	v
s:vim_bg	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:vim_bg = ['bg', 'bg']$/;"	v
s:vim_fg	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:vim_fg = ['fg', 'fg']$/;"	v
s:none	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:none = ['NONE', 'NONE']$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg0  = s:gb.dark0$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:bg0  = s:gb.dark0_soft$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:bg0  = s:gb.dark0_hard$/;"	v
s:bg1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg1  = s:gb.dark1$/;"	v
s:bg2	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg2  = s:gb.dark2$/;"	v
s:bg3	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg3  = s:gb.dark3$/;"	v
s:bg4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg4  = s:gb.dark4$/;"	v
s:gray	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:gray = s:gb.gray_245$/;"	v
s:fg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg0 = s:gb.light0$/;"	v
s:fg1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg1 = s:gb.light1$/;"	v
s:fg2	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg2 = s:gb.light2$/;"	v
s:fg3	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg3 = s:gb.light3$/;"	v
s:fg4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg4 = s:gb.light4$/;"	v
s:fg4_256	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg4_256 = s:gb.light4_256$/;"	v
s:red	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:red    = s:gb.bright_red$/;"	v
s:green	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:green  = s:gb.bright_green$/;"	v
s:yellow	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:yellow = s:gb.bright_yellow$/;"	v
s:blue	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:blue   = s:gb.bright_blue$/;"	v
s:purple	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:purple = s:gb.bright_purple$/;"	v
s:aqua	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:aqua   = s:gb.bright_aqua$/;"	v
s:orange	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:orange = s:gb.bright_orange$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg0  = s:gb.light0$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:bg0  = s:gb.light0_soft$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:bg0  = s:gb.light0_hard$/;"	v
s:bg1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg1  = s:gb.light1$/;"	v
s:bg2	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg2  = s:gb.light2$/;"	v
s:bg3	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg3  = s:gb.light3$/;"	v
s:bg4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg4  = s:gb.light4$/;"	v
s:gray	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:gray = s:gb.gray_244$/;"	v
s:fg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg0 = s:gb.dark0$/;"	v
s:fg1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg1 = s:gb.dark1$/;"	v
s:fg2	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg2 = s:gb.dark2$/;"	v
s:fg3	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg3 = s:gb.dark3$/;"	v
s:fg4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg4 = s:gb.dark4$/;"	v
s:fg4_256	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg4_256 = s:gb.dark4_256$/;"	v
s:red	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:red    = s:gb.faded_red$/;"	v
s:green	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:green  = s:gb.faded_green$/;"	v
s:yellow	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:yellow = s:gb.faded_yellow$/;"	v
s:blue	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:blue   = s:gb.faded_blue$/;"	v
s:purple	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:purple = s:gb.faded_purple$/;"	v
s:aqua	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:aqua   = s:gb.faded_aqua$/;"	v
s:orange	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:orange = s:gb.faded_orange$/;"	v
s:bg0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:bg0[1]    = 0$/;"	v
s:fg4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg4[1]    = 7$/;"	v
s:gray	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:gray[1]   = 8$/;"	v
s:red	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:red[1]    = 9$/;"	v
s:green	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:green[1]  = 10$/;"	v
s:yellow	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:yellow[1] = 11$/;"	v
s:blue	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:blue[1]   = 12$/;"	v
s:purple	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:purple[1] = 13$/;"	v
s:aqua	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:aqua[1]   = 14$/;"	v
s:fg1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:fg1[1]    = 15$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bg0 = s:bg0$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bg1 = s:bg1$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bg2 = s:bg2$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bg3 = s:bg3$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.bg4 = s:bg4$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.gray = s:gray$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg0 = s:fg0$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg1 = s:fg1$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg2 = s:fg2$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg3 = s:fg3$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg4 = s:fg4$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.fg4_256 = s:fg4_256$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.red    = s:red$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.green  = s:green$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.yellow = s:yellow$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.blue   = s:blue$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.purple = s:purple$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.aqua   = s:aqua$/;"	v
s:gb	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:gb.orange = s:orange$/;"	v
g:terminal_color_0	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_0 = s:bg0[0]$/;"	v
g:terminal_color_8	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_8 = s:gray[0]$/;"	v
g:terminal_color_1	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_1 = s:gb.neutral_red[0]$/;"	v
g:terminal_color_9	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_9 = s:red[0]$/;"	v
g:terminal_color_2	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_2 = s:gb.neutral_green[0]$/;"	v
g:terminal_color_10	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_10 = s:green[0]$/;"	v
g:terminal_color_3	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_3 = s:gb.neutral_yellow[0]$/;"	v
g:terminal_color_11	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_11 = s:yellow[0]$/;"	v
g:terminal_color_4	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_4 = s:gb.neutral_blue[0]$/;"	v
g:terminal_color_12	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_12 = s:blue[0]$/;"	v
g:terminal_color_5	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_5 = s:gb.neutral_purple[0]$/;"	v
g:terminal_color_13	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_13 = s:purple[0]$/;"	v
g:terminal_color_6	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_6 = s:gb.neutral_aqua[0]$/;"	v
g:terminal_color_14	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_14 = s:aqua[0]$/;"	v
g:terminal_color_7	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_7 = s:fg4[0]$/;"	v
g:terminal_color_15	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:terminal_color_15 = s:fg1[0]$/;"	v
s:hls_cursor	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:hls_cursor = s:orange$/;"	v
s:hls_cursor	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)$/;"	v
s:number_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:number_column = s:none$/;"	v
s:number_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:number_column = get(s:gb, g:gruvbox_number_column)$/;"	v
s:sign_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:sign_column = s:bg1$/;"	v
s:sign_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:sign_column = s:number_column$/;"	v
g:gitgutter_override_sign_column_highlight	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:gitgutter_override_sign_column_highlight = 0$/;"	v
s:sign_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:sign_column = get(s:gb, g:gruvbox_sign_column)$/;"	v
s:color_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:color_column = s:bg1$/;"	v
s:color_column	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:color_column = get(s:gb, g:gruvbox_color_column)$/;"	v
s:vert_split	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:vert_split = s:bg0$/;"	v
s:vert_split	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let s:vert_split = get(s:gb, g:gruvbox_vert_split)$/;"	v
s:invert_signs	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:invert_signs = ''$/;"	v
s:invert_signs	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:invert_signs = s:inverse$/;"	v
s:invert_selection	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:invert_selection = s:inverse$/;"	v
s:invert_selection	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:invert_selection = ''$/;"	v
s:invert_tabline	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:invert_tabline = ''$/;"	v
s:invert_tabline	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:invert_tabline = s:inverse$/;"	v
s:italicize_comments	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:italicize_comments = s:italic$/;"	v
s:italicize_comments	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:italicize_comments = ''$/;"	v
s:italicize_strings	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let s:italicize_strings = ''$/;"	v
s:italicize_strings	nvim/plugged/gruvbox/colors/gruvbox.vim	/^    let s:italicize_strings = s:italic$/;"	v
HL	nvim/plugged/gruvbox/colors/gruvbox.vim	/^function! s:HL(group, fg, ...)$/;"	f
g:indent_guides_auto_colors	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:indent_guides_auto_colors = 0$/;"	v
g:indentLine_color_term	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:indentLine_color_term = s:bg2[1]$/;"	v
g:indentLine_color_gui	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:indentLine_color_gui = s:bg2[0]$/;"	v
g:rbpt_colorpairs	nvim/plugged/gruvbox/colors/gruvbox.vim	/^  let g:rbpt_colorpairs =$/;"	v
g:rainbow_guifgs	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]$/;"	v
g:rainbow_ctermfgs	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]$/;"	v
g:rainbow_conf	nvim/plugged/gruvbox/colors/gruvbox.vim	/^   let g:rainbow_conf = {}$/;"	v
g:rainbow_conf	nvim/plugged/gruvbox/colors/gruvbox.vim	/^   let g:rainbow_conf['guifgs'] = g:rainbow_guifgs$/;"	v
g:rainbow_conf	nvim/plugged/gruvbox/colors/gruvbox.vim	/^   let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs$/;"	v
g:niji_dark_colours	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:niji_dark_colours = g:rbpt_colorpairs$/;"	v
g:niji_light_colours	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:niji_light_colours = g:rbpt_colorpairs$/;"	v
g:vimshell_escape_colors	nvim/plugged/gruvbox/colors/gruvbox.vim	/^let g:vimshell_escape_colors = [$/;"	v
GruvboxHlsShowCursor	nvim/plugged/gruvbox/colors/gruvbox.vim	/^function! GruvboxHlsShowCursor()$/;"	f
GruvboxHlsHideCursor	nvim/plugged/gruvbox/colors/gruvbox.vim	/^function! GruvboxHlsHideCursor()$/;"	f
getGruvColor	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^function! s:getGruvColor(group)$/;"	f
s:bg0	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:bg0  = s:getGruvColor('GruvboxBg0')$/;"	v
s:bg1	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:bg1  = s:getGruvColor('GruvboxBg1')$/;"	v
s:bg2	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:bg2  = s:getGruvColor('GruvboxBg2')$/;"	v
s:bg4	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:bg4  = s:getGruvColor('GruvboxBg4')$/;"	v
s:fg1	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:fg1  = s:getGruvColor('GruvboxFg1')$/;"	v
s:fg4	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:fg4  = s:getGruvColor('GruvboxFg4')$/;"	v
s:yellow	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:yellow = s:getGruvColor('GruvboxYellow')$/;"	v
s:blue	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:blue   = s:getGruvColor('GruvboxBlue')$/;"	v
s:aqua	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:aqua   = s:getGruvColor('GruvboxAqua')$/;"	v
s:orange	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:orange = s:getGruvColor('GruvboxOrange')$/;"	v
s:green	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:green = s:getGruvColor('GruvboxGreen')$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p = {'normal':{}, 'inactive':{}, 'insert':{}, 'replace':{}, 'visual':{}, 'tabline':{}, 'terminal':{}}$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.normal.left = [ [ s:bg0, s:fg4, 'bold' ], [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.normal.right = [ [ s:bg0, s:fg4 ], [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.normal.middle = [ [ s:fg4, s:bg1 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.inactive.right = [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.inactive.left =  [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.inactive.middle = [ [ s:bg4, s:bg1 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.insert.left = [ [ s:bg0, s:blue, 'bold' ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.insert.right = [ [ s:bg0, s:blue ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.insert.middle = [ [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.terminal.left = [ [ s:bg0, s:green, 'bold' ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.terminal.right = [ [ s:bg0, s:green ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.terminal.middle = [ [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.replace.left = [ [ s:bg0, s:aqua, 'bold' ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.replace.right = [ [ s:bg0, s:aqua ], [ s:fg1, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.replace.middle = [ [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.visual.left = [ [ s:bg0, s:orange, 'bold' ], [ s:bg0, s:bg4 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.visual.right = [ [ s:bg0, s:orange ], [ s:bg0, s:bg4 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.visual.middle = [ [ s:fg4, s:bg1 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.tabline.left = [ [ s:fg4, s:bg2 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.tabline.tabsel = [ [ s:bg0, s:fg4 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.tabline.middle = [ [ s:bg0, s:bg0 ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.tabline.right = [ [ s:bg0, s:orange ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.normal.error = [ [ s:bg0, s:orange ] ]$/;"	v
s:p	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let s:p.normal.warning = [ [ s:bg2, s:yellow ] ]$/;"	v
g:lightline#colorscheme#gruvbox#palette	nvim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim	/^  let g:lightline#colorscheme#gruvbox#palette = lightline#colorscheme#flatten(s:p)$/;"	v
gruvbox#invert_signs_toggle	nvim/plugged/gruvbox/autoload/gruvbox.vim	/^function! gruvbox#invert_signs_toggle()$/;"	f
gruvbox#hls_show	nvim/plugged/gruvbox/autoload/gruvbox.vim	/^function! gruvbox#hls_show()$/;"	f
gruvbox#hls_hide	nvim/plugged/gruvbox/autoload/gruvbox.vim	/^function! gruvbox#hls_hide()$/;"	f
gruvbox#hls_toggle	nvim/plugged/gruvbox/autoload/gruvbox.vim	/^function! gruvbox#hls_toggle()$/;"	f
g:airline#themes#gruvbox#palette	nvim/plugged/gruvbox/autoload/airline/themes/gruvbox.vim	/^let g:airline#themes#gruvbox#palette = {}$/;"	v
airline#themes#gruvbox#refresh	nvim/plugged/gruvbox/autoload/airline/themes/gruvbox.vim	/^function! airline#themes#gruvbox#refresh()$/;"	f
g:loaded_fugitive	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let g:loaded_fugitive = 1$/;"	v
FugitiveGitDir	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveGitDir(...) abort$/;"	f
FugitiveReal	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveReal(...) abort$/;"	f
FugitiveFind	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveFind(...) abort$/;"	f
FugitivePath	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitivePath(...) abort$/;"	f
FugitiveParse	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveParse(...) abort$/;"	f
FugitivePrepare	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitivePrepare(...) abort$/;"	f
FugitiveConfig	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveConfig(...) abort$/;"	f
FugitiveRemoteUrl	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveRemoteUrl(...) abort$/;"	f
FugitiveHead	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveHead(...) abort$/;"	f
FugitiveStatusline	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveStatusline(...) abort$/;"	f
FugitiveCommonDir	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveCommonDir(...) abort$/;"	f
FugitiveWorkTree	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveWorkTree(...) abort$/;"	f
FugitiveIsGitDir	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveIsGitDir(path) abort$/;"	f
s:worktree_for_dir	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:worktree_for_dir = {}$/;"	v
s:dir_for_worktree	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:dir_for_worktree = {}$/;"	v
Tree	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! s:Tree(path) abort$/;"	f
FugitiveExtractGitDir	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveExtractGitDir(path) abort$/;"	f
FugitiveDetect	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveDetect(path) abort$/;"	f
FugitiveVimPath	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveVimPath(path) abort$/;"	f
FugitiveGitPath	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! FugitiveGitPath(path) abort$/;"	f
Slash	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! s:Slash(path) abort$/;"	f
ProjectionistDetect	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! s:ProjectionistDetect() abort$/;"	f
g:io_fugitive	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let g:io_fugitive = {$/;"	v
fugitive	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^augroup fugitive$/;"	a
s:addr_other	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:addr_other = has('patch-8.1.560') ? '-addr=other' : ''$/;"	v
s:addr_tabs	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''$/;"	v
s:addr_wins	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''$/;"	v
s:nowait	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^let s:nowait = v:version >= 704 ? '<nowait>' : ''$/;"	v
Map	nvim/plugged/vim-fugitive/plugin/fugitive.vim	/^function! s:Map(mode, lhs, rhs, ...) abort$/;"	f
g:autoloaded_fugitive	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let g:autoloaded_fugitive = 1$/;"	v
g:fugitive_git_executable	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let g:fugitive_git_executable = 'git'$/;"	v
g:fugitive_git_executable	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let g:fugitive_git_executable = 'env ' . g:fugitive_git_executable$/;"	v
function	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:function(name) abort$/;"	f
sub	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:sub(str,pat,rep) abort$/;"	f
gsub	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:gsub(str,pat,rep) abort$/;"	f
Uniq	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Uniq(list) abort$/;"	f
winshell	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:winshell() abort$/;"	f
shellesc	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:shellesc(arg) abort$/;"	f
s:fnameescape	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:fnameescape = " \\t\\n*?[{`$\\\\%#'\\"|!<"$/;"	v
fnameescape	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:fnameescape(file) abort$/;"	f
throw	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:throw(string) abort$/;"	f
DirCheck	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DirCheck(...) abort$/;"	f
Mods	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Mods(mods, ...) abort$/;"	f
Slash	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Slash(path) abort$/;"	f
Resolve	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Resolve(path) abort$/;"	f
cpath	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:cpath(path, ...) abort$/;"	f
Cd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Cd(...) abort$/;"	f
s:executables	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:executables = {}$/;"	v
executable	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:executable(binary) abort$/;"	f
DoAutocmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoAutocmd(cmd) abort$/;"	f
s:nowait	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:nowait = v:version >= 704 ? '<nowait>' : ''$/;"	v
Map	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Map(mode, lhs, rhs, ...) abort$/;"	f
QuickfixGet	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:QuickfixGet(nr, ...) abort$/;"	f
QuickfixSet	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:QuickfixSet(nr, ...) abort$/;"	f
QuickfixCreate	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:QuickfixCreate(nr, opts) abort$/;"	f
QuickfixStream	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:QuickfixStream(nr, title, cmd, first, callback, ...) abort$/;"	f
UserCommandList	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:UserCommandList(...) abort$/;"	f
UserCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:UserCommand(...) abort$/;"	f
s:git_versions	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:git_versions = {}$/;"	v
fugitive#GitVersion	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#GitVersion(...) abort$/;"	f
s:commondirs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:commondirs = {}$/;"	v
fugitive#CommonDir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CommonDir(dir) abort$/;"	f
Dir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Dir(...) abort$/;"	f
Tree	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Tree(...) abort$/;"	f
HasOpt	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:HasOpt(args, ...) abort$/;"	f
PreparePathArgs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreparePathArgs(cmd, dir, literal) abort$/;"	f
s:prepare_env	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:prepare_env = {$/;"	v
fugitive#PrepareDirEnvArgv	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#PrepareDirEnvArgv(...) abort$/;"	f
BuildShell	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BuildShell(dir, env, args) abort$/;"	f
fugitive#Prepare	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Prepare(...) abort$/;"	f
SystemError	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:SystemError(cmd, ...) abort$/;"	f
ChompError	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ChompError(...) abort$/;"	f
ChompDefault	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ChompDefault(default, ...) abort$/;"	f
LinesError	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:LinesError(...) abort$/;"	f
NullError	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NullError(...) abort$/;"	f
TreeChomp	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TreeChomp(...) abort$/;"	f
EchoExec	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:EchoExec(...) abort$/;"	f
s:head_cache	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:head_cache = {}$/;"	v
fugitive#Head	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Head(...) abort$/;"	f
fugitive#RevParse	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RevParse(rev, ...) abort$/;"	f
ConfigTimestamps	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ConfigTimestamps(dir, dict) abort$/;"	f
s:config	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:config = {}$/;"	v
fugitive#Config	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Config(...) abort$/;"	f
Remote	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Remote(dir) abort$/;"	f
fugitive#RemoteUrl	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RemoteUrl(...) abort$/;"	f
add_methods	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:add_methods(namespace, method_names) abort$/;"	f
s:repo_prototype	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:repo_prototype = {}$/;"	v
s:repos	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:repos = {}$/;"	v
fugitive#repo	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#repo(...) abort$/;"	f
repo_dir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_dir(...) dict abort$/;"	f
repo_tree	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_tree(...) dict abort$/;"	f
repo_bare	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_bare() dict abort$/;"	f
repo_find	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_find(object) dict abort$/;"	f
repo_translate	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_translate(rev) dict abort$/;"	f
repo_head	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_head(...) dict abort$/;"	f
repo_prepare	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_prepare(...) dict abort$/;"	f
repo_git_command	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_git_command(...) dict abort$/;"	f
repo_git_chomp	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_git_chomp(...) dict abort$/;"	f
repo_git_chomp_in_tree	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_git_chomp_in_tree(...) dict abort$/;"	f
repo_rev_parse	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_rev_parse(rev) dict abort$/;"	f
repo_superglob	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_superglob(base) dict abort$/;"	f
repo_config	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_config(name) dict abort$/;"	f
repo_user	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:repo_user() dict abort$/;"	f
DirCommitFile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DirCommitFile(path) abort$/;"	f
DirRev	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DirRev(url) abort$/;"	f
s:merge_heads	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:merge_heads = ['MERGE_HEAD', 'REBASE_HEAD', 'CHERRY_PICK_HEAD', 'REVERT_HEAD']$/;"	v
MergeHead	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:MergeHead(...) abort$/;"	f
Owner	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Owner(path, ...) abort$/;"	f
fugitive#Real	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Real(url) abort$/;"	f
fugitive#Path	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Path(url, ...) abort$/;"	f
Relative	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Relative(...) abort$/;"	f
fugitive#Find	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Find(object, ...) abort$/;"	f
Generate	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Generate(rev, ...) abort$/;"	f
DotRelative	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DotRelative(path, ...) abort$/;"	f
fugitive#Object	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Object(...) abort$/;"	f
s:var	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:var = '\\%(%\\|#<\\=\\d\\+\\|##\\=\\)'$/;"	v
s:flag	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:flag = '\\%(:[p8~.htre]\\|:g\\=s\\(.\\).\\{-\\}\\1.\\{-\\}\\1\\)'$/;"	v
s:expand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:expand = '\\%(\\(' . s:var . '\\)\\(' . s:flag . '*\\)\\(:S\\)\\=\\)'$/;"	v
BufName	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BufName(var) abort$/;"	f
ExpandVarLegacy	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ExpandVarLegacy(str) abort$/;"	f
ExpandVar	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ExpandVar(other, var, flags, esc, ...) abort$/;"	f
Expand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Expand(rev, ...) abort$/;"	f
fugitive#Expand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Expand(object) abort$/;"	f
ExpandSplit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ExpandSplit(string, ...) abort$/;"	f
SplitExpand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:SplitExpand(string, ...) abort$/;"	f
SplitExpandChain	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:SplitExpandChain(string, ...) abort$/;"	f
s:trees	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:trees = {}$/;"	v
s:indexes	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:indexes = {}$/;"	v
TreeInfo	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TreeInfo(dir, commit) abort$/;"	f
PathInfo	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PathInfo(url) abort$/;"	f
fugitive#simplify	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#simplify(url) abort$/;"	f
fugitive#resolve	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#resolve(url) abort$/;"	f
fugitive#getftime	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#getftime(url) abort$/;"	f
fugitive#getfsize	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#getfsize(url) abort$/;"	f
fugitive#getftype	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#getftype(url) abort$/;"	f
fugitive#filereadable	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#filereadable(url) abort$/;"	f
fugitive#filewritable	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#filewritable(url) abort$/;"	f
fugitive#isdirectory	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#isdirectory(url) abort$/;"	f
fugitive#getfperm	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#getfperm(url) abort$/;"	f
fugitive#setfperm	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#setfperm(url, perm) abort$/;"	f
TempCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TempCmd(out, cmd) abort$/;"	f
s:blobdirs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let s:blobdirs = {}$/;"	v
BlobTemp	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlobTemp(url) abort$/;"	f
fugitive#readfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#readfile(url, ...) abort$/;"	f
fugitive#writefile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#writefile(lines, url, ...) abort$/;"	f
s:globsubs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:globsubs = {$/;"	v
fugitive#glob	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#glob(url, ...) abort$/;"	f
fugitive#delete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#delete(url, ...) abort$/;"	f
s:buffer_prototype	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:buffer_prototype = {}$/;"	v
fugitive#buffer	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#buffer(...) abort$/;"	f
buffer_repo	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:buffer_repo() dict abort$/;"	f
buffer_type	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:buffer_type(...) dict abort$/;"	f
FilterEscape	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FilterEscape(items, ...) abort$/;"	f
GlobComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:GlobComplete(lead, pattern) abort$/;"	f
fugitive#CompletePath	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CompletePath(base, ...) abort$/;"	f
fugitive#PathComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#PathComplete(...) abort$/;"	f
CompleteHeads	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CompleteHeads(dir) abort$/;"	f
fugitive#CompleteObject	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CompleteObject(base, ...) abort$/;"	f
CompleteSub	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CompleteSub(subcommand, A, L, P, ...) abort$/;"	f
CompleteRevision	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CompleteRevision(A, L, P, ...) abort$/;"	f
CompleteRemote	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CompleteRemote(A, L, P) abort$/;"	f
ReplaceCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ReplaceCmd(cmd) abort$/;"	f
QueryLog	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:QueryLog(refspec) abort$/;"	f
FormatLog	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FormatLog(dict) abort$/;"	f
FormatRebase	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FormatRebase(dict) abort$/;"	f
FormatFile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FormatFile(dict) abort$/;"	f
Format	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Format(val) abort$/;"	f
AddHeader	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:AddHeader(key, value) abort$/;"	f
AddSection	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:AddSection(label, lines, ...) abort$/;"	f
fugitive#BufReadStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BufReadStatus() abort$/;"	f
fugitive#FileReadCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#FileReadCmd(...) abort$/;"	f
fugitive#FileWriteCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#FileWriteCmd(...) abort$/;"	f
fugitive#BufReadCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BufReadCmd(...) abort$/;"	f
fugitive#BufWriteCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BufWriteCmd(...) abort$/;"	f
fugitive#SourceCmd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#SourceCmd(...) abort$/;"	f
s:temp_files	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let s:temp_files = {}$/;"	v
TempState	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TempState(...) abort$/;"	f
TempReadPre	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TempReadPre(file) abort$/;"	f
TempReadPost	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:TempReadPost(file) abort$/;"	f
fugitive_temp	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_temp$/;"	a
fugitive#Command	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Command(line1, line2, range, bang, mods, arg) abort$/;"	f
s:exec_paths	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:exec_paths = {}$/;"	v
ExecPath	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ExecPath() abort$/;"	f
Subcommands	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Subcommands() abort$/;"	f
s:aliases	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:aliases = {}$/;"	v
Aliases	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Aliases(dir) abort$/;"	f
fugitive#Complete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Complete(lead, ...) abort$/;"	f
fugitive#CdComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CdComplete(A, L, P) abort$/;"	f
fugitive#Cd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Cd(path, ...) abort$/;"	f
StatusCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StatusCommand(line1, line2, range, count, bang, mods, reg, arg, args, ...) abort$/;"	f
StageJump	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageJump(offset, section, ...) abort$/;"	f
StageSeek	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageSeek(info, fallback) abort$/;"	f
DoAutocmdChanged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoAutocmdChanged(dir) abort$/;"	f
ReloadStatusBuffer	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ReloadStatusBuffer(...) abort$/;"	f
ReloadStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ReloadStatus(...) abort$/;"	f
s:last_time	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:last_time = reltime()$/;"	v
s:last_times	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let s:last_times = {}$/;"	v
ExpireStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ExpireStatus(bufnr) abort$/;"	f
ReloadWinStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ReloadWinStatus(...) abort$/;"	f
ReloadTabStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ReloadTabStatus(...) abort$/;"	f
fugitive#ReloadStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#ReloadStatus(...) abort$/;"	f
fugitive#EfmDir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#EfmDir(...) abort$/;"	f
fugitive_status	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_status$/;"	a
StageInfo	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageInfo(...) abort$/;"	f
Selection	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Selection(arg1, ...) abort$/;"	f
StageArgs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageArgs(visual) abort$/;"	f
Do	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Do(action, visual) abort$/;"	f
StageReveal	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageReveal() abort$/;"	f
s:file_pattern	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:file_pattern = '^[A-Z?] .\\|^diff --'$/;"	v
s:file_commit_pattern	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:file_commit_pattern = s:file_pattern . '\\|^\\%(\\l\\{3,\\} \\)\\=[0-9a-f]\\{4,\\} '$/;"	v
s:item_pattern	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:item_pattern = s:file_commit_pattern . '\\|^@@'$/;"	v
NextHunk	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextHunk(count) abort$/;"	f
PreviousHunk	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreviousHunk(count) abort$/;"	f
NextFile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextFile(count) abort$/;"	f
PreviousFile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreviousFile(count) abort$/;"	f
NextItem	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextItem(count) abort$/;"	f
PreviousItem	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreviousItem(count) abort$/;"	f
s:section_pattern	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:section_pattern = '^[A-Z][a-z][^:]*$'$/;"	v
s:section_commit_pattern	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:section_commit_pattern = s:section_pattern . '\\|^commit '$/;"	v
NextSection	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextSection(count) abort$/;"	f
PreviousSection	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreviousSection(count) abort$/;"	f
NextSectionEnd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextSectionEnd(count) abort$/;"	f
PreviousSectionEnd	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PreviousSectionEnd(count) abort$/;"	f
PatchSearchExpr	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PatchSearchExpr(reverse) abort$/;"	f
StageInline	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageInline(mode, ...) abort$/;"	f
NextExpandedHunk	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NextExpandedHunk(count) abort$/;"	f
StageDiff	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageDiff(diff) abort$/;"	f
StageDiffEdit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageDiffEdit() abort$/;"	f
StageApply	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageApply(info, reverse, extra) abort$/;"	f
StageDelete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageDelete(lnum1, lnum2, count) abort$/;"	f
StageIgnore	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StageIgnore(lnum1, lnum2, count) abort$/;"	f
DoToggleHeadHeader	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleHeadHeader(value) abort$/;"	f
DoStageUnpushedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUnpushedHeading(heading) abort$/;"	f
DoToggleUnpushedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnpushedHeading(heading) abort$/;"	f
DoStageUnpushed	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUnpushed(record) abort$/;"	f
DoToggleUnpushed	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnpushed(record) abort$/;"	f
DoUnstageUnpulledHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageUnpulledHeading(heading) abort$/;"	f
DoToggleUnpulledHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnpulledHeading(heading) abort$/;"	f
DoUnstageUnpulled	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageUnpulled(record) abort$/;"	f
DoToggleUnpulled	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnpulled(record) abort$/;"	f
DoUnstageUnpushed	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageUnpushed(record) abort$/;"	f
DoToggleStagedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleStagedHeading(...) abort$/;"	f
DoUnstageStagedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageStagedHeading(heading) abort$/;"	f
DoToggleUnstagedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnstagedHeading(...) abort$/;"	f
DoStageUnstagedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUnstagedHeading(heading) abort$/;"	f
DoToggleUntrackedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUntrackedHeading(...) abort$/;"	f
DoStageUntrackedHeading	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUntrackedHeading(heading) abort$/;"	f
DoToggleStaged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleStaged(record) abort$/;"	f
DoUnstageStaged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageStaged(record) abort$/;"	f
DoToggleUnstaged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUnstaged(record) abort$/;"	f
DoStageUnstaged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUnstaged(record) abort$/;"	f
DoUnstageUnstaged	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoUnstageUnstaged(record) abort$/;"	f
DoToggleUntracked	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoToggleUntracked(record) abort$/;"	f
DoStageUntracked	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DoStageUntracked(record) abort$/;"	f
StagePatch	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StagePatch(lnum1,lnum2) abort$/;"	f
CommitInteractive	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CommitInteractive(line1, line2, range, bang, mods, args, patch) abort$/;"	f
CommitSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CommitSubcommand(line1, line2, range, bang, mods, args, ...) abort$/;"	f
RevertSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RevertSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
fugitive#CommitComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CommitComplete(A, L, P) abort$/;"	f
fugitive#RevertComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RevertComplete(A, L, P) abort$/;"	f
FinishCommit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FinishCommit() abort$/;"	f
fugitive#MergeComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#MergeComplete(A, L, P) abort$/;"	f
fugitive#RebaseComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RebaseComplete(A, L, P) abort$/;"	f
fugitive#PullComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#PullComplete(A, L, P) abort$/;"	f
RebaseSequenceAborter	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RebaseSequenceAborter() abort$/;"	f
fugitive#Cwindow	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Cwindow() abort$/;"	f
s:common_efm	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:common_efm = ''$/;"	v
s:rebase_abbrevs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:rebase_abbrevs = {$/;"	v
RebaseEdit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RebaseEdit(cmd, dir) abort$/;"	f
MergeRebase	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:MergeRebase(cmd, bang, mods, args, ...) abort$/;"	f
RebaseClean	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RebaseClean(file) abort$/;"	f
MergeSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:MergeSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
RebaseSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RebaseSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
PullSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PullSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
fugitive_merge	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_merge$/;"	a
g:fugitive_summary_format	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^  let g:fugitive_summary_format = '%s'$/;"	v
fugitive#GrepComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#GrepComplete(A, L, P) abort$/;"	f
fugitive#LogComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#LogComplete(A, L, P) abort$/;"	f
GrepParseLine	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:GrepParseLine(prefix, name_only, dir, line) abort$/;"	f
GrepSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:GrepSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
LogFlushQueue	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:LogFlushQueue(state) abort$/;"	f
LogParse	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:LogParse(state, dir, line) abort$/;"	f
fugitive#LogCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort$/;"	f
UsableWin	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:UsableWin(nr) abort$/;"	f
OpenParse	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:OpenParse(args, wants_cmd) abort$/;"	f
DiffClose	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:DiffClose() abort$/;"	f
BlurStatus	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlurStatus() abort$/;"	f
OpenExec	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:OpenExec(cmd, mods, args, ...) abort$/;"	f
fugitive#Open	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Open(cmd, bang, mods, arg, args) abort$/;"	f
fugitive#ReadCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort$/;"	f
fugitive#EditComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#EditComplete(A, L, P) abort$/;"	f
fugitive#ReadComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#ReadComplete(A, L, P) abort$/;"	f
fugitive#WriteCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort$/;"	f
fugitive#WqCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#WqCommand(...) abort$/;"	f
fugitive_commit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_commit$/;"	a
fugitive#PushComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#PushComplete(A, L, P) abort$/;"	f
fugitive#FetchComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#FetchComplete(A, L, P) abort$/;"	f
AskPassArgs	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:AskPassArgs(dir) abort$/;"	f
Dispatch	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Dispatch(bang, cmd, args) abort$/;"	f
PushSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:PushSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
FetchSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:FetchSubcommand(line1, line2, range, bang, mods, args) abort$/;"	f
fugitive_diff	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_diff$/;"	a
can_diffoff	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:can_diffoff(buf) abort$/;"	f
fugitive#CanDiffoff	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#CanDiffoff(buf) abort$/;"	f
diff_modifier	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diff_modifier(count) abort$/;"	f
diff_window_count	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diff_window_count() abort$/;"	f
diff_restore	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diff_restore() abort$/;"	f
diffthis	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diffthis() abort$/;"	f
diffoff	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diffoff() abort$/;"	f
diffoff_all	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:diffoff_all(dir) abort$/;"	f
CompareAge	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:CompareAge(mine, theirs) abort$/;"	f
IsConflicted	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:IsConflicted() abort$/;"	f
fugitive#Diffsplit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Diffsplit(autodir, keepfocus, mods, arg, args) abort$/;"	f
Move	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Move(force, rename, destination) abort$/;"	f
fugitive#RenameComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RenameComplete(A,L,P) abort$/;"	f
fugitive#MoveCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#MoveCommand(line1, line2, range, bang, mods, arg, args) abort$/;"	f
fugitive#RenameCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RenameCommand(line1, line2, range, bang, mods, arg, args) abort$/;"	f
Remove	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Remove(after, force) abort$/;"	f
fugitive#RemoveCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#RemoveCommand(line1, line2, range, bang, mods, arg, args) abort$/;"	f
fugitive#DeleteCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#DeleteCommand(line1, line2, range, bang, mods, arg, args) abort$/;"	f
Keywordprg	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:Keywordprg() abort$/;"	f
linechars	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:linechars(pattern) abort$/;"	f
BlameBufnr	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameBufnr(...) abort$/;"	f
BlameCommitFileLnum	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameCommitFileLnum(...) abort$/;"	f
BlameLeave	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameLeave() abort$/;"	f
BlameQuit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameQuit() abort$/;"	f
fugitive#BlameComplete	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BlameComplete(A, L, P) abort$/;"	f
BlameSubcommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameSubcommand(line1, count, range, bang, mods, args) abort$/;"	f
BlameCommit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameCommit(cmd, ...) abort$/;"	f
BlameJump	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameJump(suffix, ...) abort$/;"	f
s:hash_colors	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:hash_colors = {}$/;"	v
fugitive#BlameSyntax	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BlameSyntax() abort$/;"	f
BlameRehighlight	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameRehighlight() abort$/;"	f
BlameFileType	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:BlameFileType() abort$/;"	f
fugitive_blame	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_blame$/;"	a
s:redirects	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^let s:redirects = {}$/;"	v
fugitive#BrowseCommand	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abort$/;"	f
<SID>:	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>$/;"	m
fugitive#MapCfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#MapCfile(...) abort$/;"	f
ContainingCommit	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:ContainingCommit() abort$/;"	f
SquashArgument	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:SquashArgument(...) abort$/;"	f
RebaseArgument	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:RebaseArgument() abort$/;"	f
NavigateUp	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:NavigateUp(count) abort$/;"	f
MapMotion	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:MapMotion(lhs, rhs) abort$/;"	f
fugitive#MapJumps	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#MapJumps(...) abort$/;"	f
StatusCfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:StatusCfile(...) abort$/;"	f
fugitive#StatusCfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#StatusCfile() abort$/;"	f
MessageCfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:MessageCfile(...) abort$/;"	f
fugitive#MessageCfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#MessageCfile() abort$/;"	f
cfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:cfile() abort$/;"	f
GF	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! s:GF(mode) abort$/;"	f
fugitive#Cfile	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Cfile() abort$/;"	f
fugitive#Statusline	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Statusline(...) abort$/;"	f
fugitive#statusline	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#statusline(...) abort$/;"	f
fugitive#head	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#head(...) abort$/;"	f
fugitive#Foldtext	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Foldtext() abort$/;"	f
fugitive#foldtext	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#foldtext() abort$/;"	f
fugitive_folding	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^augroup fugitive_folding$/;"	a
fugitive#Init	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#Init() abort$/;"	f
fugitive#is_git_dir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#is_git_dir(path) abort$/;"	f
fugitive#extract_git_dir	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#extract_git_dir(path) abort$/;"	f
fugitive#detect	nvim/plugged/vim-fugitive/autoload/fugitive.vim	/^function! fugitive#detect(path) abort$/;"	f
b:current_syntax	nvim/plugged/vim-fugitive/syntax/fugitive.vim	/^let b:current_syntax = "fugitive"$/;"	v
b:current_syntax	nvim/plugged/vim-fugitive/syntax/fugitiveblame.vim	/^let b:current_syntax = "fugitiveblame"$/;"	v
g:gutentags_debug	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_debug = get(g:, 'gutentags_debug', 0)$/;"	v
g:loaded_gutentags	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:loaded_gutentags = 1$/;"	v
g:gutentags_trace	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_trace = get(g:, 'gutentags_trace', 0)$/;"	v
g:gutentags_fake	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_fake = get(g:, 'gutentags_fake', 0)$/;"	v
g:gutentags_background_update	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_background_update = get(g:, 'gutentags_background_update', 1)$/;"	v
g:gutentags_pause_after_update	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_pause_after_update = get(g:, 'gutentags_pause_after_update', 0)$/;"	v
g:gutentags_enabled	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_enabled = get(g:, 'gutentags_enabled', 1)$/;"	v
g:gutentags_modules	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_modules = get(g:, 'gutentags_modules', ['ctags'])$/;"	v
g:gutentags_init_user_func	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_init_user_func = get(g:, 'gutentags_init_user_func', $/;"	v
g:gutentags_add_ctrlp_root_markers	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_add_ctrlp_root_markers = get(g:, 'gutentags_add_ctrlp_root_markers', 1)$/;"	v
g:gutentags_add_default_project_roots	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_add_default_project_roots = get(g:, 'gutentags_add_default_project_roots', 1)$/;"	v
g:gutentags_project_root	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_project_root = get(g:, 'gutentags_project_root', [])$/;"	v
g:gutentags_project_root	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_project_root += ['.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout']$/;"	v
g:gutentags_project_root_finder	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_project_root_finder = get(g:, 'gutentags_project_root_finder', '')$/;"	v
g:gutentags_project_info	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_project_info = get(g:, 'gutentags_project_info', [])$/;"	v
g:gutentags_exclude_filetypes	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_exclude_filetypes = get(g:, 'gutentags_exclude_filetypes', [])$/;"	v
g:gutentags_exclude_project_root	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_exclude_project_root = get(g:, 'gutentags_exclude_project_root', ['\/usr\/local'])$/;"	v
g:gutentags_resolve_symlinks	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_resolve_symlinks = get(g:, 'gutentags_resolve_symlinks', 0)$/;"	v
g:gutentags_generate_on_new	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_generate_on_new = get(g:, 'gutentags_generate_on_new', 1)$/;"	v
g:gutentags_generate_on_missing	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_generate_on_missing = get(g:, 'gutentags_generate_on_missing', 1)$/;"	v
g:gutentags_generate_on_write	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_generate_on_write = get(g:, 'gutentags_generate_on_write', 1)$/;"	v
g:gutentags_generate_on_empty_buffer	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_generate_on_empty_buffer = get(g:, 'gutentags_generate_on_empty_buffer', 0)$/;"	v
g:gutentags_file_list_command	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_file_list_command = get(g:, 'gutentags_file_list_command', '')$/;"	v
g:gutentags_use_jobs	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_use_jobs = get(g:, 'gutentags_use_jobs', has('job'))$/;"	v
g:gutentags_cache_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_cache_dir = ''$/;"	v
g:gutentags_cache_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_cache_dir = fnamemodify(g:gutentags_cache_dir, ':p')$/;"	v
g:gutentags_cache_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_cache_dir = fnamemodify(g:gutentags_cache_dir, ':s?[\/\\\\]$??')$/;"	v
g:gutentags_define_advanced_commands	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:gutentags_define_advanced_commands = get(g:, 'gutentags_define_advanced_commands', 0)$/;"	v
g:gutentags_plat_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_plat_dir = expand('<sfile>:h:h:p') . "\\\\plat\\\\win32\\\\"$/;"	v
g:gutentags_res_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_res_dir = expand('<sfile>:h:h:p') . "\\\\res\\\\"$/;"	v
g:gutentags_script_ext	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_script_ext = '.cmd'$/;"	v
g:gutentags_plat_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_plat_dir = expand('<sfile>:h:h:p') . '\/plat\/unix\/'$/;"	v
g:gutentags_res_dir	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_res_dir = expand('<sfile>:h:h:p') . '\/res\/'$/;"	v
g:gutentags_script_ext	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    let g:gutentags_script_ext = '.sh'$/;"	v
g:__gutentags_vim_is_leaving	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^let g:__gutentags_vim_is_leaving = 0$/;"	v
gutentags_detect	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^augroup gutentags_detect$/;"	a
GutentagsToggleEnabled	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    command! GutentagsToggleEnabled :let g:gutentags_enabled=!g:gutentags_enabled$/;"	c
GutentagsToggleTrace	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    command! GutentagsToggleTrace   :call gutentags#toggletrace()$/;"	c
GutentagsToggleFake	nvim/plugged/vim-gutentags/plugin/gutentags.vim	/^    command! GutentagsToggleFake    :call gutentags#fake()$/;"	c
g:gutentags_gtags_executable	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^    let g:gutentags_gtags_executable = 'gtags'$/;"	v
g:gutentags_gtags_dbpath	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^    let g:gutentags_gtags_dbpath = ''$/;"	v
g:gutentags_gtags_options_file	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^    let g:gutentags_gtags_options_file = '.gutgtags'$/;"	v
g:gutentags_gtags_cscope_executable	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^    let g:gutentags_gtags_cscope_executable = 'gtags-cscope'$/;"	v
g:gutentags_auto_add_gtags_cscope	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^    let g:gutentags_auto_add_gtags_cscope = 1$/;"	v
s:added_db_files	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^let s:added_db_files = {}$/;"	v
add_db	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^function! s:add_db(db_file) abort$/;"	f
gutentags#gtags_cscope#init	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^function! gutentags#gtags_cscope#init(project_root) abort$/;"	f
gutentags#gtags_cscope#generate	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^function! gutentags#gtags_cscope#generate(proj_dir, tags_file, gen_opts) abort$/;"	f
gutentags#gtags_cscope#on_job_exit	nvim/plugged/vim-gutentags/autoload/gutentags/gtags_cscope.vim	/^function! gutentags#gtags_cscope#on_job_exit(job, exit_val) abort$/;"	f
g:gutentags_ctags_executable	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_executable = get(g:, 'gutentags_ctags_executable', 'ctags')$/;"	v
g:gutentags_ctags_tagfile	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_tagfile = get(g:, 'gutentags_ctags_tagfile', 'tags')$/;"	v
g:gutentags_ctags_auto_set_tags	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_auto_set_tags = get(g:, 'gutentags_ctags_auto_set_tags', 1)$/;"	v
g:gutentags_ctags_options_file	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_options_file = get(g:, 'gutentags_ctags_options_file', '.gutctags')$/;"	v
g:gutentags_ctags_check_tagfile	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_check_tagfile = get(g:, 'gutentags_ctags_check_tagfile', 0)$/;"	v
g:gutentags_ctags_extra_args	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_extra_args = get(g:, 'gutentags_ctags_extra_args', [])$/;"	v
g:gutentags_ctags_post_process_cmd	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_post_process_cmd = get(g:, 'gutentags_ctags_post_process_cmd', '')$/;"	v
g:gutentags_ctags_exclude	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_exclude = get(g:, 'gutentags_ctags_exclude', [])$/;"	v
g:gutentags_ctags_exclude_wildignore	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let g:gutentags_ctags_exclude_wildignore = get(g:, 'gutentags_ctags_exclude_wildignore', 1)$/;"	v
_handleOldOptions	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! s:_handleOldOptions() abort$/;"	f
s:did_check_exe	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let s:did_check_exe = 0$/;"	v
s:runner_exe	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let s:runner_exe = gutentags#get_plat_file('update_tags')$/;"	v
s:unix_redir	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let s:unix_redir = (&shellredir =~# '%s') ? &shellredir : &shellredir . ' %s'$/;"	v
s:wildignores_options_path	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let s:wildignores_options_path = ''$/;"	v
s:last_wildignores	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^let s:last_wildignores = ''$/;"	v
gutentags#ctags#init	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! gutentags#ctags#init(project_root) abort$/;"	f
gutentags#ctags#generate	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! gutentags#ctags#generate(proj_dir, tags_file, gen_opts) abort$/;"	f
gutentags#ctags#on_job_exit	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! gutentags#ctags#on_job_exit(job, exit_val) abort$/;"	f
get_ctags_executable	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! s:get_ctags_executable(proj_dir) abort$/;"	f
generate_wildignore_options	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! s:generate_wildignore_options() abort$/;"	f
process_options_file	nvim/plugged/vim-gutentags/autoload/gutentags/ctags.vim	/^function! s:process_options_file(proj_dir, path) abort$/;"	f
g:gutentags_cscope_executable	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^    let g:gutentags_cscope_executable = 'cscope'$/;"	v
g:gutentags_scopefile	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^    let g:gutentags_scopefile = 'cscope.out'$/;"	v
g:gutentags_auto_add_cscope	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^    let g:gutentags_auto_add_cscope = 1$/;"	v
g:gutentags_cscope_build_inverted_index	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^    let g:gutentags_cscope_build_inverted_index = 0$/;"	v
s:runner_exe	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^let s:runner_exe = gutentags#get_plat_file('update_scopedb')$/;"	v
s:unix_redir	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^let s:unix_redir = (&shellredir =~# '%s') ? &shellredir : &shellredir . ' %s'$/;"	v
s:added_dbs	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^let s:added_dbs = []$/;"	v
gutentags#cscope#init	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^function! gutentags#cscope#init(project_root) abort$/;"	f
gutentags#cscope#generate	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^function! gutentags#cscope#generate(proj_dir, tags_file, gen_opts) abort$/;"	f
gutentags#cscope#on_job_exit	nvim/plugged/vim-gutentags/autoload/gutentags/cscope.vim	/^function! gutentags#cscope#on_job_exit(job, exit_val) abort$/;"	f
gutentags#chdir	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#chdir(path)$/;"	f
gutentags#throw	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#throw(message)$/;"	f
gutentags#error	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#error(message)$/;"	f
gutentags#warning	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#warning(message)$/;"	f
gutentags#trace	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#trace(message, ...)$/;"	f
gutentags#stripslash	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#stripslash(path)$/;"	f
gutentags#normalizepath	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#normalizepath(path)$/;"	f
gutentags#shellslash	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#shellslash(path)$/;"	f
gutentags#get_plat_file	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_plat_file(filename) abort$/;"	f
gutentags#get_res_file	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_res_file(filename) abort$/;"	f
gutentags#get_cachefile	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_cachefile(root_dir, filename) abort$/;"	f
gutentags#validate_cmd	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#validate_cmd(cmd) abort$/;"	f
gutentags#make_args	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#make_args(cmd) abort$/;"	f
gutentags#make_args	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#make_args(cmd) abort$/;"	f
gutentags#is_path_rooted	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#is_path_rooted(path) abort$/;"	f
gutentags#is_path_rooted	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#is_path_rooted(path) abort$/;"	f
s:known_files	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^let s:known_files = []$/;"	v
s:known_projects	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^let s:known_projects = {}$/;"	v
cache_project_root	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! s:cache_project_root(path) abort$/;"	f
gutentags#get_project_file_list_cmd	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_project_file_list_cmd(path) abort$/;"	f
gutentags#get_project_root	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_project_root(path) abort$/;"	f
gutentags#default_get_project_root	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#default_get_project_root(path) abort$/;"	f
gutentags#get_project_info	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_project_info(path) abort$/;"	f
gutentags#setup_gutentags	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#setup_gutentags() abort$/;"	f
gutentags#on_vim_leave_pre	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#on_vim_leave_pre() abort$/;"	f
s:update_queue	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^let s:update_queue = {}$/;"	v
s:update_in_progress	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^let s:update_in_progress = {}$/;"	v
s:update_queue	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    let s:update_queue[module] = []$/;"	v
s:update_in_progress	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    let s:update_in_progress[module] = []$/;"	v
gutentags#add_job	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#add_job(module, tags_file, data) abort$/;"	f
gutentags#find_job_index_by_tags_file	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#find_job_index_by_tags_file(module, tags_file) abort$/;"	f
gutentags#find_job_index_by_data	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#find_job_index_by_data(module, data) abort$/;"	f
gutentags#get_job_tags_file	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_job_tags_file(module, job_idx) abort$/;"	f
gutentags#get_job_data	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#get_job_data(module, job_idx) abort$/;"	f
gutentags#remove_job	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#remove_job(module, job_idx) abort$/;"	f
gutentags#remove_job_by_data	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#remove_job_by_data(module, data) abort$/;"	f
manual_update_tags	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! s:manual_update_tags(bang) abort$/;"	f
write_triggered_update_tags	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! s:write_triggered_update_tags(bufno) abort$/;"	f
update_tags	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! s:update_tags(bufno, module, write_mode, queue_mode) abort$/;"	f
gutentags#rescan	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#rescan(...)$/;"	f
gutentags#toggletrace	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#toggletrace(...)$/;"	f
gutentags#fake	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#fake(...)$/;"	f
gutentags#default_stdout_cb	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#default_stdout_cb(chan, msg) abort$/;"	f
gutentags#default_stderr_cb	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#default_stderr_cb(chan, msg) abort$/;"	f
nvim_job_exit_wrapper	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! s:nvim_job_exit_wrapper(real_cb, job, exit_code, event_type) abort$/;"	f
nvim_job_out_wrapper	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! s:nvim_job_out_wrapper(real_cb, job, lines, event_type) abort$/;"	f
gutentags#build_default_job_options	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#build_default_job_options(module) abort$/;"	f
gutentags#start_job	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#start_job(cmd, opts) abort$/;"	f
gutentags#build_default_job_options	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#build_default_job_options(module) abort$/;"	f
gutentags#start_job	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^    function! gutentags#start_job(cmd, opts) abort$/;"	f
gutentags#inprogress	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#inprogress()$/;"	f
gutentags#statusline	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#statusline(...) abort$/;"	f
gutentags#statusline_cb	nvim/plugged/vim-gutentags/autoload/gutentags.vim	/^function! gutentags#statusline_cb(fmt_cb, ...) abort$/;"	f
ShowUsage	nvim/plugged/vim-gutentags/plat/unix/update_tags.sh	/^ShowUsage() {$/;"	f
ShowUsage	nvim/plugged/vim-gutentags/plat/unix/update_scopedb.sh	/^ShowUsage() {$/;"	f
CleanUp	nvim/plugged/vim-gutentags/plat/unix/update_scopedb.sh	/^CleanUp() {$/;"	f
CSCOPE_EXE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set CSCOPE_EXE=cscope$/;"	v
CSCOPE_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set CSCOPE_ARGS=$/;"	v
DB_FILE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set DB_FILE=cscope.out$/;"	v
FILE_LIST_CMD	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set FILE_LIST_CMD=$/;"	v
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set LOG_FILE=$/;"	v
BUILD_INVERTED_INDEX	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set BUILD_INVERTED_INDEX=0$/;"	v
ParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^:ParseArgs$/;"	l
CSCOPE_EXE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set CSCOPE_EXE=%~2$/;"	v
DB_FILE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set DB_FILE=%~2$/;"	v
PROJ_ROOT	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set PROJ_ROOT=%~2$/;"	v
FILE_LIST_CMD	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set FILE_LIST_CMD=%~2$/;"	v
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set LOG_FILE=%~2$/;"	v
BUILD_INVERTED_INDEX	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set BUILD_INVERTED_INDEX=1$/;"	v
LoopParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^:LoopParseArgs$/;"	l
DoneParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^:DoneParseArgs$/;"	l
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^if [%LOG_FILE%]==[] set LOG_FILE=CON$/;"	v
FILESIZE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set FILESIZE=0$/;"	v
FILESIZE	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^for \/F %%F in ("%DB_FILE%.files") do set FILESIZE=%%~zF$/;"	v
CSCOPE_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^set CSCOPE_ARGS=%CSCOPE_ARGS% -i %DB_FILE%.files$/;"	v
CSCOPE_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^    set CSCOPE_ARGS=%CSCOPE_ARGS% -q$/;"	v
Usage	nvim/plugged/vim-gutentags/plat/win32/update_scopedb.cmd	/^:Usage$/;"	l
CTAGS_EXE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set CTAGS_EXE=ctags$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set CTAGS_ARGS=$/;"	v
TAGS_FILE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set TAGS_FILE=tags$/;"	v
PROJECT_ROOT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set PROJECT_ROOT=$/;"	v
FILE_LIST_CMD	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set FILE_LIST_CMD=$/;"	v
FILE_LIST_CMD_IS_ABSOLUTE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set FILE_LIST_CMD_IS_ABSOLUTE=0$/;"	v
UPDATED_SOURCE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set UPDATED_SOURCE=$/;"	v
POST_PROCESS_CMD	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set POST_PROCESS_CMD=$/;"	v
PAUSE_BEFORE_EXIT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set PAUSE_BEFORE_EXIT=0$/;"	v
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set LOG_FILE=$/;"	v
ParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^:ParseArgs$/;"	l
CTAGS_EXE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set CTAGS_EXE=%~2$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set CTAGS_ARGS=%CTAGS_ARGS% --exclude=%2$/;"	v
TAGS_FILE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set TAGS_FILE=%~2$/;"	v
PROJECT_ROOT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set PROJECT_ROOT=%~2$/;"	v
FILE_LIST_CMD	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set FILE_LIST_CMD=%~2$/;"	v
FILE_LIST_CMD_IS_ABSOLUTE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set FILE_LIST_CMD_IS_ABSOLUTE=1$/;"	v
UPDATED_SOURCE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set UPDATED_SOURCE=%~2$/;"	v
PAUSE_BEFORE_EXIT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set PAUSE_BEFORE_EXIT=1$/;"	v
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set LOG_FILE=%~2$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set CTAGS_ARGS=%CTAGS_ARGS% --options=%2$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set CTAGS_ARGS=%CTAGS_ARGS% %~2$/;"	v
POST_PROCESS_CMD	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^    set POST_PROCESS_CMD=%~2$/;"	v
LoopParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^:LoopParseArgs$/;"	l
DoneParseArgs	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^:DoneParseArgs$/;"	l
LOG_FILE	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^if [%LOG_FILE%]==[] set LOG_FILE=CON$/;"	v
INDEX_WHOLE_PROJECT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^set INDEX_WHOLE_PROJECT=1$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        set CTAGS_ARGS=%CTAGS_ARGS% --append "%UPDATED_SOURCE%"$/;"	v
INDEX_WHOLE_PROJECT	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        set INDEX_WHOLE_PROJECT=0$/;"	v
use_raw_list	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        set use_raw_list=0$/;"	v
use_raw_list	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        if ["%PROJECT_ROOT%"]==["."] set use_raw_list=1$/;"	v
use_raw_list	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        if ["%FILE_LIST_CMD_IS_ABSOLUTE%"]==["1"] set use_raw_list=1$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        set CTAGS_ARGS=%CTAGS_ARGS% -L %TAGS_FILE%.files$/;"	v
CTAGS_ARGS	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^        set CTAGS_ARGS=%CTAGS_ARGS% "%PROJECT_ROOT%"$/;"	v
Unlock	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^:Unlock$/;"	l
Usage	nvim/plugged/vim-gutentags/plat/win32/update_tags.cmd	/^:Usage$/;"	l
g:loaded_emmet_vim	nvim/plugged/emmet-vim/plugin/emmet.vim	/^let g:loaded_emmet_vim = 1$/;"	v
s:save_cpo	nvim/plugged/emmet-vim/plugin/emmet.vim	/^let s:save_cpo = &cpoptions$/;"	v
g:emmet_html5	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  let g:emmet_html5 = 1$/;"	v
g:emmet_docroot	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  let g:emmet_docroot = {}$/;"	v
g:emmet_debug	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  let g:emmet_debug = 0$/;"	v
g:emmet_curl_command	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  let g:emmet_curl_command = 'curl -s -L -A Mozilla\/5.0'$/;"	v
g:user_emmet_leader_key	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  let g:user_emmet_leader_key = '<c-y>'$/;"	v
install_plugin	nvim/plugged/emmet-vim/plugin/emmet.vim	/^function! s:install_plugin(mode, buffer)$/;"	f
EmmetInstall	nvim/plugged/emmet-vim/plugin/emmet.vim	/^command! -nargs=0 -bar EmmetInstall call <SID>install_plugin(get(g:, 'user_emmet_mode', 'a'), 1)$/;"	c
Emmet	nvim/plugged/emmet-vim/plugin/emmet.vim	/^  command! -nargs=1 Emmet call emmet#expandAbbr(4, <q-args>)$/;"	c
s:save_cpo	nvim/plugged/emmet-vim/autoload/emmet.vim	/^let s:save_cpo = &cpoptions$/;"	v
s:filtermx	nvim/plugged/emmet-vim/autoload/emmet.vim	/^let s:filtermx = '|\\(\\%(bem\\|html\\|blade\\|haml\\|slim\\|e\\|c\\|s\\|fc\\|xsl\\|t\\|\\\/[^ ]\\+\\)\\s*,\\{0,1}\\s*\\)*$'$/;"	v
emmet#getExpandos	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getExpandos(type, key) abort$/;"	f
emmet#splitFilterArg	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#splitFilterArg(filters) abort$/;"	f
emmet#useFilter	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#useFilter(filters, filter) abort$/;"	f
emmet#getIndentation	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getIndentation(...) abort$/;"	f
emmet#getBaseType	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getBaseType(type) abort$/;"	f
emmet#isExtends	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#isExtends(type, extend) abort$/;"	f
emmet#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#parseIntoTree(abbr, type) abort$/;"	f
emmet#expandAbbrIntelligent	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#expandAbbrIntelligent(feedkey) abort$/;"	f
emmet#isExpandable	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#isExpandable() abort$/;"	f
emmet#mergeConfig	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#mergeConfig(lhs, rhs) abort$/;"	f
emmet#newNode	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#newNode() abort$/;"	f
itemno	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! s:itemno(itemno, current) abort$/;"	f
localvar	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! s:localvar(current, key) abort$/;"	f
emmet#toString	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#toString(...) abort$/;"	f
emmet#getSettings	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getSettings() abort$/;"	f
emmet#getFilters	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getFilters(type) abort$/;"	f
emmet#getResource	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getResource(type, name, default) abort$/;"	f
emmet#getFileType	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getFileType(...) abort$/;"	f
emmet#getDollarExprs	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getDollarExprs(expand) abort$/;"	f
emmet#getDollarValueByKey	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getDollarValueByKey(key) abort$/;"	f
emmet#reExpandDollarExpr	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#reExpandDollarExpr(expand, times) abort$/;"	f
emmet#expandDollarExpr	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#expandDollarExpr(expand) abort$/;"	f
emmet#expandCursorExpr	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#expandCursorExpr(expand, mode) abort$/;"	f
emmet#unescapeDollarExpr	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#unescapeDollarExpr(expand) abort$/;"	f
emmet#expandAbbr	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#expandAbbr(mode, abbr) range abort$/;"	f
emmet#updateTag	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#updateTag() abort$/;"	f
emmet#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#moveNextPrevItem(flag) abort$/;"	f
emmet#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#moveNextPrev(flag) abort$/;"	f
emmet#imageSize	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#imageSize() abort$/;"	f
emmet#imageEncode	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#imageEncode() abort$/;"	f
emmet#toggleComment	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#toggleComment() abort$/;"	f
emmet#balanceTag	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#balanceTag(flag) range abort$/;"	f
emmet#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#splitJoinTag() abort$/;"	f
emmet#mergeLines	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#mergeLines() range abort$/;"	f
emmet#removeTag	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#removeTag() abort$/;"	f
emmet#mergeLines	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#mergeLines() abort$/;"	f
emmet#anchorizeURL	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#anchorizeURL(flag) abort$/;"	f
emmet#codePretty	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#codePretty() range abort$/;"	f
emmet#expandWord	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#expandWord(abbr, type, orig) abort$/;"	f
emmet#getSnippets	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#getSnippets(type) abort$/;"	f
emmet#completeTag	nvim/plugged/emmet-vim/autoload/emmet.vim	/^function! emmet#completeTag(findstart, base) abort$/;"	f
s:emmet_settings	nvim/plugged/emmet-vim/autoload/emmet.vim	/^let s:emmet_settings = {$/;"	v
emmet#lang#sass#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#findTokens(str) abort$/;"	f
emmet#lang#sass#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#sass#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#sass#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#imageSize() abort$/;"	f
emmet#lang#sass#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#imageEncode() abort$/;"	f
emmet#lang#sass#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#parseTag(tag) abort$/;"	f
emmet#lang#sass#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#toggleComment() abort$/;"	f
emmet#lang#sass#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#balanceTag(flag) range abort$/;"	f
emmet#lang#sass#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#sass#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#moveNextPrev(flag) abort$/;"	f
emmet#lang#sass#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#splitJoinTag() abort$/;"	f
emmet#lang#sass#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#removeTag() abort$/;"	f
emmet#lang#sass#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/sass.vim	/^function! emmet#lang#sass#mergeLines() abort$/;"	f
emmet#lang#haml#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#findTokens(str) abort$/;"	f
emmet#lang#haml#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#haml#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#haml#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#imageSize() abort$/;"	f
emmet#lang#haml#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#imageEncode() abort$/;"	f
emmet#lang#haml#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#parseTag(tag) abort$/;"	f
emmet#lang#haml#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#toggleComment() abort$/;"	f
emmet#lang#haml#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#balanceTag(flag) range abort$/;"	f
emmet#lang#haml#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#haml#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#moveNextPrev(flag) abort$/;"	f
emmet#lang#haml#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#splitJoinTag() abort$/;"	f
emmet#lang#haml#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#removeTag() abort$/;"	f
emmet#lang#haml#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/haml.vim	/^function! emmet#lang#haml#mergeLines() abort$/;"	f
emmet#lang#jade#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#findTokens(str) abort$/;"	f
emmet#lang#jade#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#jade#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#jade#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#imageSize() abort$/;"	f
emmet#lang#jade#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#imageEncode() abort$/;"	f
emmet#lang#jade#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#parseTag(tag) abort$/;"	f
emmet#lang#jade#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#toggleComment() abort$/;"	f
emmet#lang#jade#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#balanceTag(flag) range abort$/;"	f
emmet#lang#jade#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#jade#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#moveNextPrev(flag) abort$/;"	f
emmet#lang#jade#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#splitJoinTag() abort$/;"	f
emmet#lang#jade#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#removeTag() abort$/;"	f
emmet#lang#jade#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/jade.vim	/^function! emmet#lang#jade#mergeLines() abort$/;"	f
emmet#lang#slim#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#findTokens(str) abort$/;"	f
emmet#lang#slim#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#slim#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#slim#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#imageSize() abort$/;"	f
emmet#lang#slim#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#imageEncode() abort$/;"	f
emmet#lang#slim#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#parseTag(tag) abort$/;"	f
emmet#lang#slim#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#toggleComment() abort$/;"	f
emmet#lang#slim#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#balanceTag(flag) range abort$/;"	f
emmet#lang#slim#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#slim#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#moveNextPrev(flag) abort$/;"	f
emmet#lang#slim#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#splitJoinTag() abort$/;"	f
emmet#lang#slim#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#removeTag() abort$/;"	f
emmet#lang#slim#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/slim.vim	/^function! emmet#lang#slim#mergeLines() abort$/;"	f
emmet#lang#less#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#findTokens(str) abort$/;"	f
emmet#lang#less#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#less#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#less#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#imageSize() abort$/;"	f
emmet#lang#less#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#imageEncode() abort$/;"	f
emmet#lang#less#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#parseTag(tag) abort$/;"	f
emmet#lang#less#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#toggleComment() abort$/;"	f
emmet#lang#less#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#balanceTag(flag) range abort$/;"	f
emmet#lang#less#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#less#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#moveNextPrev(flag) abort$/;"	f
emmet#lang#less#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#splitJoinTag() abort$/;"	f
emmet#lang#less#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#removeTag() abort$/;"	f
emmet#lang#less#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/less.vim	/^function! emmet#lang#less#mergeLines() abort$/;"	f
s:bx	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^let s:bx = '{\\%("[^"]*"\\|''[^'']*''\\|\\$#\\|\\${\\w\\+}\\|\\$\\+\\|{[^{]\\+\\|[^{}]\\)\\{-}}'$/;"	v
s:mx	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^let s:mx = '\\([+>]\\|[<^]\\+\\)\\{-}'$/;"	v
emmet#lang#html#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#findTokens(str) abort$/;"	f
emmet#lang#html#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#parseIntoTree(abbr, type) abort$/;"	f
dollar_add	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! s:dollar_add(base,no) abort$/;"	f
emmet#lang#html#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#html#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#imageSize() abort$/;"	f
emmet#lang#html#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#imageEncode() abort$/;"	f
emmet#lang#html#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#parseTag(tag) abort$/;"	f
emmet#lang#html#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#toggleComment() abort$/;"	f
emmet#lang#html#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#balanceTag(flag) range abort$/;"	f
emmet#lang#html#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#html#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#moveNextPrev(flag) abort$/;"	f
emmet#lang#html#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#splitJoinTag() abort$/;"	f
emmet#lang#html#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#removeTag() abort$/;"	f
emmet#lang#html#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/html.vim	/^function! emmet#lang#html#mergeLines() abort$/;"	f
emmet#lang#css#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#findTokens(str) abort$/;"	f
emmet#lang#css#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#css#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#css#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#imageSize() abort$/;"	f
emmet#lang#css#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#imageEncode() abort$/;"	f
emmet#lang#css#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#parseTag(tag) abort$/;"	f
emmet#lang#css#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#toggleComment() abort$/;"	f
emmet#lang#css#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#balanceTag(flag) range abort$/;"	f
emmet#lang#css#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#css#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#moveNextPrev(flag) abort$/;"	f
emmet#lang#css#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#splitJoinTag() abort$/;"	f
emmet#lang#css#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#removeTag() abort$/;"	f
emmet#lang#css#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim	/^function! emmet#lang#css#mergeLines() abort$/;"	f
emmet#lang#elm#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#findTokens(str) abort$/;"	f
emmet#lang#elm#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#elm#renderNode	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#renderNode(node)$/;"	f
emmet#lang#elm#renderParam	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#renderParam(param)$/;"	f
emmet#lang#elm#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#elm#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#imageEncode() abort$/;"	f
emmet#lang#elm#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#parseTag(tag) abort$/;"	f
emmet#lang#elm#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#toggleComment() abort$/;"	f
emmet#lang#elm#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#balanceTag(flag) range abort$/;"	f
emmet#lang#elm#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#elm#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#moveNextPrev(flag) abort$/;"	f
emmet#lang#elm#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#splitJoinTag() abort$/;"	f
emmet#lang#elm#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#removeTag() abort$/;"	f
emmet#lang#elm#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/elm.vim	/^function! emmet#lang#elm#mergeLines() abort$/;"	f
emmet#lang#scss#findTokens	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#findTokens(str) abort$/;"	f
emmet#lang#scss#parseIntoTree	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#parseIntoTree(abbr, type) abort$/;"	f
emmet#lang#scss#toString	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#toString(settings, current, type, inline, filters, itemno, indent) abort$/;"	f
emmet#lang#scss#imageSize	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#imageSize() abort$/;"	f
emmet#lang#scss#imageEncode	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#imageEncode() abort$/;"	f
emmet#lang#scss#parseTag	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#parseTag(tag) abort$/;"	f
emmet#lang#scss#toggleComment	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#toggleComment() abort$/;"	f
emmet#lang#scss#balanceTag	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#balanceTag(flag) range abort$/;"	f
emmet#lang#scss#moveNextPrevItem	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#moveNextPrevItem(flag) abort$/;"	f
emmet#lang#scss#moveNextPrev	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#moveNextPrev(flag) abort$/;"	f
emmet#lang#scss#splitJoinTag	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#splitJoinTag() abort$/;"	f
emmet#lang#scss#removeTag	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#removeTag() abort$/;"	f
emmet#lang#scss#mergeLines	nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim	/^function! emmet#lang#scss#mergeLines() abort$/;"	f
emmet#lorem#ja#expand	nvim/plugged/emmet-vim/autoload/emmet/lorem/ja.vim	/^function! emmet#lorem#ja#expand(command) abort$/;"	f
emmet#lorem#en#expand	nvim/plugged/emmet-vim/autoload/emmet/lorem/en.vim	/^function! emmet#lorem#en#expand(command) abort$/;"	f
s:exists	nvim/plugged/emmet-vim/autoload/emmet/lang.vim	/^let s:exists = {}$/;"	v
emmet#lang#exists	nvim/plugged/emmet-vim/autoload/emmet/lang.vim	/^function! emmet#lang#exists(type) abort$/;"	f
emmet#lang#type	nvim/plugged/emmet-vim/autoload/emmet/lang.vim	/^function! emmet#lang#type(type) abort$/;"	f
emmet#lang#getExtends	nvim/plugged/emmet-vim/autoload/emmet/lang.vim	/^function! emmet#lang#getExtends(type) abort$/;"	f
emmet#util#deleteContent	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#deleteContent(region) abort$/;"	f
emmet#util#setContent	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#setContent(region, content) abort$/;"	f
emmet#util#selectRegion	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#selectRegion(region) abort$/;"	f
emmet#util#pointInRegion	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#pointInRegion(point, region) abort$/;"	f
emmet#util#cursorInRegion	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#cursorInRegion(region) abort$/;"	f
emmet#util#regionIsValid	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#regionIsValid(region) abort$/;"	f
emmet#util#searchRegion	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#searchRegion(start, end) abort$/;"	f
emmet#util#getContent	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getContent(region) abort$/;"	f
emmet#util#regionInRegion	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#regionInRegion(outer, inner) abort$/;"	f
emmet#util#getVisualBlock	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getVisualBlock() abort$/;"	f
emmet#util#getContentFromURL	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getContentFromURL(url) abort$/;"	f
emmet#util#getTextFromHTML	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getTextFromHTML(buf) abort$/;"	f
emmet#util#getImageSize	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getImageSize(fn) abort$/;"	f
emmet#util#imageSizeWithImageMagick	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#imageSizeWithImageMagick(fn) abort$/;"	f
emmet#util#isImageMagickInstalled	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#isImageMagickInstalled() abort$/;"	f
b64encode	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! s:b64encode(bytes, table, pad)$/;"	f
emmet#util#imageEncodeDecode	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#imageEncodeDecode(fn, flag) abort$/;"	f
emmet#util#unique	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#unique(arr) abort$/;"	f
s:seed	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^let s:seed = localtime()$/;"	v
emmet#util#srand	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#srand(seed) abort$/;"	f
emmet#util#rand	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#rand() abort$/;"	f
emmet#util#cache	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#cache(name, ...) abort$/;"	f
emmet#util#getcurpos	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#getcurpos() abort$/;"	f
emmet#util#closePopup	nvim/plugged/emmet-vim/autoload/emmet/util.vim	/^function! emmet#util#closePopup() abort$/;"	f
quickExpr	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^var quickExpr = \/^[^<]*(<(.|\\s)+>)[^>]*$|^#(\\w+)$\/,$/;"	V
init	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	init: function( selector, context ) {$/;"	M
jquery	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	jquery: "1.2.6",$/;"	P
size	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	size: function() {$/;"	M
length	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	length: 0,$/;"	P
get	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	get: function( num ) {$/;"	M
pushStack	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	pushStack: function( elems ) {$/;"	M
setArray	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	setArray: function( elems ) {$/;"	M
each	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	each: function( callback, args ) {$/;"	M
index	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	index: function( elem ) {$/;"	M
attr	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	attr: function( name, value, type ) {$/;"	M
css	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	css: function( key, value ) {$/;"	M
text	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	text: function( text ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = "";$/;"	V
wrapAll	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	wrapAll: function( html ) {$/;"	M
wrapInner	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	wrapInner: function( html ) {$/;"	M
wrap	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	wrap: function( html ) {$/;"	M
append	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	append: function() {$/;"	M
prepend	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	prepend: function() {$/;"	M
before	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	before: function() {$/;"	M
after	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	after: function() {$/;"	M
end	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	end: function() {$/;"	M
find	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	find: function( selector ) {$/;"	M
clone	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	clone: function( events ) {$/;"	M
filter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	filter: function( selector ) {$/;"	M
not	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	not: function( selector ) {$/;"	M
add	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	add: function( selector ) {$/;"	M
is	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	is: function( selector ) {$/;"	M
hasClass	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	hasClass: function( selector ) {$/;"	M
val	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	val: function( value ) {$/;"	M
checked	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				this.checked = (jQuery.inArray(this.value, value) >= 0 ||$/;"	M
jQuery	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				jQuery( "option", this ).each(function(){$/;"	M
selected	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					this.selected = (jQuery.inArray( this.value, values ) >= 0 ||$/;"	M
html	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	html: function( value ) {$/;"	M
replaceWith	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	replaceWith: function( value ) {$/;"	M
eq	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	eq: function( i ) {$/;"	M
slice	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	slice: function() {$/;"	M
map	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	map: function( callback ) {$/;"	M
andSelf	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	andSelf: function() {$/;"	M
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	data: function( key, value ){$/;"	M
removeData	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	removeData: function( key ){$/;"	M
domManip	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	domManip: function( args, table, reverse, callback ) {$/;"	M
evalScript	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^function evalScript( i, elem ) {$/;"	F
async	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			async: false,$/;"	P
dataType	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			dataType: "script"$/;"	P
now	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^function now(){$/;"	F
expando	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^var expando = "jQuery" + now(), uuid = 0, windowData = {},$/;"	V
noConflict	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	noConflict: function( deep ) {$/;"	M
isFunction	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	isFunction: function( fn ) {$/;"	M
isXMLDoc	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	isXMLDoc: function( elem ) {$/;"	M
globalEval	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	globalEval: function( data ) {$/;"	M
nodeName	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	nodeName: function( elem, name ) {$/;"	M
cache	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	cache: {},$/;"	P
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	data: function( elem, name, data ) {$/;"	M
removeData	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	removeData: function( elem, name ) {$/;"	M
each	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	each: function( object, callback, args ) {$/;"	M
name	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var name, i = 0, length = object.length;$/;"	V
i	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var name, i = 0, length = object.length;$/;"	V
prop	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	prop: function( elem, value, type, i, name ) {$/;"	M
className	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	className: {$/;"	P
add	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		add: function( elem, classNames ) {$/;"	M
remove	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		remove: function( elem, classNames ) {$/;"	M
has	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		has: function( elem, className ) {$/;"	M
swap	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	swap: function( elem, options, callback ) {$/;"	M
old	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var old = {};$/;"	O
css	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	css: function( elem, name, force ) {$/;"	M
val	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var val, props = { position: "absolute", visibility: "hidden", display:"block" }, which = name == "width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ];$/;"	V
props	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var val, props = { position: "absolute", visibility: "hidden", display:"block" }, which = name == "width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ];$/;"	V
getWH	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			function getWH() {$/;"	F
padding	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				var padding = 0, border = 0;$/;"	V
curCSS	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	curCSS: function( elem, name, force ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret, style = elem.style;$/;"	V
style	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret, style = elem.style;$/;"	V
color	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		function color( elem ) {$/;"	F
swap	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				var swap = [], stack = [], a = elem, i = 0;$/;"	A
clean	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	clean: function( elems, context ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [];$/;"	A
attr	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	attr: function( elem, name, value ) {$/;"	M
special	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var special = \/href|src|style\/.test( name );$/;"	V
filter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				elem.filter = (elem.filter || "").replace( \/alpha\\([^)]*\\)\/, "" ) +$/;"	M
trim	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	trim: function( text ) {$/;"	M
makeArray	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	makeArray: function( array ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [];$/;"	A
if	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		if( array != null ){$/;"	M
inArray	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	inArray: function( elem, array ) {$/;"	M
merge	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	merge: function( first, second ) {$/;"	M
i	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var i = 0, elem, pos = first.length;$/;"	V
unique	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	unique: function( array ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [], done = {};$/;"	A
grep	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	grep: function( elems, callback, inv ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [];$/;"	A
map	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	map: function( elems, callback ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [];$/;"	A
browser	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^jQuery.browser = {$/;"	P
version	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	version: (userAgent.match( \/.+(?:rv|it|ra|ie)[\\\/: ]([\\d.]+)\/ ) || [])[1],$/;"	M
safari	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	safari: \/webkit\/.test( userAgent ),$/;"	P
opera	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	opera: \/opera\/.test( userAgent ),$/;"	P
msie	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	msie: \/msie\/.test( userAgent ) && !\/opera\/.test( userAgent ),$/;"	P
mozilla	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	mozilla: \/mozilla\/.test( userAgent ) && !\/(compatible|webkit)\/.test( userAgent )$/;"	P
props	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	props: {$/;"	P
cssFloat	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		cssFloat: styleFloat,$/;"	P
styleFloat	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		styleFloat: styleFloat,$/;"	P
readonly	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		readonly: "readOnly",$/;"	P
maxlength	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		maxlength: "maxLength",$/;"	P
cellspacing	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		cellspacing: "cellSpacing"$/;"	P
parent	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	parent: function(elem){return elem.parentNode;},$/;"	M
parents	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	parents: function(elem){return jQuery.dir(elem,"parentNode");},$/;"	M
next	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	next: function(elem){return jQuery.nth(elem,2,"nextSibling");},$/;"	M
prev	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	prev: function(elem){return jQuery.nth(elem,2,"previousSibling");},$/;"	M
nextAll	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	nextAll: function(elem){return jQuery.dir(elem,"nextSibling");},$/;"	M
prevAll	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	prevAll: function(elem){return jQuery.dir(elem,"previousSibling");},$/;"	M
siblings	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	siblings: function(elem){return jQuery.sibling(elem.parentNode.firstChild,elem);},$/;"	M
children	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	children: function(elem){return jQuery.sibling(elem.firstChild);},$/;"	M
contents	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	contents: function(elem){return jQuery.nodeName(elem,"iframe")?elem.contentDocument||elem.contentWindow.document:jQuery.makeArray(elem.childNodes);}$/;"	M
appendTo	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	appendTo: "append",$/;"	P
prependTo	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	prependTo: "prepend",$/;"	P
insertBefore	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	insertBefore: "before",$/;"	P
insertAfter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	insertAfter: "after",$/;"	P
replaceAll	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	replaceAll: "replaceWith"$/;"	P
removeAttr	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	removeAttr: function( name ) {$/;"	M
addClass	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	addClass: function( classNames ) {$/;"	M
removeClass	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	removeClass: function( classNames ) {$/;"	M
toggleClass	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	toggleClass: function( classNames ) {$/;"	M
remove	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	remove: function( selector ) {$/;"	M
jQuery	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			jQuery( "*", this ).add(this).each(function(){$/;"	M
empty	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	empty: function() {$/;"	M
num	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^function num(elem, prop) {$/;"	F
expr	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	expr: {$/;"	P
lt	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			lt: function(a,i,m){return i<m[3]-0;},$/;"	M
gt	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			gt: function(a,i,m){return i>m[3]-0;},$/;"	M
nth	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			nth: function(a,i,m){return m[3]-0==i;},$/;"	M
eq	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			eq: function(a,i,m){return m[3]-0==i;},$/;"	M
first	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			first: function(a,i){return i==0;},$/;"	M
last	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			last: function(a,i,m,r){return i==r.length-1;},$/;"	M
even	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			even: function(a,i){return i%2==0;},$/;"	M
odd	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			odd: function(a,i){return i%2;},$/;"	M
parent	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			parent: function(a){return a.firstChild;},$/;"	M
empty	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			empty: function(a){return !a.firstChild;},$/;"	M
contains	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			contains: function(a,i,m){return (a.textContent||a.innerText||jQuery(a).text()||"").indexOf(m[3])>=0;},$/;"	M
visible	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			visible: function(a){return "hidden"!=a.type&&jQuery.css(a,"display")!="none"&&jQuery.css(a,"visibility")!="hidden";},$/;"	M
hidden	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			hidden: function(a){return "hidden"==a.type||jQuery.css(a,"display")=="none"||jQuery.css(a,"visibility")=="hidden";},$/;"	M
enabled	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			enabled: function(a){return !a.disabled;},$/;"	M
disabled	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			disabled: function(a){return a.disabled;},$/;"	M
checked	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			checked: function(a){return a.checked;},$/;"	M
selected	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			selected: function(a){return a.selected||jQuery.attr(a,"selected");},$/;"	M
text	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			text: function(a){return "text"==a.type;},$/;"	M
radio	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			radio: function(a){return "radio"==a.type;},$/;"	M
checkbox	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			checkbox: function(a){return "checkbox"==a.type;},$/;"	M
file	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			file: function(a){return "file"==a.type;},$/;"	M
password	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			password: function(a){return "password"==a.type;},$/;"	M
submit	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			submit: function(a){return "submit"==a.type;},$/;"	M
image	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			image: function(a){return "image"==a.type;},$/;"	M
reset	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			reset: function(a){return "reset"==a.type;},$/;"	M
button	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			button: function(a){return "button"==a.type||jQuery.nodeName(a,"button");},$/;"	M
input	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			input: function(a){return \/input|select|textarea|button\/i.test(a.nodeName);},$/;"	M
has	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			has: function(a,i,m){return jQuery.find(m[3],a).length;},$/;"	M
header	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			header: function(a){return \/h\\d\/i.test(a.nodeName);},$/;"	M
animated	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			animated: function(a){return jQuery.grep(jQuery.timers,function(fn){return a==fn.elem;}).length;}$/;"	M
parse	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	parse: [$/;"	P
multiFilter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	multiFilter: function( expr, elems, not ) {$/;"	M
old	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var old, cur = [];$/;"	V
cur	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var old, cur = [];$/;"	V
find	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	find: function( t, context ) {$/;"	M
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var ret = [context], done = [], last, nodeName;$/;"	A
r	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var r = [];$/;"	A
merge	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					var merge = {};$/;"	O
tmp	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^							var tmp = [];$/;"	A
classFilter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	classFilter: function(r,m,not){$/;"	M
tmp	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var tmp = [];$/;"	A
filter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	filter: function(t,r,not) {$/;"	M
last	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var last;$/;"	V
tmp	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				var tmp = [], type = m[3];$/;"	A
merge	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				var merge = {}, tmp = [],$/;"	O
first	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					first = (test[1] + (test[2] || 1)) - 0, last = test[3] - 0;$/;"	M
c	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^						var c = 1;$/;"	V
dir	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	dir: function( elem, dir ){$/;"	M
matched	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var matched = [],$/;"	A
nth	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	nth: function(cur,result,dir,elem){$/;"	M
num	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var num = 0;$/;"	V
sibling	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	sibling: function( n, elem ) {$/;"	M
r	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var r = [];$/;"	A
event	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^jQuery.event = {$/;"	P
add	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	add: function(elem, types, handler, data) {$/;"	M
if	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		if( data != undefined ) {$/;"	M
guid	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	guid: 1,$/;"	P
global	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	global: {},$/;"	P
remove	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	remove: function(elem, types, handler) {$/;"	M
trigger	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	trigger: function(type, data, elem, donative, extra) {$/;"	M
val	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var val, ret, fn = jQuery.isFunction( elem[ type ] || null ),$/;"	V
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var val, ret, fn = jQuery.isFunction( elem[ type ] || null ),$/;"	V
fn	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			var val, ret, fn = jQuery.isFunction( elem[ type ] || null ),$/;"	V
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					type: type,$/;"	P
target	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					target: elem,$/;"	P
preventDefault	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					preventDefault: function(){},$/;"	M
stopPropagation	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					stopPropagation: function(){},$/;"	M
handle	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	handle: function(event) {$/;"	M
val	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var val, ret, namespace, all, handlers;$/;"	V
ret	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var val, ret, namespace, all, handlers;$/;"	V
namespace	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var val, ret, namespace, all, handlers;$/;"	V
handlers	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		handlers = ( jQuery.data(this, "events") || {} )[event.type];$/;"	M
fix	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	fix: function(event) {$/;"	M
props	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var props = "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode metaKey newValue originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target timeStamp toElement type view wheelDelta which".split(" ");$/;"	V
preventDefault	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		event.preventDefault = function() {$/;"	M
stopPropagation	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		event.stopPropagation = function() {$/;"	M
which	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));$/;"	M
proxy	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	proxy: function( fn, proxy ){$/;"	M
special	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	special: {$/;"	P
ready	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		ready: {$/;"	P
setup	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			setup: function() {$/;"	M
teardown	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			teardown: function() { return; }$/;"	M
mouseenter	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		mouseenter: {$/;"	P
setup	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			setup: function() {$/;"	M
teardown	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			teardown: function() {$/;"	M
handler	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			handler: function(event) {$/;"	M
mouseleave	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		mouseleave: {$/;"	P
setup	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			setup: function() {$/;"	M
teardown	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			teardown: function() {$/;"	M
handler	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			handler: function(event) {$/;"	M
bind	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	bind: function( type, data, fn ) {$/;"	M
one	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	one: function( type, data, fn ) {$/;"	M
unbind	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	unbind: function( type, fn ) {$/;"	M
trigger	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	trigger: function( type, data, fn ) {$/;"	M
triggerHandler	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	triggerHandler: function( type, data, fn ) {$/;"	M
toggle	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	toggle: function( fn ) {$/;"	M
lastToggle	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			this.lastToggle = ( this.lastToggle || 0 ) % i;$/;"	M
hover	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	hover: function(fnOver, fnOut) {$/;"	M
ready	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	ready: function(fn) {$/;"	M
isReady	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	isReady: false,$/;"	P
readyList	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	readyList: [],$/;"	P
ready	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	ready: function() {$/;"	M
bindReady	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^function bindReady(){$/;"	F
numStyles	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var numStyles;$/;"	V
withinElement	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^var withinElement = function(event, elem) {$/;"	F
jQuery	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^jQuery(window).bind("unload", function() {$/;"	M
load	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	load: function( url, params, callback ) {$/;"	M
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var type = "GET";$/;"	V
url	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			url: url,$/;"	P
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			type: type,$/;"	P
dataType	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			dataType: "html",$/;"	P
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			data: params,$/;"	P
complete	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			complete: function(res, status){$/;"	M
serialize	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	serialize: function() {$/;"	M
serializeArray	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	serializeArray: function() {$/;"	M
get	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	get: function( url, data, callback, type ) {$/;"	M
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			type: "GET",$/;"	P
url	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			url: url,$/;"	P
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			data: data,$/;"	P
success	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			success: callback,$/;"	P
dataType	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			dataType: type$/;"	P
getScript	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	getScript: function( url, callback ) {$/;"	M
getJSON	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	getJSON: function( url, data, callback ) {$/;"	M
post	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	post: function( url, data, callback, type ) {$/;"	M
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			type: "POST",$/;"	P
url	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			url: url,$/;"	P
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			data: data,$/;"	P
success	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			success: callback,$/;"	P
dataType	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			dataType: type$/;"	P
ajaxSetup	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	ajaxSetup: function( settings ) {$/;"	M
ajaxSettings	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	ajaxSettings: {$/;"	P
global	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		global: true,$/;"	P
type	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		type: "GET",$/;"	P
timeout	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		timeout: 0,$/;"	P
contentType	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		contentType: "application\/x-www-form-urlencoded",$/;"	P
processData	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		processData: true,$/;"	P
async	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		async: true,$/;"	P
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		data: null,$/;"	P
username	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		username: null,$/;"	P
password	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		password: null,$/;"	P
accepts	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		accepts: {$/;"	P
xml	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			xml: "application\/xml, text\/xml",$/;"	P
html	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			html: "text\/html",$/;"	P
script	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			script: "text\/javascript, application\/javascript",$/;"	P
json	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			json: "application\/json, text\/javascript",$/;"	P
text	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			text: "text\/plain",$/;"	P
_default	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			_default: "*\/*"$/;"	P
lastModified	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	lastModified: {},$/;"	P
ajax	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	ajax: function( s ) {$/;"	M
jsonp	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var jsonp, jsre = \/=\\?(&|$)\/g, status, data,$/;"	V
jsre	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var jsonp, jsre = \/=\\?(&|$)\/g, status, data,$/;"	V
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";$/;"	M
data	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");$/;"	M
remote	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var remote = \/^(?:\\w+:)?\\\/\\\/([^\\\/?#]+)\/;$/;"	V
onreadystatechange	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var onreadystatechange = function(isTimeout){$/;"	F
modRes	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					var modRes;$/;"	V
setTimeout	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				setTimeout(function(){$/;"	M
success	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		function success(){$/;"	F
complete	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		function complete(){$/;"	F
handleError	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	handleError: function( s, xhr, status, e ) {$/;"	M
active	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	active: 0,$/;"	P
httpSuccess	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	httpSuccess: function( xhr ) {$/;"	M
httpNotModified	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	httpNotModified: function( xhr, url ) {$/;"	M
httpData	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	httpData: function( xhr, type, filter ) {$/;"	M
param	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	param: function( a ) {$/;"	M
s	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var s = [];$/;"	A
show	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	show: function(speed,callback){$/;"	M
height	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				height: "show", width: "show", opacity: "show"$/;"	P
hide	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	hide: function(speed,callback){$/;"	M
height	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				height: "hide", width: "hide", opacity: "hide"$/;"	P
toggle	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	toggle: function( fn, fn2 ){$/;"	M
height	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^					height: "toggle", width: "toggle", opacity: "toggle"$/;"	P
slideDown	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	slideDown: function(speed,callback){$/;"	M
slideUp	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	slideUp: function(speed,callback){$/;"	M
slideToggle	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	slideToggle: function(speed, callback){$/;"	M
fadeIn	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	fadeIn: function(speed, callback){$/;"	M
fadeOut	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	fadeOut: function(speed, callback){$/;"	M
fadeTo	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	fadeTo: function(speed,to,callback){$/;"	M
animate	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	animate: function( prop, speed, easing, callback ) {$/;"	M
e	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^				var e = new jQuery.fx( self, opt, name );$/;"	V
start	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^							start = ((end || 1) \/ e.cur(true)) * start;$/;"	M
end	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^							end = ((parts[1] == "-=" ? -1 : 1) * end) + start;$/;"	M
queue	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	queue: function(type, fn){$/;"	M
stop	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	stop: function(clearQueue, gotoEnd){$/;"	M
queue	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^var queue = function( elem, type, array ) {$/;"	F
dequeue	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^jQuery.fn.dequeue = function(type){$/;"	M
speed	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	speed: function(speed, easing, fn) {$/;"	M
duration	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			duration: speed,$/;"	P
duration	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		opt.duration = (opt.duration && opt.duration.constructor == Number ?$/;"	M
complete	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		opt.complete = function(){$/;"	M
easing	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	easing: {$/;"	P
linear	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		linear: function( p, n, firstNum, diff ) {$/;"	M
swing	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		swing: function( p, n, firstNum, diff ) {$/;"	M
timers	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	timers: [],$/;"	P
timerId	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	timerId: null,$/;"	P
fx	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	fx: function( elem, options, prop ){$/;"	M
orig	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^			options.orig = {};$/;"	P
update	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	update: function(){$/;"	M
cur	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	cur: function(force){$/;"	M
custom	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	custom: function(from, to, unit){$/;"	M
t	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		function t(gotoEnd){$/;"	F
show	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	show: function(){$/;"	M
hide	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	hide: function(){$/;"	M
step	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	step: function(gotoEnd){$/;"	M
speeds	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	speeds:{$/;"	P
slow	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		slow: 600,$/;"	P
fast	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^ 		fast: 200,$/;"	P
def	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^ 		def: 400$/;"	P
step	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	step: {$/;"	P
scrollLeft	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		scrollLeft: function(fx){$/;"	M
scrollTop	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		scrollTop: function(fx){$/;"	M
opacity	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		opacity: function(fx){$/;"	M
_default	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		_default: function(fx){$/;"	M
offset	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^jQuery.fn.offset = function() {$/;"	M
left	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	var left = 0, top = 0, elem = this[0], results;$/;"	V
border	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	function border(elem) {$/;"	F
add	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	function add(l, t) {$/;"	F
position	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	position: function() {$/;"	M
left	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^		var left = 0, top = 0, results;$/;"	V
offsetParent	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	offsetParent: function() {$/;"	M
method	nvim/plugged/emmet-vim/docs/static/js/jquery-latest.js	/^	var method = 'scroll' + name;$/;"	V
s:sfile	nvim/plugged/emmet-vim/unittest.vim	/^let s:sfile = expand('<sfile>')$/;"	v
s:logging	nvim/plugged/emmet-vim/unittest.vim	/^let s:logging = 0$/;"	v
reload	nvim/plugged/emmet-vim/unittest.vim	/^function! s:reload(d)$/;"	f
logn	nvim/plugged/emmet-vim/unittest.vim	/^function! s:logn(msg)$/;"	f
log	nvim/plugged/emmet-vim/unittest.vim	/^function! s:log(msg)$/;"	f
show_type	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_type(type)$/;"	f
show_category	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_category(category)$/;"	f
show_pass	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_pass(pass)$/;"	f
show_done	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_done()$/;"	f
escape	nvim/plugged/emmet-vim/unittest.vim	/^function! s:escape(str)$/;"	f
show_title	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_title(no, title)$/;"	f
show_skip	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_skip(no, title)$/;"	f
show_ok	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_ok()$/;"	f
show_ng	nvim/plugged/emmet-vim/unittest.vim	/^function! s:show_ng(no, expect, got)$/;"	f
test	nvim/plugged/emmet-vim/unittest.vim	/^function! s:test(...)$/;"	f
do_tests	nvim/plugged/emmet-vim/unittest.vim	/^function! s:do_tests(bang, ...)$/;"	f
emmet_unittest_complete	nvim/plugged/emmet-vim/unittest.vim	/^function! s:emmet_unittest_complete(arglead, cmdline, cmdpos)$/;"	f
EmmetUnitTest	nvim/plugged/emmet-vim/unittest.vim	/^command! -bang -nargs=* -complete=customlist,<SID>emmet_unittest_complete EmmetUnitTest call s:do_tests("<bang>", <f-args>)$/;"	c
g:loaded_rhubarb	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^let g:loaded_rhubarb = 1$/;"	v
g:dispatch_compilers	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^  let g:dispatch_compilers = {}$/;"	v
g:dispatch_compilers	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^let g:dispatch_compilers['hub'] = 'git'$/;"	v
g:fugitive_git_command	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^  let g:fugitive_git_command = 'hub'$/;"	v
Config	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^function! s:Config() abort$/;"	f
rhubarb	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^augroup rhubarb$/;"	a
g:fugitive_browse_handlers	nvim/plugged/vim-rhubarb/plugin/rhubarb.vim	/^  let g:fugitive_browse_handlers = []$/;"	v
g:autoloaded_rhubarb	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^let g:autoloaded_rhubarb = 1$/;"	v
throw	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:throw(string) abort$/;"	f
shellesc	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:shellesc(arg) abort$/;"	f
rhubarb#HomepageForUrl	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#HomepageForUrl(url) abort$/;"	f
rhubarb#homepage_for_url	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#homepage_for_url(url) abort$/;"	f
repo_homepage	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:repo_homepage() abort$/;"	f
credentials	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:credentials() abort$/;"	f
rhubarb#JsonDecode	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#JsonDecode(string) abort$/;"	f
rhubarb#JsonEncode	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#JsonEncode(object) abort$/;"	f
curl_arguments	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:curl_arguments(path, ...) abort$/;"	f
rhubarb#Request	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#Request(path, ...) abort$/;"	f
rhubarb#request	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#request(...) abort$/;"	f
rhubarb#RepoRequest	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#RepoRequest(...) abort$/;"	f
rhubarb#repo_request	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#repo_request(...) abort$/;"	f
url_encode	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! s:url_encode(str) abort$/;"	f
rhubarb#RepoSearch	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#RepoSearch(type, q) abort$/;"	f
rhubarb#repo_search	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#repo_search(...) abort$/;"	f
s:reference	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^let s:reference = '\\<\\%(\\c\\%(clos\\|resolv\\|referenc\\)e[sd]\\=\\|\\cfix\\%(e[sd]\\)\\=\\)\\>'$/;"	v
rhubarb#Complete	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#Complete(findstart, base) abort$/;"	f
rhubarb#omnifunc	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#omnifunc(findstart, base) abort$/;"	f
rhubarb#FugitiveUrl	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#FugitiveUrl(...) abort$/;"	f
rhubarb#fugitive_url	nvim/plugged/vim-rhubarb/autoload/rhubarb.vim	/^function! rhubarb#fugitive_url(...) abort$/;"	f
g:elixir_indent_debug	nvim/plugged/vim-elixir/test.init.vim	/^let g:elixir_indent_debug=1$/;"	v
current_compiler	nvim/plugged/vim-elixir/compiler/exunit.vim	/^let current_compiler = "exunit"$/;"	v
CompilerSet	nvim/plugged/vim-elixir/compiler/exunit.vim	/^  command -nargs=* CompilerSet setlocal <args>$/;"	c
s:cpo_save	nvim/plugged/vim-elixir/compiler/exunit.vim	/^let s:cpo_save = &cpo$/;"	v
current_compiler	nvim/plugged/vim-elixir/compiler/mix.vim	/^let current_compiler = 'mix'$/;"	v
CompilerSet	nvim/plugged/vim-elixir/compiler/mix.vim	/^    command -nargs=* CompilerSet setlocal <args>$/;"	c
current_compiler	nvim/plugged/vim-elixir/compiler/credo.vim	/^let current_compiler = 'credo'$/;"	v
CompilerSet	nvim/plugged/vim-elixir/compiler/credo.vim	/^    command -nargs=* CompilerSet setlocal <args>$/;"	c
b:did_indent	nvim/plugged/vim-elixir/indent/elixir.vim	/^let b:did_indent = 1$/;"	v
elixir#indent	nvim/plugged/vim-elixir/indent/elixir.vim	/^function! elixir#indent(lnum)$/;"	f
s:cpo_save	nvim/plugged/vim-elixir/indent/eelixir.vim	/^let s:cpo_save = &cpo$/;"	v
b:eelixir_subtype_indentexpr	nvim/plugged/vim-elixir/indent/eelixir.vim	/^let b:eelixir_subtype_indentexpr = &l:indentexpr$/;"	v
b:did_indent	nvim/plugged/vim-elixir/indent/eelixir.vim	/^let b:did_indent = 1$/;"	v
GetEelixirIndent	nvim/plugged/vim-elixir/indent/eelixir.vim	/^function! GetEelixirIndent(...)$/;"	f
bm	nvim/plugged/vim-elixir/bin/test_indent	/^def bm$/;"	f
detect_change	nvim/plugged/vim-elixir/bin/test_indent	/^def detect_change(f)$/;"	f
strip_doc_blocks	nvim/plugged/vim-elixir/bin/test_indent	/^def strip_doc_blocks(body)$/;"	f
g:elixir_indent_max_lookbehind	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^  let g:elixir_indent_max_lookbehind = 30$/;"	v
sw	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:sw()$/;"	f
elixir#indent#indent	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#indent(lnum)$/;"	f
debug	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:debug(str)$/;"	f
starts_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:starts_with(context, expr)$/;"	f
prev_starts_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:prev_starts_with(context, expr)$/;"	f
_starts_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:_starts_with(text, expr, lnum)$/;"	f
prev_ends_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:prev_ends_with(context, expr)$/;"	f
_ends_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:_ends_with(text, expr, lnum)$/;"	f
is_string_or_comment	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:is_string_or_comment(line, col)$/;"	f
syntax_name	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:syntax_name(line, col)$/;"	f
elixir#indent#searchpair_back_skip	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#searchpair_back_skip()$/;"	f
keyword	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:keyword(expr)$/;"	f
find_last_pos	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:find_last_pos(lnum, text, match)$/;"	f
elixir#indent#handle_top_of_file	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_top_of_file(context)$/;"	f
elixir#indent#handle_starts_with_string_continuation	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_starts_with_string_continuation(context)$/;"	f
elixir#indent#handle_follow_prev_nb	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_follow_prev_nb(context)$/;"	f
get_base_indent	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:get_base_indent(lnum, text)$/;"	f
elixir#indent#handle_following_trailing_binary_operator	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_following_trailing_binary_operator(context)$/;"	f
elixir#indent#handle_starts_with_pipe	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_starts_with_pipe(context)$/;"	f
elixir#indent#handle_starts_with_end	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_starts_with_end(context)$/;"	f
elixir#indent#handle_starts_with_binary_operator	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_starts_with_binary_operator(context)$/;"	f
elixir#indent#handle_inside_block	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_inside_block(context)$/;"	f
handle_with	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:handle_with(start_lnum, start_col, context)$/;"	f
do_handle_pattern_match_block	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! s:do_handle_pattern_match_block(relative_line, context)$/;"	f
elixir#indent#handle_inside_generic_block	nvim/plugged/vim-elixir/autoload/elixir/indent.vim	/^function! elixir#indent#handle_inside_generic_block(context)$/;"	f
elixir#util#get_filename	nvim/plugged/vim-elixir/autoload/elixir/util.vim	/^function! elixir#util#get_filename(word) abort$/;"	f
LoadRepos	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^defmodule LoadRepos do$/;"	m
load_apps	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp load_apps do$/;"	f
configs	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp configs do$/;"	f
config_to_url	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp config_to_url(_, %{url: url}), do: url$/;"	f
config_to_url	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp config_to_url(repo, %{$/;"	f
adapter_to_string	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp adapter_to_string(Ecto.Adapters.Postgres), do: "postgres"$/;"	f
adapter_to_string	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp adapter_to_string(Ecto.Adapters.MySQL), do: "mysql"$/;"	f
adapter_to_string	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  defp adapter_to_string(mod), do: raise("Unknown adapter #{inspect(mod)}")$/;"	f
main	nvim/plugged/vim-elixir/autoload/db/adapter/get_repos.exs	/^  def main do$/;"	f
s:path	nvim/plugged/vim-elixir/autoload/db/adapter/ecto.vim	/^let s:path = expand('<sfile>:h')$/;"	v
s:cmd	nvim/plugged/vim-elixir/autoload/db/adapter/ecto.vim	/^let s:cmd = join(['mix', 'run', '--no-start', '--no-compile', shellescape(s:path.'\/get_repos.exs')])$/;"	v
repo_list	nvim/plugged/vim-elixir/autoload/db/adapter/ecto.vim	/^function! s:repo_list() abort$/;"	f
db#adapter#ecto#canonicalize	nvim/plugged/vim-elixir/autoload/db/adapter/ecto.vim	/^function! db#adapter#ecto#canonicalize(url) abort$/;"	f
db#adapter#ecto#complete_opaque	nvim/plugged/vim-elixir/autoload/db/adapter/ecto.vim	/^function! db#adapter#ecto#complete_opaque(url) abort$/;"	f
hello	nvim/plugged/vim-elixir/spec/indent/binary_operator_spec.rb	/^  def hello do$/;"	f
hello	nvim/plugged/vim-elixir/spec/indent/binary_operator_spec.rb	/^  def hello do$/;"	f	class:hello
resend_confirmation	nvim/plugged/vim-elixir/spec/indent/with_spec.rb	/^  def resend_confirmation(username) when is_binary(username) do$/;"	f
create_user	nvim/plugged/vim-elixir/spec/indent/with_spec.rb	/^  def create_user(params) do$/;"	f	class:resend_confirmation
my_function	nvim/plugged/vim-elixir/spec/indent/with_spec.rb	/^  def my_function do$/;"	f	class:resend_confirmation.create_user
test	nvim/plugged/vim-elixir/spec/indent/if_spec.rb	/^  def test do$/;"	f
exec	nvim/plugged/vim-elixir/spec/indent/if_spec.rb	/^  def exec(command, progress_func \\\\ fn(_, state) -> state end, key \\\\ nil, output \\\\ nil) do$/;"	f	class:test
handle_call	nvim/plugged/vim-elixir/spec/indent/def_spec.rb	/^    def handle_call({:release_lock, key}, _from, state) do$/;"	f
hello	nvim/plugged/vim-elixir/spec/indent/def_spec.rb	/^  def hello do$/;"	f	class:handle_call
world	nvim/plugged/vim-elixir/spec/indent/def_spec.rb	/^  def world do$/;"	f	class:handle_call.hello
xpto	nvim/plugged/vim-elixir/spec/indent/tuples_spec.rb	/^  def xpto do$/;"	f
method	nvim/plugged/vim-elixir/spec/indent/tuples_spec.rb	/^  def method do$/;"	f	class:xpto
example	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def example do$/;"	f
project	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def project do$/;"	f	class:example
config	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def config do$/;"	f	class:example.project
test	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def test do$/;"	f	class:example.project.config
test	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def test do$/;"	f	class:example.project.config.test
test	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def test do$/;"	f	class:example.project.config.test.test
project	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def project do$/;"	f	class:example.project.config.test.test.test
test	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def test do$/;"	f	class:example.project.config.test.test.test.project
create	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def create(conn, %{$/;"	f	class:example.project.config.test.test.test.project.test
double	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def double(x) do$/;"	f	class:example.project.config.test.test.test.project.test.create
double	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def double(x) do$/;"	f	class:example.project.config.test.test.test.project.test.create.double
double	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def double(x) do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double
test_another_feature	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def test_another_feature do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double.double
test	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^    def test do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double.double.test_another_feature
fun	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^    def fun do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double.double.test_another_feature
fun	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^    def fun do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double.double.test_another_feature
init	nvim/plugged/vim-elixir/spec/indent/lists_spec.rb	/^  def init(_) do$/;"	f	class:example.project.config.test.test.test.project.test.create.double.double.double.test_another_feature
lol	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def lol do$/;"	f
name	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def name, do: IO.puts "bobmarley"$/;"	f
name	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def name(param) do$/;"	f	class:name
name	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def name, do: IO.puts "bobmarley"$/;"	f	class:name
name	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def name(param) do$/;"	f	class:name.name
f	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^  def f do$/;"	f	class:name.name
f	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^  def f do$/;"	f	class:name.name.f
test	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def test do$/;"	f	class:name.name.f.f
how_are_you	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def how_are_you do$/;"	f	class:name.name.f.f
how_are_you	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def how_are_you do$/;"	f	class:name.name.f.f
hello	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^    def hello do$/;"	f	class:name.name.f.f
handle_info	nvim/plugged/vim-elixir/spec/indent/blocks_spec.rb	/^  def handle_info(:tick, state = %{policy_iteration: []}) do$/;"	f	class:name.name.f.f.hello
handle_call	nvim/plugged/vim-elixir/spec/indent/keyword_spec.rb	/^  def handle_call({:get_in_line_for_lock, key}, from, state) do$/;"	f
do_query	nvim/plugged/vim-elixir/spec/indent/ecto_queries_spec.rb	/^    def do_query do$/;"	f
smth	nvim/plugged/vim-elixir/spec/indent/ecto_queries_spec.rb	/^  def smth do$/;"	f
do_query	nvim/plugged/vim-elixir/spec/indent/ecto_queries_spec.rb	/^  def do_query do$/;"	f	class:smth
alphabetical	nvim/plugged/vim-elixir/spec/indent/ecto_queries_spec.rb	/^  def alphabetical(query) do$/;"	f	class:smth.do_query
obtain_lock	nvim/plugged/vim-elixir/spec/indent/receive_spec.rb	/^  def obtain_lock(pid, key, timeout \\\\ 60_000) do$/;"	f
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func
some_other_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_other_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func
some_func	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def some_func do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^      def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^      def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hi	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hi do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hello	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hello do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hi	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hi do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
hi	nvim/plugged/vim-elixir/spec/indent/basic_spec.rb	/^    def hi do$/;"	f	class:some_func.some_func.some_func.some_func.some_func.some_func.some_other_func.some_func.some_other_func.some_func.some_other_func.hello.hello.hello.hello.hello.hello
test	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def test do$/;"	f
test	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def test do$/;"	f	class:test
test	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def test do$/;"	f	class:test.test
export_info	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^    def export_info(users) do$/;"	f	class:test.test.test
build_command	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def build_command(input, output) do$/;"	f	class:test.test.test
build_command	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def build_command(input, output) do$/;"	f	class:test.test.test.build_command
build_command	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def build_command(input, output) do$/;"	f	class:test.test.test.build_command.build_command
build_command	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^    def build_command(input, output) do$/;"	f	class:test.test.test.build_command.build_command.build_command
hello	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^  def hello do$/;"	f	class:test.test.test.build_command.build_command.build_command
do_stuff	nvim/plugged/vim-elixir/spec/indent/pipeline_spec.rb	/^    def do_stuff do$/;"	f	class:test.test.test.build_command.build_command.build_command.hello
do	nvim/plugged/vim-elixir/spec/indent/anonymous_functions_spec.rb	/^  def do$/;"	f
do	nvim/plugged/vim-elixir/spec/indent/anonymous_functions_spec.rb	/^  def do$/;"	f
test	nvim/plugged/vim-elixir/spec/indent/anonymous_functions_spec.rb	/^  def test do$/;"	f
lol	nvim/plugged/vim-elixir/spec/indent/anonymous_functions_spec.rb	/^    def lol do$/;"	f
run	nvim/plugged/vim-elixir/spec/indent/comment_spec.rb	/^    def run do$/;"	f
run	nvim/plugged/vim-elixir/spec/indent/comment_spec.rb	/^    def run(task) when task in [:t1, :t2] do$/;"	f
fold	nvim/plugged/vim-elixir/spec/folding/basic_spec.rb	/^  def self.fold(content)$/;"	F
some_func	nvim/plugged/vim-elixir/spec/folding/basic_spec.rb	/^    def some_func do # fold$/;"	f
some_func	nvim/plugged/vim-elixir/spec/folding/basic_spec.rb	/^    def some_func do # fold$/;"	f
Buffer	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^class Buffer$/;"	c
initialize	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def initialize(vim, type)$/;"	f	class:Buffer
reindent	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def reindent(content)$/;"	f	class:Buffer
type	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def type(content)$/;"	f	class:Buffer
syntax	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def syntax(content, pattern)$/;"	f	class:Buffer
fold_and_replace	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def fold_and_replace(content, fold_on_line)$/;"	f	class:Buffer
with_file	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def with_file(content = nil)$/;"	f	class:Buffer
edit_file	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def edit_file(content)$/;"	f	class:Buffer
Differ	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^class Differ$/;"	c
diff	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def self.diff(result, expected)$/;"	F	class:Differ
instance	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def self.instance$/;"	F	class:Differ
initialize	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def initialize$/;"	f	class:Differ
diff	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def diff(result, expected)$/;"	f	class:Differ.initialize
ExBuffer	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^module ExBuffer$/;"	m	class:Differ
new	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def self.new$/;"	F	class:Differ.ExBuffer
EexBuffer	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^module EexBuffer$/;"	m	class:Differ
new	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def self.new$/;"	F	class:Differ.EexBuffer
EexBuffer	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^module EexBuffer$/;"	m	class:Differ
new	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def self.new$/;"	F	class:Differ.EexBuffer
i	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def i(str)$/;"	f	class:Differ
ip	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def ip(str)$/;"	f	class:Differ
gen_tests	nvim/plugged/vim-elixir/spec/spec_helper.rb	/^  def gen_tests(method, str)$/;"	f	class:Differ
foo	nvim/plugged/vim-elixir/spec/syntax/comments_spec.rb	/^    def foo(<<$/;"	f
function	nvim/plugged/vim-elixir/spec/syntax/strings_spec.rb	/^      def function do$/;"	f
function	nvim/plugged/vim-elixir/spec/syntax/strings_spec.rb	/^      def function do$/;"	f
function	nvim/plugged/vim-elixir/spec/syntax/strings_spec.rb	/^      def function do$/;"	f
some_fun	nvim/plugged/vim-elixir/spec/syntax/doc_spec.rb	/^        def some_fun(x), do: x$/;"	f
some_fun	nvim/plugged/vim-elixir/spec/syntax/doc_spec.rb	/^        def some_fun(x), do: x$/;"	f
some_fun	nvim/plugged/vim-elixir/spec/syntax/doc_spec.rb	/^        def some_fun(x), do: x$/;"	f
some_fun	nvim/plugged/vim-elixir/spec/syntax/doc_spec.rb	/^        def some_fun(x), do: x$/;"	f
foo	nvim/plugged/vim-elixir/spec/syntax/operator_spec.rb	/^      def foo(bar \\\\ :baz)$/;"	f
foo	nvim/plugged/vim-elixir/spec/syntax/operator_spec.rb	/^      def foo(bar \/\/ :baz)$/;"	f	class:foo
MyTest	nvim/plugged/vim-elixir/spec/syntax/exunit_spec.rb	/^    module MyTest do$/;"	m
exec	nvim/plugged/vim-elixir/spec/syntax/anonymous_function_spec.rb	/^      def exec(func \\\\ fn(_, state) -> state end) do$/;"	f
exec	nvim/plugged/vim-elixir/spec/syntax/anonymous_function_spec.rb	/^        def exec(func \\\\ fn(_, state) -> state end) do$/;"	f
init	nvim/plugged/vim-elixir/spec/syntax/atom_spec.rb	/^          def init(args) do$/;"	f
init	nvim/plugged/vim-elixir/spec/syntax/atom_spec.rb	/^          def init(args) do$/;"	f
project	nvim/plugged/vim-elixir/spec/syntax/atom_spec.rb	/^    def project do$/;"	f
handle_call	nvim/plugged/vim-elixir/spec/syntax/variable_spec.rb	/^      def handle_call(:pop, _from, [h|stack]) do$/;"	f
handle_call	nvim/plugged/vim-elixir/spec/syntax/variable_spec.rb	/^    def handle_call(:pop)$/;"	f
handle_call	nvim/plugged/vim-elixir/spec/syntax/variable_spec.rb	/^      def handle_call(:pop,$/;"	f
call	nvim/plugged/vim-elixir/spec/syntax/variable_spec.rb	/^      def call(:pop, _, [h|stack]) do$/;"	f
sign_in	nvim/plugged/vim-elixir/spec/syntax/variable_spec.rb	/^    def sign_in(conn, %{$/;"	f
main_syntax	nvim/plugged/vim-elixir/syntax/elixir.vim	/^  let main_syntax = "elixir"$/;"	v
s:cpo_save	nvim/plugged/vim-elixir/syntax/elixir.vim	/^let s:cpo_save = &cpo$/;"	v
g:elixir_use_markdown_for_docs	nvim/plugged/vim-elixir/syntax/elixir.vim	/^  let g:elixir_use_markdown_for_docs = 0$/;"	v
b:current_syntax	nvim/plugged/vim-elixir/syntax/elixir.vim	/^let b:current_syntax = "elixir"$/;"	v
s:cpo_save	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^let s:cpo_save = &cpo$/;"	v
main_syntax	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^  let main_syntax = 'eelixir'$/;"	v
g:eelixir_default_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^  let g:eelixir_default_subtype = "html"$/;"	v
s:lines	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^  let s:lines = getline(1)."\\n".getline(2)."\\n".getline(3)."\\n".getline(4)."\\n".getline(5)."\\n".getline("$")$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^  let b:eelixir_subtype = matchstr(s:lines,'eelixir_subtype=\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = matchstr(&filetype,'^eex\\.\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = matchstr(&filetype,'^leex\\.\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = matchstr(substitute(expand("%:t"),'\\c\\%(\\.eex\\|\\.leex\\|\\.eelixir\\)\\+$','',''),'\\.\\zs\\w\\+$')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = 'elixir'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = 'elixir'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = 'yaml'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = 'javascript'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = 'text'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^    let b:eelixir_subtype = g:eelixir_default_subtype$/;"	v
b:current_syntax	nvim/plugged/vim-elixir/syntax/eelixir.vim	/^let b:current_syntax = 'eelixir'$/;"	v
GenStage	nvim/plugged/vim-elixir/large_file.ex	/^defmodule GenStage do$/;"	m
A	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule A do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link(number) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(counter) do$/;"	f
handle_demand	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_demand(demand, counter) when demand > 0 do$/;"	f
B	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule B do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link(number) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(number) do$/;"	f
handle_events	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_events(events, _from, number) do$/;"	f
C	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule C do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link() do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(:ok) do$/;"	f
handle_events	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_events(events, _from, state) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^      def init(:ok) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^      def init(:ok) do$/;"	f
Broadcaster	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule Broadcaster do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link() do$/;"	f
sync_notify	nvim/plugged/vim-elixir/large_file.ex	/^        def sync_notify(event, timeout \\\\ 5000) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(:ok) do$/;"	f
handle_call	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_call({:notify, event}, _from, state) do$/;"	f
handle_demand	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_demand(_demand, state) do$/;"	f
QueueBroadcaster	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule QueueBroadcaster do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link() do$/;"	f
sync_notify	nvim/plugged/vim-elixir/large_file.ex	/^        def sync_notify(event, timeout \\\\ 5000) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(:ok) do$/;"	f
handle_call	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_call({:notify, event}, from, {queue, pending_demand}) do$/;"	f
handle_demand	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_demand(incoming_demand, {queue, pending_demand}) do$/;"	f
dispatch_events	nvim/plugged/vim-elixir/large_file.ex	/^        defp dispatch_events(queue, 0, events) do$/;"	f
dispatch_events	nvim/plugged/vim-elixir/large_file.ex	/^        defp dispatch_events(queue, demand, events) do$/;"	f
Printer	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule Printer do$/;"	m
start_link	nvim/plugged/vim-elixir/large_file.ex	/^        def start_link() do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(:ok) do$/;"	f
handle_events	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_events(events, _from, state) do$/;"	f
RateLimiter	nvim/plugged/vim-elixir/large_file.ex	/^      defmodule RateLimiter do$/;"	m
init	nvim/plugged/vim-elixir/large_file.ex	/^        def init(_) do$/;"	f
handle_subscribe	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_subscribe(:producer, opts, from, producers) do$/;"	f
handle_cancel	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_cancel(_, from, producers) do$/;"	f
handle_events	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_events(events, from, producers) do$/;"	f
handle_info	nvim/plugged/vim-elixir/large_file.ex	/^        def handle_info({:ask, from}, producers) do$/;"	f
ask_and_schedule	nvim/plugged/vim-elixir/large_file.ex	/^        defp ask_and_schedule(producers, from) do$/;"	f
init	nvim/plugged/vim-elixir/large_file.ex	/^      def init(args) do$/;"	f
handle_demand	nvim/plugged/vim-elixir/large_file.ex	/^      def handle_demand(demand, state) do$/;"	f
handle_subscribe	nvim/plugged/vim-elixir/large_file.ex	/^      def handle_subscribe(:producer, _options, from, state) do$/;"	f
b:did_ftplugin	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^let b:did_ftplugin = 1$/;"	v
b:match_ignorecase	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^  let b:match_ignorecase = 0$/;"	v
b:match_words	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^  let b:match_words = '\\:\\@<!\\<\\%(do\\|fn\\)\\:\\@!\\>' .$/;"	v
b:block_begin	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^let b:block_begin = '\\<\\(do$\\|fn\\>\\)'$/;"	v
b:block_end	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^let b:block_end = '\\<end\\>'$/;"	v
]]	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^nnoremap <buffer> <silent> <expr> ]] ':silent keeppatterns \/'.b:block_begin.'<CR>'$/;"	m
[[	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^nnoremap <buffer> <silent> <expr> [[ ':silent keeppatterns ?'.b:block_begin.'<CR>'$/;"	m
][	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^nnoremap <buffer> <silent> <expr> ][ ':silent keeppatterns \/'.b:block_end  .'<CR>'$/;"	m
[]	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^nnoremap <buffer> <silent> <expr> [] ':silent keeppatterns ?'.b:block_end  .'<CR>'$/;"	m
]]	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^onoremap <buffer> <silent> <expr> ]] ':silent keeppatterns \/'.b:block_begin.'<CR>'$/;"	m
[[	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^onoremap <buffer> <silent> <expr> [[ ':silent keeppatterns ?'.b:block_begin.'<CR>'$/;"	m
][	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^onoremap <buffer> <silent> <expr> ][ ':silent keeppatterns \/'.b:block_end  .'<CR>'$/;"	m
[]	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^onoremap <buffer> <silent> <expr> [] ':silent keeppatterns ?'.b:block_end  .'<CR>'$/;"	m
b:undo_ftplugin	nvim/plugged/vim-elixir/ftplugin/elixir.vim	/^let b:undo_ftplugin = 'setlocal sw< sts< et< isk< com< cms< path< inex< sua< def< fo<'.$/;"	v
s:save_cpo	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let s:save_cpo = &cpo$/;"	v
s:undo_ftplugin	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let s:undo_ftplugin = ""$/;"	v
s:browsefilter	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let s:browsefilter = "All Files (*.*)\\t*.*\\n"$/;"	v
s:match_words	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let s:match_words = ""$/;"	v
g:eelixir_default_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let g:eelixir_default_subtype = "html"$/;"	v
s:lines	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:lines = join(getline(1, 5) + [getline('$')], "\\n")$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:eelixir_subtype = matchstr(s:lines,'eelixir_subtype=\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = matchstr(&filetype,'^eex\\.\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = matchstr(&filetype,'^leex\\.\\zs\\w\\+')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = matchstr(substitute(expand("%:t"),'\\c\\%(\\.eex\\|\\.leex\\|\\.eelixir\\)\\+$','',''),'\\.\\zs\\w\\+$')$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = 'elixir'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = 'elixir'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = 'yaml'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = 'javascript'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = 'text'$/;"	v
b:eelixir_subtype	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^    let b:eelixir_subtype = g:eelixir_default_subtype$/;"	v
s:undo_ftplugin	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:undo_ftplugin = b:undo_ftplugin$/;"	v
s:browsefilter	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:browsefilter = b:browsefilter$/;"	v
s:match_words	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:match_words = b:match_words$/;"	v
b:did_ftplugin	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let b:did_ftplugin = 1$/;"	v
s:undo_ftplugin	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin$/;"	v
s:browsefilter	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:browsefilter = substitute(b:browsefilter,'\\cAll Files (\\*\\.\\*)\\t\\*\\.\\*\\n','','') . s:browsefilter$/;"	v
s:match_words	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let s:match_words = b:match_words . ',' . s:match_words$/;"	v
b:match_words	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:match_words = s:match_words$/;"	v
b:surround_45	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:surround_45 = "<% \\r %>"$/;"	v
b:surround_61	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:surround_61 = "<%= \\r %>"$/;"	v
b:surround_35	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:surround_35 = "<%# \\r %>"$/;"	v
b:surround_5	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^  let b:surround_5 = "<% \\r %>\\n<% end %>"$/;"	v
b:undo_ftplugin	nvim/plugged/vim-elixir/ftplugin/eelixir.vim	/^let b:undo_ftplugin = "setl cms< " .$/;"	v
DetectElixir	nvim/plugged/vim-elixir/ftdetect/elixir.vim	/^function! s:DetectElixir()$/;"	f
msg	nvim/plugged/coc.nvim/jest.js	/^  let msg = 'Uncaught exception: ' + err.stack$/;"	V
g:did_coc_loaded	nvim/plugged/coc.nvim/plugin/coc.vim	/^let g:did_coc_loaded = 1$/;"	v
g:coc_service_initialized	nvim/plugged/coc.nvim/plugin/coc.vim	/^let g:coc_service_initialized = 0$/;"	v
s:is_win	nvim/plugged/coc.nvim/plugin/coc.vim	/^let s:is_win = has('win32') || has('win64')$/;"	v
s:root	nvim/plugged/coc.nvim/plugin/coc.vim	/^let s:root = expand('<sfile>:h:h')$/;"	v
s:is_vim	nvim/plugged/coc.nvim/plugin/coc.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:is_gvim	nvim/plugged/coc.nvim/plugin/coc.vim	/^let s:is_gvim = get(v:, 'progname', '') ==# 'gvim'$/;"	v
CocAction	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocAction(...) abort$/;"	f
CocHasProvider	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocHasProvider(name) abort$/;"	f
CocActionAsync	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocActionAsync(...) abort$/;"	f
CocRequest	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocRequest(...) abort$/;"	f
CocRegistNotification	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocRegistNotification(id, method, cb) abort$/;"	f
CocLocations	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocLocations(id, method, ...) abort$/;"	f
CocLocationsAsync	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocLocationsAsync(id, method, ...) abort$/;"	f
CocRequestAsync	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! CocRequestAsync(...)$/;"	f
AsyncRequest	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:AsyncRequest(name, args) abort$/;"	f
CommandList	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:CommandList(...) abort$/;"	f
ExtensionList	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:ExtensionList(...) abort$/;"	f
SearchOptions	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:SearchOptions(...) abort$/;"	f
InstallOptions	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:InstallOptions(...)abort$/;"	f
OpenConfig	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:OpenConfig()$/;"	f
OpenLocalConfig	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:OpenLocalConfig()$/;"	f
AddAnsiGroups	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:AddAnsiGroups() abort$/;"	f
CursorRangeFromSelected	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:CursorRangeFromSelected(type, ...) abort$/;"	f
Disable	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:Disable() abort$/;"	f
Autocmd	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:Autocmd(...) abort$/;"	f
SyncAutocmd	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:SyncAutocmd(...)$/;"	f
Enable	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:Enable()$/;"	f
FormatFromSelected	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:FormatFromSelected(type)$/;"	f
CodeActionFromSelected	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:CodeActionFromSelected(type)$/;"	f
ShowInfo	nvim/plugged/coc.nvim/plugin/coc.vim	/^function! s:ShowInfo()$/;"	f
CocInfo	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocInfo         :call s:ShowInfo()$/;"	c
CocOpenLog	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocOpenLog      :call coc#rpc#notify('openLog',  [])$/;"	c
CocListResume	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocListResume   :call coc#rpc#notify('listResume', [])$/;"	c
CocPrev	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocPrev         :call coc#rpc#notify('listPrev', [])$/;"	c
CocNext	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocNext         :call coc#rpc#notify('listNext', [])$/;"	c
CocDisable	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocDisable      :call s:Disable()$/;"	c
CocEnable	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocEnable       :call s:Enable()$/;"	c
CocConfig	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocConfig       :call s:OpenConfig()$/;"	c
CocLocalConfig	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocLocalConfig  :call s:OpenLocalConfig()$/;"	c
CocRestart	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocRestart      :call coc#rpc#restart()$/;"	c
CocStart	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocStart        :call coc#rpc#start_server()$/;"	c
CocRebuild	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocRebuild      :call coc#util#rebuild()$/;"	c
CocSearch	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=+ -complete=custom,s:SearchOptions  CocSearch    :call coc#rpc#notify('search', [<f-args>])$/;"	c
CocUninstall	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=+ -complete=custom,s:ExtensionList  CocUninstall :call coc#rpc#notify('CocAction', ['uninstallExtension', <f-args>])$/;"	c
CocList	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=* -complete=custom,coc#list#options CocList      :call coc#rpc#notify('openList',  [<f-args>])$/;"	c
CocCommand	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=* -complete=custom,s:CommandList -range CocCommand :call coc#rpc#notify('runCommand', [<f-args>])$/;"	c
CocAction	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=* -range CocAction :call coc#rpc#notify('codeActionRange', [<line1>, <line2>, <f-args>])$/;"	c
CocFix	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=* -range CocFix    :call coc#rpc#notify('codeActionRange', [<line1>, <line2>, 'quickfix'])$/;"	c
CocUpdate	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 CocUpdate       :call coc#util#update_extensions(1)$/;"	c
CocUpdateSync	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=0 -bar CocUpdateSync   :call coc#util#update_extensions()$/;"	c
CocInstall	nvim/plugged/coc.nvim/plugin/coc.vim	/^command! -nargs=* -bar -complete=custom,s:InstallOptions CocInstall   :call coc#util#install_extension([<f-args>])$/;"	c
<Plug>(coc-range-select)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <Plug>(coc-range-select)          :<C-u>call       CocAction('rangeSelect',     visualmode(), v:true)<CR>$/;"	m
<Plug>(coc-range-select-backward)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <Plug>(coc-range-select-backward) :<C-u>call       CocAction('rangeSelect',     visualmode(), v:false)<CR>$/;"	m
<Plug>(coc-range-select)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-range-select)          :<C-u>call       CocAction('rangeSelect',     '', v:true)<CR>$/;"	m
<Plug>(coc-codelens-action)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-codelens-action)       :<C-u>call       CocActionAsync('codeLensAction')<CR>$/;"	m
<Plug>(coc-format-selected)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <Plug>(coc-format-selected)       :<C-u>call       CocActionAsync('formatSelected',     visualmode())<CR>$/;"	m
<Plug>(coc-codeaction-selected)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <Plug>(coc-codeaction-selected)   :<C-u>call       CocActionAsync('codeAction',         visualmode())<CR>$/;"	m
<Plug>(coc-codeaction-selected)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-codeaction-selected)   :<C-u>set        operatorfunc=<SID>CodeActionFromSelected<CR>g@$/;"	m
<Plug>(coc-codeaction)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-codeaction)            :<C-u>call       CocActionAsync('codeAction',         '')<CR>$/;"	m
<Plug>(coc-rename)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-rename)                :<C-u>call       CocActionAsync('rename')<CR>$/;"	m
<Plug>(coc-format-selected)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-format-selected)       :<C-u>set        operatorfunc=<SID>FormatFromSelected<CR>g@$/;"	m
<Plug>(coc-format)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-format)                :<C-u>call       CocActionAsync('format')<CR>$/;"	m
<Plug>(coc-diagnostic-info)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-diagnostic-info)       :<C-u>call       CocActionAsync('diagnosticInfo')<CR>$/;"	m
<Plug>(coc-diagnostic-next)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-diagnostic-next)       :<C-u>call       CocActionAsync('diagnosticNext')<CR>$/;"	m
<Plug>(coc-diagnostic-prev)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-diagnostic-prev)       :<C-u>call       CocActionAsync('diagnosticPrevious')<CR>$/;"	m
<Plug>(coc-diagnostic-next-error)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-diagnostic-next-error) :<C-u>call       CocActionAsync('diagnosticNext',     'error')<CR>$/;"	m
<Plug>(coc-diagnostic-prev-error)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-diagnostic-prev-error) :<C-u>call       CocActionAsync('diagnosticPrevious', 'error')<CR>$/;"	m
<Plug>(coc-definition)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-definition)            :<C-u>call       CocAction('jumpDefinition')<CR>$/;"	m
<Plug>(coc-declaration)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-declaration)           :<C-u>call       CocAction('jumpDeclaration')<CR>$/;"	m
<Plug>(coc-implementation)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-implementation)        :<C-u>call       CocAction('jumpImplementation')<CR>$/;"	m
<Plug>(coc-type-definition)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-type-definition)       :<C-u>call       CocAction('jumpTypeDefinition')<CR>$/;"	m
<Plug>(coc-references)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-references)            :<C-u>call       CocAction('jumpReferences')<CR>$/;"	m
<Plug>(coc-openlink)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-openlink)              :<C-u>call       CocActionAsync('openLink')<CR>$/;"	m
<Plug>(coc-fix-current)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-fix-current)           :<C-u>call       CocActionAsync('doQuickfix')<CR>$/;"	m
<Plug>(coc-float-hide)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-float-hide)            :<C-u>call       coc#util#float_hide()<CR>$/;"	m
<Plug>(coc-float-jump)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-float-jump)            :<c-u>call       coc#util#float_jump()<cr>$/;"	m
<Plug>(coc-command-repeat)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-command-repeat)        :<C-u>call       CocAction('repeatCommand')<CR>$/;"	m
<Plug>(coc-refactor)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <Plug>(coc-refactor)              :<C-u>call       CocActionAsync('refactor')<CR>$/;"	m
<Plug>CocRefresh	nvim/plugged/coc.nvim/plugin/coc.vim	/^inoremap <silent>                          <Plug>CocRefresh <C-r>=coc#_complete()<CR>$/;"	m
<Plug>(coc-cursors-operator)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <silent> <Plug>(coc-cursors-operator) :<C-u>set operatorfunc=<SID>CursorRangeFromSelected<CR>g@$/;"	m
<Plug>(coc-cursors-range)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <silent> <Plug>(coc-cursors-range)    :<C-u>call coc#rpc#request('cursorsSelect', [bufnr('%'), 'range', visualmode()])<CR>$/;"	m
<Plug>(coc-cursors-word)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <silent> <Plug>(coc-cursors-word)     :<C-u>call coc#rpc#request('cursorsSelect', [bufnr('%'), 'word', 'n'])<CR>$/;"	m
<Plug>(coc-cursors-position)	nvim/plugged/coc.nvim/plugin/coc.vim	/^nnoremap <silent> <Plug>(coc-cursors-position) :<C-u>call coc#rpc#request('cursorsSelect', [bufnr('%'), 'position', 'n'])<CR>$/;"	m
<Plug>(coc-funcobj-i)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call coc#rpc#request('selectFunction', [v:true, visualmode()])<CR>$/;"	m
<Plug>(coc-funcobj-a)	nvim/plugged/coc.nvim/plugin/coc.vim	/^vnoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call coc#rpc#request('selectFunction', [v:false, visualmode()])<CR>$/;"	m
<Plug>(coc-funcobj-i)	nvim/plugged/coc.nvim/plugin/coc.vim	/^onoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call coc#rpc#request('selectFunction', [v:true, ''])<CR>$/;"	m
<Plug>(coc-funcobj-a)	nvim/plugged/coc.nvim/plugin/coc.vim	/^onoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call coc#rpc#request('selectFunction', [v:false, ''])<CR>$/;"	m
value	nvim/plugged/coc.nvim/bin/server.js	/^  value: function () {$/;"	M
msg	nvim/plugged/coc.nvim/bin/server.js	/^  let msg = 'Uncaught exception: ' + err.stack$/;"	V
terminateTree	nvim/plugged/coc.nvim/bin/terminateProcess.sh	/^terminateTree() {$/;"	f
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:channel_map	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^let s:channel_map = {}$/;"	v
s:is_win	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^let s:is_win = has('win32') || has('win64')$/;"	v
coc#terminal#start	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^function! coc#terminal#start(cmd, cwd, env) abort$/;"	f
job_id	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let job_id = termopen(a:cmd, {$/;"	v
s:channel_map	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let s:channel_map[bufnr] = job_id$/;"	v
cmd	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let cmd = s:is_win ? join(a:cmd, ' ') : a:cmd$/;"	v
res	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let res = term_start(cmd, {$/;"	v
job	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let job = term_getjob(bufnr)$/;"	v
s:channel_map	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^    let s:channel_map[bufnr] = job_getchannel(job)$/;"	v
coc#terminal#send	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^function! coc#terminal#send(bufnr, text, add_new_line) abort$/;"	f
coc#terminal#close	nvim/plugged/coc.nvim/autoload/coc/terminal.vim	/^function! coc#terminal#close(bufnr) abort$/;"	f
s:funcs	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^let s:funcs = {}$/;"	v
s:prop_id	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^let s:prop_id = 1000$/;"	v
s:namespace_id	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^let s:namespace_id = 1$/;"	v
s:namespace_cache	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^let s:namespace_cache = {}$/;"	v
buf_line_count	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:buf_line_count(bufnr) abort$/;"	f
execute	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:execute(cmd)$/;"	f
funcs.set_current_dir	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_current_dir(dir) abort$/;"	f
funcs.set_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_var(name, value) abort$/;"	f
funcs.del_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.del_var(name) abort$/;"	f
funcs.set_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_option(name, value) abort$/;"	f
funcs.set_current_buf	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_current_buf(bufnr) abort$/;"	f
funcs.set_current_win	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_current_win(win_id) abort$/;"	f
funcs.set_current_tabpage	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_current_tabpage(tabnr) abort$/;"	f
funcs.list_wins	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.list_wins() abort$/;"	f
funcs.call_atomic	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.call_atomic(calls)$/;"	f
funcs.set_client_info	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_client_info(...) abort$/;"	f
funcs.subscribe	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.subscribe(...) abort$/;"	f
funcs.unsubscribe	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.unsubscribe(...) abort$/;"	f
funcs.call_function	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.call_function(method, args) abort$/;"	f
funcs.call_dict_function	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.call_dict_function(dict, method, args) abort$/;"	f
funcs.command	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.command(command) abort$/;"	f
funcs.eval	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.eval(expr) abort$/;"	f
funcs.get_api_info	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_api_info()$/;"	f
funcs.list_bufs	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.list_bufs()$/;"	f
funcs.feedkeys	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.feedkeys(keys, mode, escape_csi)$/;"	f
funcs.list_runtime_paths	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.list_runtime_paths()$/;"	f
funcs.command_output	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.command_output(cmd)$/;"	f
funcs.get_current_line	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_current_line()$/;"	f
funcs.set_current_line	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.set_current_line(line)$/;"	f
funcs.del_current_line	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.del_current_line(line)$/;"	f
funcs.get_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_var(var)$/;"	f
funcs.get_vvar	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_vvar(var)$/;"	f
funcs.get_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_option(name)$/;"	f
funcs.get_current_buf	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_current_buf()$/;"	f
funcs.get_current_win	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_current_win()$/;"	f
funcs.get_current_tabpage	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_current_tabpage()$/;"	f
funcs.list_tabpages	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.list_tabpages()$/;"	f
funcs.get_mode	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.get_mode()$/;"	f
funcs.strwidth	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.strwidth(str)$/;"	f
funcs.out_write	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.out_write(str)$/;"	f
funcs.err_write	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.err_write(str)$/;"	f
funcs.err_writeln	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.err_writeln(str)$/;"	f
funcs.create_namespace	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.create_namespace(name) abort$/;"	f
funcs.buf_set_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_set_option(bufnr, name, val)$/;"	f
funcs.buf_get_changedtick	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_changedtick(bufnr)$/;"	f
funcs.buf_is_valid	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_is_valid(bufnr)$/;"	f
funcs.buf_get_mark	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_mark(bufnr, name)$/;"	f
funcs.buf_add_highlight	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_add_highlight(bufnr, srcId, hlGroup, line, colStart, colEnd) abort$/;"	f
funcs.buf_clear_namespace	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_clear_namespace(bufnr, srcId, startLine, endLine) abort$/;"	f
funcs.buf_line_count	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_line_count(bufnr) abort$/;"	f
funcs.buf_attach	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_attach(...)$/;"	f
funcs.buf_detach	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_detach()$/;"	f
funcs.buf_get_lines	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_lines(bufnr, start, end, strict) abort$/;"	f
funcs.buf_set_lines	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_set_lines(bufnr, start, end, strict, ...) abort$/;"	f
funcs.buf_set_name	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_set_name(bufnr, name) abort$/;"	f
funcs.buf_get_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_var(bufnr, name)$/;"	f
funcs.buf_set_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_set_var(bufnr, name, val)$/;"	f
funcs.buf_del_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_del_var(bufnr, name)$/;"	f
funcs.buf_get_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_option(bufnr, name)$/;"	f
funcs.buf_get_name	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.buf_get_name(bufnr)$/;"	f
funcs.win_get_buf	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_buf(winid)$/;"	f
funcs.win_get_position	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_position(win_id) abort$/;"	f
funcs.win_get_height	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_height(win_id) abort$/;"	f
funcs.win_get_width	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_width(win_id) abort$/;"	f
funcs.win_get_cursor	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_cursor(win_id) abort$/;"	f
funcs.win_get_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_var(win_id, name) abort$/;"	f
funcs.win_set_width	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_set_width(win_id, width) abort$/;"	f
funcs.win_get_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_option(win_id, name) abort$/;"	f
funcs.win_set_height	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_set_height(win_id, height) abort$/;"	f
funcs.win_set_option	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_set_option(win_id, name, value) abort$/;"	f
funcs.win_set_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_set_var(win_id, name, value) abort$/;"	f
funcs.win_del_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_del_var(win_id, name) abort$/;"	f
funcs.win_is_valid	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_is_valid(win_id) abort$/;"	f
funcs.win_get_number	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_number(win_id) abort$/;"	f
funcs.win_set_cursor	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_set_cursor(win_id, pos) abort$/;"	f
funcs.win_close	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_close(win_id, ...) abort$/;"	f
funcs.win_get_tabpage	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.win_get_tabpage(win_id) abort$/;"	f
funcs.tabpage_get_number	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_get_number(id)$/;"	f
funcs.tabpage_list_wins	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_list_wins(tabnr)$/;"	f
funcs.tabpage_get_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_get_var(tabnr, name)$/;"	f
funcs.tabpage_set_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_set_var(tabnr, name, value)$/;"	f
funcs.tabpage_del_var	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_del_var(tabnr, name)$/;"	f
funcs.tabpage_is_valid	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_is_valid(tabnr)$/;"	f
funcs.tabpage_get_win	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! s:funcs.tabpage_get_win(tabnr)$/;"	f
coc#api#func_names	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! coc#api#func_names() abort$/;"	f
coc#api#call	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! coc#api#call(method, args) abort$/;"	f
coc#api#notify	nvim/plugged/coc.nvim/autoload/coc/api.vim	/^function! coc#api#notify(method, args) abort$/;"	f
s:root	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^let s:root = expand('<sfile>:h:h:h')$/;"	v
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:is_win	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^let s:is_win = has("win32") || has("win64")$/;"	v
s:clients	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^let s:clients = {}$/;"	v
s:logfile	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^let s:logfile = tempname()$/;"	v
coc#client#create	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#create(name, command)$/;"	f
start	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:start() dict$/;"	f
on_stderr	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:on_stderr(name, msgs)$/;"	f
on_exit	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:on_exit(name, code) abort$/;"	f
get_channel	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:get_channel(client)$/;"	f
request	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:request(method, args) dict$/;"	f
notify	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:notify(method, args) dict$/;"	f
request_async	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:request_async(method, args, cb) dict$/;"	f
on_async_response	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! s:on_async_response(id, resp, isErr) dict$/;"	f
coc#client#is_running	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#is_running(name) abort$/;"	f
coc#client#stop	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#stop(name) abort$/;"	f
coc#client#request	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#request(name, method, args)$/;"	f
coc#client#notify	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#notify(name, method, args)$/;"	f
coc#client#request_async	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#request_async(name, method, args, cb)$/;"	f
coc#client#on_response	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#on_response(name, id, resp, isErr)$/;"	f
coc#client#restart	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#restart(name) abort$/;"	f
coc#client#restart_all	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#restart_all()$/;"	f
coc#client#open_log	nvim/plugged/coc.nvim/autoload/coc/client.vim	/^function! coc#client#open_log()$/;"	f
s:root	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^let s:root = expand('<sfile>:h:h:h')$/;"	v
s:is_win	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^let s:is_win = has('win32') || has('win64')$/;"	v
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:activate	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^let s:activate = ""$/;"	v
s:quit	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^let s:quit = ""$/;"	v
s:app	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:app = "MacVim"$/;"	v
s:app	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:app = "Terminal"$/;"	v
s:app	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:app = "iTerm2"$/;"	v
s:app	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:app = "System Events"$/;"	v
s:quit	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:quit = "quit"$/;"	v
s:activate	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let s:activate = 'activate'$/;"	v
coc#util#has_preview	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#has_preview()$/;"	f
coc#util#has_float	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#has_float()$/;"	f
coc#util#get_float	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_float()$/;"	f
coc#util#float_hide	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#float_hide()$/;"	f
coc#util#float_jump	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#float_jump()$/;"	f
coc#util#float_scrollable	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#float_scrollable()$/;"	f
coc#util#float_scroll	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#float_scroll(forward)$/;"	f
coc#util#cursor	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#cursor()$/;"	f
coc#util#close_win	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#close_win(id)$/;"	f
coc#util#close	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#close(id) abort$/;"	f
coc#util#win_position	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#win_position()$/;"	f
coc#util#close_popup	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#close_popup()$/;"	f
coc#util#version	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#version()$/;"	f
coc#util#valid_state	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#valid_state()$/;"	f
coc#util#open_file	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#open_file(cmd, file)$/;"	f
coc#util#platform	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#platform()$/;"	f
coc#util#remote_fns	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#remote_fns(name)$/;"	f
coc#util#job_command	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#job_command()$/;"	f
coc#util#echo_hover	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#echo_hover(msg)$/;"	f
coc#util#execute	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#execute(cmd)$/;"	f
coc#util#jump	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#jump(cmd, filepath, ...) abort$/;"	f
coc#util#jumpTo	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#jumpTo(line, character) abort$/;"	f
coc#util#echo_messages	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#echo_messages(hl, msgs)$/;"	f
coc#util#echo_lines	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#echo_lines(lines)$/;"	f
coc#util#timer	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#timer(method, args)$/;"	f
Call	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! s:Call(method, args)$/;"	f
coc#util#is_preview	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#is_preview(bufnr)$/;"	f
coc#util#get_bufoptions	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_bufoptions(bufnr) abort$/;"	f
variables	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! s:variables(bufnr) abort$/;"	f
coc#util#root_patterns	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#root_patterns()$/;"	f
coc#util#on_error	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#on_error(msg) abort$/;"	f
coc#util#preview_info	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#preview_info(info, ...) abort$/;"	f
coc#util#get_config_home	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_config_home()$/;"	f
coc#util#get_input	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_input()$/;"	f
coc#util#move_cursor	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#move_cursor(delta)$/;"	f
coc#util#get_complete_option	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_complete_option()$/;"	f
coc#util#with_callback	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#with_callback(method, args, cb)$/;"	f
timeout	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^  let timeout = s:is_vim ? 10 : 0$/;"	v
coc#util#add_matchids	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#add_matchids(ids)$/;"	f
coc#util#prompt_confirm	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#prompt_confirm(title)$/;"	f
coc#util#get_syntax_name	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_syntax_name(lnum, col)$/;"	f
coc#util#echo_signatures	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#echo_signatures(signatures) abort$/;"	f
echo_signature	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! s:echo_signature(parts)$/;"	f
coc#util#unplace_signs	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#unplace_signs(bufnr, sign_ids)$/;"	f
coc#util#setline	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#setline(lnum, line)$/;"	f
coc#util#open_terminal	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#open_terminal(opts) abort$/;"	f
cmd	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^      let cmd = 'cmd.exe \/C "'.cmd.'"'$/;"	v
coc#util#run_terminal	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#run_terminal(opts, cb)$/;"	f
coc#util#getpid	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#getpid()$/;"	f
coc#util#vim_info	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#vim_info()$/;"	f
coc#util#highlight_options	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#highlight_options()$/;"	f
coc#util#get_content	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_content(bufnr)$/;"	f
coc#util#get_changeinfo	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#get_changeinfo()$/;"	f
coc#util#diff_content	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#diff_content(lines) abort$/;"	f
coc#util#clear_signs	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#clear_signs()$/;"	f
coc#util#clearmatches	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#clearmatches(ids, ...)$/;"	f
coc#util#open_url	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#open_url(url)$/;"	f
coc#util#install	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#install(...) abort$/;"	f
coc#util#do_complete	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#do_complete(name, opt, cb) abort$/;"	f
coc#util#extension_root	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#extension_root() abort$/;"	f
coc#util#update_extensions	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#update_extensions(...) abort$/;"	f
coc#util#install_extension	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#install_extension(args) abort$/;"	f
coc#util#do_autocmd	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#do_autocmd(name) abort$/;"	f
coc#util#rebuild	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#rebuild()$/;"	f
coc#util#echo_line	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#echo_line()$/;"	f
coc#util#pick_color	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#pick_color(default_color)$/;"	f
coc#util#iterm_open	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#iterm_open(dir)$/;"	f
osascript	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! s:osascript(...) abort$/;"	f
system	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! s:system(cmd)$/;"	f
coc#util#pclose	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#pclose()$/;"	f
coc#util#init_virtual_hl	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#init_virtual_hl()$/;"	f
coc#util#set_buf_var	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#set_buf_var(bufnr, name, val) abort$/;"	f
coc#util#change_lines	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#change_lines(bufnr, list) abort$/;"	f
coc#util#unmap	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#unmap(bufnr, keys) abort$/;"	f
coc#util#open_files	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#open_files(files)$/;"	f
coc#util#refactor_foldlevel	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#refactor_foldlevel(lnum) abort$/;"	f
coc#util#refactor_fold_text	nvim/plugged/coc.nvim/autoload/coc/util.vim	/^function! coc#util#refactor_fold_text(lnum) abort$/;"	f
s:activated	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^let s:activated = 0$/;"	v
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:saved_ve	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^let s:saved_ve = &t_ve$/;"	v
s:saved_cursor	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^let s:saved_cursor = &guicursor$/;"	v
s:gui	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^let s:gui = has('gui_running') || has('nvim')$/;"	v
coc#list#get_chars	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#get_chars()$/;"	f
coc#list#getc	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#getc() abort$/;"	f
coc#list#getchar	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#getchar() abort$/;"	f
coc#list#prompt_start	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#prompt_start() abort$/;"	f
coc#list#start_prompt	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#start_prompt()$/;"	f
coc#list#setlines	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#setlines(lines, append)$/;"	f
coc#list#options	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#options(...)$/;"	f
coc#list#stop_prompt	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#stop_prompt(...)$/;"	f
coc#list#status	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#status(name)$/;"	f
coc#list#create	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#create(position, height, name, numberSelect)$/;"	f
coc#list#setup	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#setup(source)$/;"	f
coc#list#has_preview	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#has_preview()$/;"	f
coc#list#restore	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#restore(winid, height)$/;"	f
coc#list#set_height	nvim/plugged/coc.nvim/autoload/coc/list.vim	/^function! coc#list#set_height(height) abort$/;"	f
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:map_next	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^let s:map_next = 1$/;"	v
coc#snippet#_select_mappings	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^function! coc#snippet#_select_mappings()$/;"	f
coc#snippet#show_choices	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^function! coc#snippet#show_choices(lnum, col, len, values) abort$/;"	f
coc#snippet#enable	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^function! coc#snippet#enable()$/;"	f
coc#snippet#disable	nvim/plugged/coc.nvim/autoload/coc/snippet.vim	/^function! coc#snippet#disable()$/;"	f
s:is_win	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^let s:is_win = has("win32") || has("win64")$/;"	v
s:client	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^let s:client = v:null$/;"	v
s:name	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^let s:name = 'coc'$/;"	v
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^let s:is_vim = !has('nvim')$/;"	v
coc#rpc#start_server	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#start_server()$/;"	f
coc#rpc#started	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#started() abort$/;"	f
coc#rpc#ready	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#ready()$/;"	f
ChannelSet	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! s:ChannelSet(dict, key, val)$/;"	f
coc#rpc#kill	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#kill()$/;"	f
coc#rpc#get_errors	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#get_errors()$/;"	f
coc#rpc#stop	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#stop()$/;"	f
coc#rpc#restart	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#restart()$/;"	f
coc#rpc#request	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#request(method, args) abort$/;"	f
coc#rpc#notify	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#notify(method, args) abort$/;"	f
coc#rpc#request_async	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#request_async(method, args, cb) abort$/;"	f
coc#rpc#async_response	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#async_response(id, resp, isErr) abort$/;"	f
coc#rpc#async_request	nvim/plugged/coc.nvim/autoload/coc/rpc.vim	/^function! coc#rpc#async_request(id, method, args)$/;"	f
s:is_vim	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:running_task	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^let s:running_task = {}$/;"	v
coc#task#start	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! coc#task#start(id, opts)$/;"	f
coc#task#stop	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! coc#task#stop(id)$/;"	f
on_exit	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! s:on_exit(id, code) abort$/;"	f
on_stderr	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! s:on_stderr(id, msgs)$/;"	f
on_stdout	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! s:on_stdout(id, msgs)$/;"	f
coc#task#running	nvim/plugged/coc.nvim/autoload/coc/task.vim	/^function! coc#task#running(id)$/;"	f
g:coc#_context	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}$/;"	v
g:coc_user_config	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc_user_config = get(g:, 'coc_user_config', {})$/;"	v
g:coc_global_extensions	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc_global_extensions = get(g:, 'coc_global_extensions', [])$/;"	v
g:coc_cygqwin_path_prefixes	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc_cygqwin_path_prefixes = get(g:, 'coc_cygqwin_path_prefixes', {})$/;"	v
g:coc_selected_text	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc_selected_text = ''$/;"	v
g:coc_vim_commands	nvim/plugged/coc.nvim/autoload/coc.vim	/^let g:coc_vim_commands = []$/;"	v
s:watched_keys	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:watched_keys = []$/;"	v
s:is_vim	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:is_vim = !has('nvim')$/;"	v
s:error_sign	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:error_sign = get(g:, 'coc_status_error_sign', has('mac') ? '❌ ' : 'E')$/;"	v
s:warning_sign	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:warning_sign = get(g:, 'coc_status_warning_sign', has('mac') ? '⚠️ ' : 'W')$/;"	v
s:select_api	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:select_api = exists('*nvim_select_popupmenu_item')$/;"	v
s:callbacks	nvim/plugged/coc.nvim/autoload/coc.vim	/^let s:callbacks = {}$/;"	v
coc#expandable	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#expandable() abort$/;"	f
coc#jumpable	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#jumpable() abort$/;"	f
coc#expandableOrJumpable	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#expandableOrJumpable() abort$/;"	f
coc#add_command	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#add_command(id, cmd, ...)$/;"	f
coc#refresh	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#refresh() abort$/;"	f
coc#on_enter	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#on_enter()$/;"	f
coc#_insert_key	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_insert_key(method, key, ...) abort$/;"	f
coc#_complete	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_complete() abort$/;"	f
coc#_do_complete	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_do_complete(start, items, preselect)$/;"	f
coc#_select_confirm	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_select_confirm()$/;"	f
coc#_selected	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_selected()$/;"	f
coc#_hide	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_hide() abort$/;"	f
coc#_cancel	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_cancel()$/;"	f
coc#_select	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_select() abort$/;"	f
coc#start	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#start(...)$/;"	f
coc#status	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#status()$/;"	f
trim	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! s:trim(str)$/;"	f
coc#config	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#config(section, value)$/;"	f
coc#add_extension	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#add_extension(...)$/;"	f
coc#_watch	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_watch(key)$/;"	f
coc#_unwatch	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_unwatch(key)$/;"	f
GlobalChange	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! s:GlobalChange(dict, key, val)$/;"	f
coc#_map	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_map()$/;"	f
coc#_unmap	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#_unmap()$/;"	f
coc#on_notify	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#on_notify(id, method, Cb)$/;"	f
coc#do_notify	nvim/plugged/coc.nvim/autoload/coc.vim	/^function! coc#do_notify(id, method, result)$/;"	f
s:root	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^let s:root = expand('<sfile>:h:h:h')$/;"	v
checkEnvironment	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^function! s:checkEnvironment() abort$/;"	f
checkCommand	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^function! s:checkCommand()$/;"	f
checkAutocmd	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^function! s:checkAutocmd()$/;"	f
checkInitailize	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^function! s:checkInitailize() abort$/;"	f
health#coc#check	nvim/plugged/coc.nvim/autoload/health/coc.vim	/^function! health#coc#check() abort$/;"	f
command_exists	nvim/plugged/coc.nvim/install.sh	/^command_exists() {$/;"	f
fetch	nvim/plugged/coc.nvim/install.sh	/^fetch() {$/;"	f
get_latest_release	nvim/plugged/coc.nvim/install.sh	/^get_latest_release() {$/;"	f
download	nvim/plugged/coc.nvim/install.sh	/^download() {$/;"	f
CompletionSource	nvim/plugged/coc.nvim/src/languages.ts	/^export interface CompletionSource {$/;"	i
CompleteConfig	nvim/plugged/coc.nvim/src/languages.ts	/^interface CompleteConfig {$/;"	i
fixDocumentation	nvim/plugged/coc.nvim/src/languages.ts	/^function fixDocumentation(str: string): string {$/;"	f
fixDocumentation	nvim/plugged/coc.nvim/src/languages.ts	/^function fixDocumentation(str: string): string {$/;"	f
fixDocumentation	nvim/plugged/coc.nvim/src/languages.ts	/^function fixDocumentation(str: string): string {$/;"	f
check	nvim/plugged/coc.nvim/src/languages.ts	/^export function check<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
check	nvim/plugged/coc.nvim/src/languages.ts	/^export function check<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
check	nvim/plugged/coc.nvim/src/languages.ts	/^export function check<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
Languages	nvim/plugged/coc.nvim/src/languages.ts	/^class Languages {$/;"	c
completeConfig	nvim/plugged/coc.nvim/src/languages.ts	/^  private completeConfig: CompleteConfig$/;"	m
onTypeFormatManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private onTypeFormatManager = new OnTypeFormatManager()$/;"	m
documentLinkManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private documentLinkManager = new DocumentLinkManager()$/;"	m
documentColorManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private documentColorManager = new DocumentColorManager()$/;"	m
foldingRangeManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private foldingRangeManager = new FoldingRangeManager()$/;"	m
renameManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private renameManager = new RenameManager()$/;"	m
formatManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private formatManager = new FormatManager()$/;"	m
codeActionManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private codeActionManager = new CodeActionManager()$/;"	m
workspaceSymbolsManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private workspaceSymbolsManager = new WorkspaceSymbolManager()$/;"	m
formatRangeManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private formatRangeManager = new FormatRangeManager()$/;"	m
hoverManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private hoverManager = new HoverManager()$/;"	m
signatureManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private signatureManager = new SignatureManager()$/;"	m
documentSymbolManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private documentSymbolManager = new DocumentSymbolManager()$/;"	m
documentHighlightManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private documentHighlightManager = new DocumentHighlightManager()$/;"	m
definitionManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private definitionManager = new DefinitionManager()$/;"	m
declarationManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private declarationManager = new DeclarationManager()$/;"	m
typeDefinitionManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private typeDefinitionManager = new TypeDefinitionManager()$/;"	m
referenceManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private referenceManager = new ReferenceManager()$/;"	m
implementationManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private implementationManager = new ImplementationManager()$/;"	m
codeLensManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private codeLensManager = new CodeLensManager()$/;"	m
selectionRangeManager	nvim/plugged/coc.nvim/src/languages.ts	/^  private selectionRangeManager = new SelectionRangeManager()$/;"	m
cancelTokenSource	nvim/plugged/coc.nvim/src/languages.ts	/^  private cancelTokenSource: CancellationTokenSource = new CancellationTokenSource()$/;"	m
completionItemKindMap	nvim/plugged/coc.nvim/src/languages.ts	/^  private completionItemKindMap: Map<CompletionItemKind, string>$/;"	m
nvim	nvim/plugged/coc.nvim/src/languages.ts	/^  private get nvim(): Neovim {$/;"	m
loadCompleteConfig	nvim/plugged/coc.nvim/src/languages.ts	/^  private loadCompleteConfig(): void {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/languages.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/languages.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/languages.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
registerOnTypeFormattingEditProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerOnTypeFormattingEditProvider($/;"	m
registerCompletionItemProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerCompletionItemProvider($/;"	m
registerCodeActionProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerCodeActionProvider(selector: DocumentSelector, provider: CodeActionProvider, clientId: string, codeActionKinds?: CodeActionKind[]): Disposable {$/;"	m
registerHoverProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerHoverProvider(selector: DocumentSelector, provider: HoverProvider): Disposable {$/;"	m
registerSelectionRangeProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerSelectionRangeProvider(selector: DocumentSelector, provider: SelectionRangeProvider): Disposable {$/;"	m
registerSignatureHelpProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerSignatureHelpProvider($/;"	m
registerDocumentSymbolProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentSymbolProvider(selector: DocumentSelector, provider: DocumentSymbolProvider): Disposable {$/;"	m
registerFoldingRangeProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerFoldingRangeProvider(selector: DocumentSelector, provider: FoldingRangeProvider): Disposable {$/;"	m
registerDocumentHighlightProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentHighlightProvider(selector: DocumentSelector, provider: any): Disposable {$/;"	m
registerCodeLensProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerCodeLensProvider(selector: DocumentSelector, provider: CodeLensProvider): Disposable {$/;"	m
registerDocumentLinkProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentLinkProvider(selector: DocumentSelector, provider: DocumentLinkProvider): Disposable {$/;"	m
registerDocumentColorProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentColorProvider(selector: DocumentSelector, provider: DocumentColorProvider): Disposable {$/;"	m
registerDefinitionProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDefinitionProvider(selector: DocumentSelector, provider: DefinitionProvider): Disposable {$/;"	m
registerDeclarationProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDeclarationProvider(selector: DocumentSelector, provider: DeclarationProvider): Disposable {$/;"	m
registerTypeDefinitionProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerTypeDefinitionProvider(selector: DocumentSelector, provider: TypeDefinitionProvider): Disposable {$/;"	m
registerImplementationProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerImplementationProvider(selector: DocumentSelector, provider: ImplementationProvider): Disposable {$/;"	m
registerReferencesProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerReferencesProvider(selector: DocumentSelector, provider: ReferenceProvider): Disposable {$/;"	m
registerRenameProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerRenameProvider(selector: DocumentSelector, provider: RenameProvider): Disposable {$/;"	m
registerWorkspaceSymbolProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerWorkspaceSymbolProvider(selector: DocumentSelector, provider: WorkspaceSymbolProvider): Disposable {$/;"	m
registerDocumentFormatProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentFormatProvider(selector: DocumentSelector, provider: DocumentFormattingEditProvider, priority = 0): Disposable {$/;"	m
registerDocumentRangeFormatProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public registerDocumentRangeFormatProvider(selector: DocumentSelector, provider: DocumentRangeFormattingEditProvider, priority = 0): Disposable {$/;"	m
shouldTriggerSignatureHelp	nvim/plugged/coc.nvim/src/languages.ts	/^  public shouldTriggerSignatureHelp(document: TextDocument, triggerCharacter: string): boolean {$/;"	m
getHover	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getHover(document: TextDocument, position: Position): Promise<Hover[]> {$/;"	m
getSignatureHelp	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getSignatureHelp(document: TextDocument, position: Position, token: CancellationToken): Promise<SignatureHelp> {$/;"	m
getDefinition	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getDefinition(document: TextDocument, position: Position): Promise<Location[]> {$/;"	m
getDeclaration	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getDeclaration(document: TextDocument, position: Position): Promise<Location[] | Location | LocationLink[] | null> {$/;"	m
getTypeDefinition	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getTypeDefinition(document: TextDocument, position: Position): Promise<Location[]> {$/;"	m
getImplementation	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getImplementation(document: TextDocument, position: Position): Promise<Location[]> {$/;"	m
getReferences	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getReferences(document: TextDocument, context: ReferenceContext, position: Position): Promise<Location[]> {$/;"	m
getDocumentSymbol	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getDocumentSymbol(document: TextDocument): Promise<SymbolInformation[] | DocumentSymbol[]> {$/;"	m
getSelectionRanges	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getSelectionRanges(document: TextDocument, positions: Position[]): Promise<SelectionRange[] | null> {$/;"	m
getWorkspaceSymbols	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getWorkspaceSymbols(document: TextDocument, query: string): Promise<SymbolInformation[]> {$/;"	m
resolveWorkspaceSymbol	nvim/plugged/coc.nvim/src/languages.ts	/^  public async resolveWorkspaceSymbol(symbol: SymbolInformation): Promise<SymbolInformation> {$/;"	m
provideRenameEdits	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideRenameEdits(document: TextDocument, position: Position, newName: string): Promise<WorkspaceEdit> {$/;"	m
prepareRename	nvim/plugged/coc.nvim/src/languages.ts	/^  public async prepareRename(document: TextDocument, position: Position): Promise<Range | { range: Range; placeholder: string } | false> {$/;"	m
provideDocumentFormattingEdits	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideDocumentFormattingEdits(document: TextDocument, options: FormattingOptions): Promise<TextEdit[]> {$/;"	m
provideDocumentRangeFormattingEdits	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideDocumentRangeFormattingEdits(document: TextDocument, range: Range, options: FormattingOptions): Promise<TextEdit[]> {$/;"	m
getCodeActions	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getCodeActions(document: TextDocument, range: Range, context: CodeActionContext, silent = false): Promise<Map<string, CodeAction[]>> {$/;"	m
getDocumentHighLight	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getDocumentHighLight(document: TextDocument, position: Position): Promise<DocumentHighlight[]> {$/;"	m
getDocumentLinks	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getDocumentLinks(document: TextDocument): Promise<DocumentLink[]> {$/;"	m
resolveDocumentLink	nvim/plugged/coc.nvim/src/languages.ts	/^  public async resolveDocumentLink(link: DocumentLink): Promise<DocumentLink> {$/;"	m
provideDocumentColors	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideDocumentColors(document: TextDocument): Promise<ColorInformation[] | null> {$/;"	m
provideFoldingRanges	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideFoldingRanges(document: TextDocument, context: FoldingContext): Promise<FoldingRange[] | null> {$/;"	m
provideColorPresentations	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideColorPresentations(color: ColorInformation, document: TextDocument, ): Promise<ColorPresentation[]> {$/;"	m
getCodeLens	nvim/plugged/coc.nvim/src/languages.ts	/^  public async getCodeLens(document: TextDocument): Promise<CodeLens[]> {$/;"	m
resolveCodeLens	nvim/plugged/coc.nvim/src/languages.ts	/^  public async resolveCodeLens(codeLens: CodeLens): Promise<CodeLens> {$/;"	m
provideDocumentOnTypeEdits	nvim/plugged/coc.nvim/src/languages.ts	/^  public async provideDocumentOnTypeEdits(character: string, document: TextDocument, position: Position): Promise<TextEdit[] | null> {$/;"	m
hasOnTypeProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public hasOnTypeProvider(character: string, document: TextDocument): boolean {$/;"	m
hasProvider	nvim/plugged/coc.nvim/src/languages.ts	/^  public hasProvider(id: string, document: TextDocument): boolean {$/;"	m
dispose	nvim/plugged/coc.nvim/src/languages.ts	/^  public dispose(): void {$/;"	m
createDiagnosticCollection	nvim/plugged/coc.nvim/src/languages.ts	/^  public createDiagnosticCollection(owner: string): DiagnosticCollection {$/;"	m
createCompleteSource	nvim/plugged/coc.nvim/src/languages.ts	/^  private createCompleteSource($/;"	m
token	nvim/plugged/coc.nvim/src/languages.ts	/^  private get token(): CancellationToken {$/;"	m
applyTextEdit	nvim/plugged/coc.nvim/src/languages.ts	/^  private async applyTextEdit(item: CompletionItem, option: CompleteOption): Promise<boolean> {$/;"	m
applyAdditionalEdits	nvim/plugged/coc.nvim/src/languages.ts	/^  private async applyAdditionalEdits($/;"	m
convertVimCompleteItem	nvim/plugged/coc.nvim/src/languages.ts	/^  private convertVimCompleteItem(item: CompletionItem, shortcut: string, opt: CompleteOption): VimCompleteItem {$/;"	m
Workspace	nvim/plugged/coc.nvim/src/workspace.ts	/^export class Workspace implements IWorkspace {$/;"	c
nvim	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly nvim: Neovim$/;"	m
version	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly version: string$/;"	m
keymaps	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly keymaps: Map<string, [Function, boolean]> = new Map()$/;"	m
bufnr	nvim/plugged/coc.nvim/src/workspace.ts	/^  public bufnr: number$/;"	m
resolver	nvim/plugged/coc.nvim/src/workspace.ts	/^  private resolver: Resolver = new Resolver()$/;"	m
rootPatterns	nvim/plugged/coc.nvim/src/workspace.ts	/^  private rootPatterns: Map<string, string[]> = new Map()$/;"	m
_workspaceFolders	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _workspaceFolders: WorkspaceFolder[] = []$/;"	m
messageLevel	nvim/plugged/coc.nvim/src/workspace.ts	/^  private messageLevel: MessageLevel$/;"	m
willSaveUntilHandler	nvim/plugged/coc.nvim/src/workspace.ts	/^  private willSaveUntilHandler: WillSaveUntilHandler$/;"	m
statusLine	nvim/plugged/coc.nvim/src/workspace.ts	/^  private statusLine: StatusLine$/;"	m
_insertMode	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _insertMode = false$/;"	m
_env	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _env: Env$/;"	m
_root	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _root: string$/;"	m
_cwd	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _cwd = process.cwd()$/;"	m
_blocking	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _blocking = false$/;"	m
_initialized	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _initialized = false$/;"	m
_attached	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _attached = false$/;"	m
buffers	nvim/plugged/coc.nvim/src/workspace.ts	/^  private buffers: Map<number, Document> = new Map()$/;"	m
autocmdMaxId	nvim/plugged/coc.nvim/src/workspace.ts	/^  private autocmdMaxId = 0$/;"	m
autocmds	nvim/plugged/coc.nvim/src/workspace.ts	/^  private autocmds: Map<number, Autocmd> = new Map()$/;"	m
terminals	nvim/plugged/coc.nvim/src/workspace.ts	/^  private terminals: Map<number, Terminal> = new Map()$/;"	m
creatingSources	nvim/plugged/coc.nvim/src/workspace.ts	/^  private creatingSources: Map<number, CancellationTokenSource> = new Map()$/;"	m
outputChannels	nvim/plugged/coc.nvim/src/workspace.ts	/^  private outputChannels: Map<string, OutputChannel> = new Map()$/;"	m
schemeProviderMap	nvim/plugged/coc.nvim/src/workspace.ts	/^  private schemeProviderMap: Map<string, TextDocumentContentProvider> = new Map()$/;"	m
namespaceMap	nvim/plugged/coc.nvim/src/workspace.ts	/^  private namespaceMap: Map<string, number> = new Map()$/;"	m
disposables	nvim/plugged/coc.nvim/src/workspace.ts	/^  private disposables: Disposable[] = []$/;"	m
setupDynamicAutocmd	nvim/plugged/coc.nvim/src/workspace.ts	/^  private setupDynamicAutocmd: Function & { clear(): void; }$/;"	m
watchedOptions	nvim/plugged/coc.nvim/src/workspace.ts	/^  private watchedOptions: Set<string> = new Set()$/;"	m
_disposed	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _disposed = false$/;"	m
_onDidOpenDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidOpenDocument = new Emitter<TextDocument>()$/;"	m
_onDidCloseDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidCloseDocument = new Emitter<TextDocument>()$/;"	m
_onDidChangeDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidChangeDocument = new Emitter<DidChangeTextDocumentParams>()$/;"	m
_onWillSaveDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onWillSaveDocument = new Emitter<TextDocumentWillSaveEvent>()$/;"	m
_onDidSaveDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidSaveDocument = new Emitter<TextDocument>()$/;"	m
_onDidChangeWorkspaceFolders	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidChangeWorkspaceFolders = new Emitter<WorkspaceFoldersChangeEvent>()$/;"	m
_onDidChangeConfiguration	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidChangeConfiguration = new Emitter<ConfigurationChangeEvent>()$/;"	m
_onDidWorkspaceInitialized	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidWorkspaceInitialized = new Emitter<void>()$/;"	m
_onDidOpenTerminal	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidOpenTerminal = new Emitter<Terminal>()$/;"	m
_onDidCloseTerminal	nvim/plugged/coc.nvim/src/workspace.ts	/^  private _onDidCloseTerminal = new Emitter<Terminal>()$/;"	m
onDidCloseTerminal	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidCloseTerminal: Event<Terminal> = this._onDidCloseTerminal.event$/;"	m
onDidOpenTerminal	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidOpenTerminal: Event<Terminal> = this._onDidOpenTerminal.event$/;"	m
onDidChangeWorkspaceFolders	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent> = this._onDidChangeWorkspaceFolders.event$/;"	m
onDidOpenTextDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidOpenTextDocument: Event<TextDocument> = this._onDidOpenDocument.event$/;"	m
onDidCloseTextDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidCloseTextDocument: Event<TextDocument> = this._onDidCloseDocument.event$/;"	m
onDidChangeTextDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidChangeTextDocument: Event<DidChangeTextDocumentParams> = this._onDidChangeDocument.event$/;"	m
onWillSaveTextDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onWillSaveTextDocument: Event<TextDocumentWillSaveEvent> = this._onWillSaveDocument.event$/;"	m
onDidSaveTextDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidSaveTextDocument: Event<TextDocument> = this._onDidSaveDocument.event$/;"	m
onDidChangeConfiguration	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidChangeConfiguration: Event<ConfigurationChangeEvent> = this._onDidChangeConfiguration.event$/;"	m
onDidWorkspaceInitialized	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly onDidWorkspaceInitialized: Event<void> = this._onDidWorkspaceInitialized.event$/;"	m
configurations	nvim/plugged/coc.nvim/src/workspace.ts	/^  public readonly configurations: Configurations$/;"	m
init	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async init(): Promise<void> {$/;"	m
getConfigFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getConfigFile(target: ConfigurationTarget): string {$/;"	m
registerAutocmd	nvim/plugged/coc.nvim/src/workspace.ts	/^  public registerAutocmd(autocmd: Autocmd): Disposable {$/;"	m
watchOption	nvim/plugged/coc.nvim/src/workspace.ts	/^  public watchOption(key: string, callback: (oldValue: any, newValue: any) => Thenable<void> | void, disposables?: Disposable[]): void {$/;"	m
watchGlobal	nvim/plugged/coc.nvim/src/workspace.ts	/^  public watchGlobal(key: string, callback?: (oldValue: any, newValue: any) => Thenable<void> | void, disposables?: Disposable[]): void {$/;"	m
cwd	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get cwd(): string {$/;"	m
env	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get env(): Env {$/;"	m
root	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get root(): string {$/;"	m
rootPath	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get rootPath(): string {$/;"	m
workspaceFolders	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get workspaceFolders(): WorkspaceFolder[] {$/;"	m
uri	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get uri(): string {$/;"	m
workspaceFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get workspaceFolder(): WorkspaceFolder {$/;"	m
textDocuments	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get textDocuments(): TextDocument[] {$/;"	m
documents	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get documents(): Document[] {$/;"	m
createNameSpace	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createNameSpace(name = ''): number {$/;"	m
channelNames	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get channelNames(): string[] {$/;"	m
pluginRoot	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get pluginRoot(): string {$/;"	m
isVim	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get isVim(): boolean {$/;"	m
isNvim	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get isNvim(): boolean {$/;"	m
completeOpt	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get completeOpt(): string {$/;"	m
initialized	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get initialized(): boolean {$/;"	m
ready	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get ready(): Promise<void> {$/;"	m
filetypes	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get filetypes(): Set<string> {$/;"	m
match	nvim/plugged/coc.nvim/src/workspace.ts	/^  public match(selector: DocumentSelector, document: TextDocument): number {$/;"	m
findUp	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async findUp(filename: string | string[]): Promise<string | null> {$/;"	m
resolveRootFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async resolveRootFolder(uri: URI, patterns: string[]): Promise<string> {$/;"	m
createFileSystemWatcher	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createFileSystemWatcher(globPattern: string, ignoreCreate?: boolean, ignoreChange?: boolean, ignoreDelete?: boolean): FileSystemWatcher {$/;"	m
getWatchmanPath	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getWatchmanPath(): string | null {$/;"	m
getConfiguration	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getConfiguration(section?: string, resource?: string): WorkspaceConfiguration {$/;"	m
getDocument	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getDocument(uri: number | string): Document {$/;"	m
getOffset	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getOffset(): Promise<number> {$/;"	m
applyEdit	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async applyEdit(edit: WorkspaceEdit): Promise<boolean> {$/;"	m
getQuickfixItem	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getQuickfixItem(loc: Location | LocationLink, text?: string, type = '', module?: string): Promise<QuickfixItem> {$/;"	m
createMru	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createMru(name: string): Mru {$/;"	m
getSelectedRange	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getSelectedRange(mode: string, document: Document): Promise<Range | null> {$/;"	m
selectRange	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async selectRange(range: Range): Promise<void> {$/;"	m
showLocations	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async showLocations(locations: Location[]): Promise<void> {$/;"	m
getLine	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getLine(uri: string, line: number): Promise<string> {$/;"	m
getWorkspaceFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getWorkspaceFolder(uri: string): WorkspaceFolder | null {$/;"	m
readFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async readFile(uri: string): Promise<string> {$/;"	m
getFilepath	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getFilepath(filepath: string): string {$/;"	m
onWillSaveUntil	nvim/plugged/coc.nvim/src/workspace.ts	/^  public onWillSaveUntil(callback: (event: TextDocumentWillSaveEvent) => void, thisArg: any, clientId: string): Disposable {$/;"	m
echoLines	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async echoLines(lines: string[], truncate = false): Promise<void> {$/;"	m
showMessage	nvim/plugged/coc.nvim/src/workspace.ts	/^  public showMessage(msg: string, identify: MsgTypes = 'more'): void {$/;"	m
document	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get document(): Promise<Document> {$/;"	m
getCursorPosition	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getCursorPosition(): Promise<Position> {$/;"	m
getCurrentState	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getCurrentState(): Promise<EditerState> {$/;"	m
getFormatOptions	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async getFormatOptions(uri?: string): Promise<FormattingOptions> {$/;"	m
jumpTo	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async jumpTo(uri: string, position?: Position | null, openCommand?: string): Promise<void> {$/;"	m
moveTo	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async moveTo(position: Position): Promise<void> {$/;"	m
createFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async createFile(filepath: string, opts: CreateFileOptions = {}): Promise<void> {$/;"	m
loadFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async loadFile(uri: string): Promise<Document> {$/;"	m
loadFiles	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async loadFiles(uris: string[]): Promise<void> {$/;"	m
renameFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async renameFile(oldPath: string, newPath: string, opts: RenameFileOptions = {}): Promise<void> {$/;"	m
deleteFile	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async deleteFile(filepath: string, opts: DeleteFileOptions = {}): Promise<void> {$/;"	m
openResource	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async openResource(uri: string): Promise<void> {$/;"	m
createOutputChannel	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createOutputChannel(name: string): OutputChannel {$/;"	m
showOutputChannel	nvim/plugged/coc.nvim/src/workspace.ts	/^  public showOutputChannel(name: string, preserveFocus?: boolean): void {$/;"	m
resolveModule	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async resolveModule(name: string): Promise<string> {$/;"	m
runCommand	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async runCommand(cmd: string, cwd?: string, timeout?: number): Promise<string> {$/;"	m
runTerminalCommand	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async runTerminalCommand(cmd: string, cwd = this.cwd, keepfocus = false): Promise<TerminalResult> {$/;"	m
createTerminal	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async createTerminal(opts: TerminalOptions): Promise<Terminal> {$/;"	m
showQuickpick	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async showQuickpick(items: string[], placeholder = 'Choose by number'): Promise<number> {$/;"	m
showPrompt	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async showPrompt(title: string): Promise<boolean> {$/;"	m
callAsync	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async callAsync<T>(method: string, args: any[]): Promise<T> {$/;"	m
requestInput	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async requestInput(title: string, defaultValue?: string): Promise<string> {$/;"	m
registerTextDocumentContentProvider	nvim/plugged/coc.nvim/src/workspace.ts	/^  public registerTextDocumentContentProvider(scheme: string, provider: TextDocumentContentProvider): Disposable {$/;"	m
registerKeymap	nvim/plugged/coc.nvim/src/workspace.ts	/^  public registerKeymap(modes: MapMode[], key: string, fn: Function, opts: Partial<KeymapOption> = {}): Disposable {$/;"	m
registerExprKeymap	nvim/plugged/coc.nvim/src/workspace.ts	/^  public registerExprKeymap(mode: 'i' | 'n' | 'v' | 's' | 'x', key: string, fn: Function, buffer = false): Disposable {$/;"	m
registerLocalKeymap	nvim/plugged/coc.nvim/src/workspace.ts	/^  public registerLocalKeymap(mode: 'n' | 'v' | 's' | 'x', key: string, fn: Function, notify = false): Disposable {$/;"	m
createStatusBarItem	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createStatusBarItem(priority = 0, opt: StatusItemOption = {}): StatusBarItem {$/;"	m
dispose	nvim/plugged/coc.nvim/src/workspace.ts	/^  public dispose(): void {$/;"	m
detach	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async detach(): Promise<void> {$/;"	m
createDatabase	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createDatabase(name: string): DB {$/;"	m
createTask	nvim/plugged/coc.nvim/src/workspace.ts	/^  public createTask(id: string): Task {$/;"	m
_setupDynamicAutocmd	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async _setupDynamicAutocmd(): Promise<void> {$/;"	m
onBufReadCmd	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufReadCmd(scheme: string, uri: string): Promise<void> {$/;"	m
attach	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async attach(): Promise<void> {$/;"	m
validteDocumentChanges	nvim/plugged/coc.nvim/src/workspace.ts	/^  private validteDocumentChanges(documentChanges: any[] | null): boolean {$/;"	m
createConfigurations	nvim/plugged/coc.nvim/src/workspace.ts	/^  private createConfigurations(): Configurations {$/;"	m
attachChangedEvents	nvim/plugged/coc.nvim/src/workspace.ts	/^  private attachChangedEvents(): void {$/;"	m
onBufCreate	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufCreate(buf: number | Buffer): Promise<void> {$/;"	m
onBufEnter	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufEnter(bufnr: number): Promise<void> {$/;"	m
onCursorMoved	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onCursorMoved(bufnr: number): Promise<void> {$/;"	m
onBufWritePost	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufWritePost(bufnr: number): Promise<void> {$/;"	m
onBufUnload	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufUnload(bufnr: number, recreate = false): Promise<void> {$/;"	m
onBufWritePre	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async onBufWritePre(bufnr: number): Promise<void> {$/;"	m
onDirChanged	nvim/plugged/coc.nvim/src/workspace.ts	/^  private onDirChanged(cwd: string): void {$/;"	m
onFileTypeChange	nvim/plugged/coc.nvim/src/workspace.ts	/^  private onFileTypeChange(filetype: string, bufnr: number): void {$/;"	m
checkBuffer	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async checkBuffer(bufnr: number): Promise<void> {$/;"	m
getFileEncoding	nvim/plugged/coc.nvim/src/workspace.ts	/^  private async getFileEncoding(): Promise<string> {$/;"	m
resolveRoot	nvim/plugged/coc.nvim/src/workspace.ts	/^  private resolveRoot(document: Document): string {$/;"	m
getRootPatterns	nvim/plugged/coc.nvim/src/workspace.ts	/^  public getRootPatterns(document: Document, patternType: PatternType): string[] {$/;"	m
renameCurrent	nvim/plugged/coc.nvim/src/workspace.ts	/^  public async renameCurrent(): Promise<void> {$/;"	m
setMessageLevel	nvim/plugged/coc.nvim/src/workspace.ts	/^  private setMessageLevel(): void {$/;"	m
mergeDocumentChanges	nvim/plugged/coc.nvim/src/workspace.ts	/^  private mergeDocumentChanges(changes: (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[]): any[] {$/;"	m
folderPaths	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get folderPaths(): string[] {$/;"	m
floatSupported	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get floatSupported(): boolean {$/;"	m
removeWorkspaceFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  public removeWorkspaceFolder(fsPath: string): void {$/;"	m
renameWorkspaceFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  public renameWorkspaceFolder(oldPath: string, newPath: string): void {$/;"	m
addRootPatterns	nvim/plugged/coc.nvim/src/workspace.ts	/^  public addRootPatterns(filetype: string, rootPatterns: string[]): void {$/;"	m
insertMode	nvim/plugged/coc.nvim/src/workspace.ts	/^  public get insertMode(): boolean {$/;"	m
getDocumentOption	nvim/plugged/coc.nvim/src/workspace.ts	/^  private getDocumentOption(name: string, doc?: Document): Promise<any> {$/;"	m
addWorkspaceFolder	nvim/plugged/coc.nvim/src/workspace.ts	/^  private addWorkspaceFolder(rootPath: string): WorkspaceFolder {$/;"	m
getServerRootPatterns	nvim/plugged/coc.nvim/src/workspace.ts	/^  private getServerRootPatterns(filetype: string): string[] {$/;"	m
SnippetManager	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^export class SnippetManager implements types.SnippetManager {$/;"	c
sessionMap	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  private sessionMap: Map<number, SnippetSession> = new Map()$/;"	m
disposables	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  private disposables: Disposable[] = []$/;"	m
statusItem	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  private statusItem: types.StatusBarItem$/;"	m
insertSnippet	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public async insertSnippet(snippet: string, select = true, range?: Range): Promise<boolean> {$/;"	m
isPlainText	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public isPlainText(text: string): boolean {$/;"	m
selectCurrentPlaceholder	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public async selectCurrentPlaceholder(triggerAutocmd = true): Promise<void> {$/;"	m
nextPlaceholder	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public async nextPlaceholder(): Promise<void> {$/;"	m
previousPlaceholder	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public async previousPlaceholder(): Promise<void> {$/;"	m
cancel	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public cancel(): void {$/;"	m
session	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public get session(): SnippetSession {$/;"	m
isActived	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public isActived(bufnr: number): boolean {$/;"	m
jumpable	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public jumpable(): boolean {$/;"	m
getSession	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public getSession(bufnr: number): SnippetSession {$/;"	m
resolveSnippet	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public async resolveSnippet(body: string): Promise<Snippets.TextmateSnippet> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/snippets/manager.ts	/^  public dispose(): void {$/;"	m
CocSnippetPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^export interface CocSnippetPlaceholder {$/;"	i
CocSnippet	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^export class CocSnippet {$/;"	c
_parser	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  private _parser: Snippets.SnippetParser = new Snippets.SnippetParser()$/;"	m
_placeholders	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  private _placeholders: CocSnippetPlaceholder[]$/;"	m
tmSnippet	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  private tmSnippet: Snippets.TextmateSnippet$/;"	m
position	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^    private position: Position,$/;"	m
_variableResolver	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^    private _variableResolver?: VariableResolver) {$/;"	m
adjustPosition	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public adjustPosition(characterCount: number, lineCount: number): void {$/;"	m
adjustTextEdit	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public adjustTextEdit(edit: TextEdit): boolean {$/;"	m
isPlainText	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public get isPlainText(): boolean {$/;"	m
toString	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public toString(): string {$/;"	m
range	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public get range(): Range {$/;"	m
firstPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public get firstPlaceholder(): CocSnippetPlaceholder | null {$/;"	m
lastPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public get lastPlaceholder(): CocSnippetPlaceholder {$/;"	m
getPlaceholderById	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public getPlaceholderById(id: number): CocSnippetPlaceholder {$/;"	m
getPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public getPlaceholder(index: number): CocSnippetPlaceholder {$/;"	m
getPrevPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public getPrevPlaceholder(index: number): CocSnippetPlaceholder {$/;"	m
getNextPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public getNextPlaceholder(index: number): CocSnippetPlaceholder {$/;"	m
finalPlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public get finalPlaceholder(): CocSnippetPlaceholder {$/;"	m
getPlaceholderByRange	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public getPlaceholderByRange(range: Range): CocSnippetPlaceholder {$/;"	m
insertSnippet	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public insertSnippet(placeholder: CocSnippetPlaceholder, snippet: string, range: Range): number {$/;"	m
updatePlaceholder	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  public updatePlaceholder(placeholder: CocSnippetPlaceholder, edit: TextEdit): { edits: TextEdit[], delta: number } {$/;"	m
update	nvim/plugged/coc.nvim/src/snippets/snippet.ts	/^  private update(): void {$/;"	m
SnippetVariableResolver	nvim/plugged/coc.nvim/src/snippets/variableResolve.ts	/^export class SnippetVariableResolver implements VariableResolver {$/;"	c
_variableToValue	nvim/plugged/coc.nvim/src/snippets/variableResolve.ts	/^  private _variableToValue: { [key: string]: string } = {}$/;"	m
nvim	nvim/plugged/coc.nvim/src/snippets/variableResolve.ts	/^  private get nvim(): Neovim {$/;"	m
init	nvim/plugged/coc.nvim/src/snippets/variableResolve.ts	/^  public async init(document: Document): Promise<void> {$/;"	m
resolve	nvim/plugged/coc.nvim/src/snippets/variableResolve.ts	/^  public resolve(variable: Variable): string {$/;"	m
enum	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export const enum TokenType {$/;"	v
Token	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export interface Token {$/;"	i
Scanner	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Scanner {$/;"	c
_table	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private static _table: { [ch: number]: TokenType } = {$/;"	m
isDigitCharacter	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public static isDigitCharacter(ch: number): boolean {$/;"	m
isVariableCharacter	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public static isVariableCharacter(ch: number): boolean {$/;"	m
value	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public value: string$/;"	m
pos	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public pos: number$/;"	m
text	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public text(value: string): void {$/;"	m
tokenText	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public tokenText(token: Token): string {$/;"	m
next	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public next(): Token {$/;"	m
Marker	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export abstract class Marker {$/;"	c
_markerBrand	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public readonly _markerBrand: any$/;"	m
parent	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public parent: Marker$/;"	m
_children	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  protected _children: Marker[] = []$/;"	m
appendChild	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public appendChild(child: Marker): this {$/;"	m
setOnlyChild	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public setOnlyChild(child: Marker): void {$/;"	m
replace	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public replace(child: Marker, others: Marker[]): void {$/;"	m
children	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get children(): Marker[] {$/;"	m
snippet	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get snippet(): TextmateSnippet | undefined {$/;"	m
toString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toString(): string {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public abstract toTextmateString(): string$/;"	m
len	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public len(): number {$/;"	m
next	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get next(): Marker | null {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public abstract clone(): Marker$/;"	m
Text	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Text extends Marker {$/;"	c
escape	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public static escape(value: string): string {$/;"	m
toString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toString(): string {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
len	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public len(): number {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): Text {$/;"	m
TransformableMarker	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export abstract class TransformableMarker extends Marker {$/;"	c
transform	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public transform: Transform$/;"	m
Placeholder	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Placeholder extends TransformableMarker {$/;"	c
compareByIndex	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public static compareByIndex(a: Placeholder, b: Placeholder): number {$/;"	m
isFinalTabstop	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get isFinalTabstop(): boolean {$/;"	m
choice	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get choice(): Choice | undefined {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): Placeholder {$/;"	m
Choice	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Choice extends Marker {$/;"	c
options	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public readonly options: Text[] = []$/;"	m
appendChild	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public appendChild(marker: Marker): this {$/;"	m
toString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toString(): string {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
len	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public len(): number {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): Choice {$/;"	m
Transform	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Transform extends Marker {$/;"	c
regexp	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public regexp: RegExp$/;"	m
resolve	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public resolve(value: string): string {$/;"	m
_replace	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _replace(groups: string[]): string {$/;"	m
toString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toString(): string {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): Transform {$/;"	m
FormatString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class FormatString extends Marker {$/;"	c
resolve	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public resolve(value: string): string {$/;"	m
_toPascalCase	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _toPascalCase(value: string): string {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): FormatString {$/;"	m
Variable	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class Variable extends TransformableMarker {$/;"	c
resolve	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public resolve(resolver: VariableResolver): boolean {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): Variable {$/;"	m
VariableResolver	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export interface VariableResolver {$/;"	i
walk	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^function walk(marker: Marker[], visitor: (marker: Marker) => boolean): void {$/;"	f
walk	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^function walk(marker: Marker[], visitor: (marker: Marker) => boolean): void {$/;"	f
walk	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^function walk(marker: Marker[], visitor: (marker: Marker) => boolean): void {$/;"	f
TextmateSnippet	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class TextmateSnippet extends Marker {$/;"	c
_placeholders	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _placeholders?: { all: Placeholder[], last?: Placeholder }$/;"	m
placeholderInfo	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get placeholderInfo(): { all: Placeholder[], last?: Placeholder } {$/;"	m
placeholders	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get placeholders(): Placeholder[] {$/;"	m
maxIndexNumber	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get maxIndexNumber(): number {$/;"	m
minIndexNumber	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public get minIndexNumber(): number {$/;"	m
insertSnippet	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public insertSnippet(snippet: string, id: number, range: Range): number {$/;"	m
updatePlaceholder	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public updatePlaceholder(id: number, val: string): void {$/;"	m
getPlaceholderText	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public getPlaceholderText(id: number, value: string): string {$/;"	m
offset	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public offset(marker: Marker): number {$/;"	m
fullLen	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public fullLen(marker: Marker): number {$/;"	m
enclosingPlaceholders	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public enclosingPlaceholders(placeholder: Placeholder): Placeholder[] {$/;"	m
resolveVariables	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public resolveVariables(resolver: VariableResolver): this {$/;"	m
appendChild	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public appendChild(child: Marker): this {$/;"	m
replace	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public replace(child: Marker, others: Marker[]): void {$/;"	m
toTextmateString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public toTextmateString(): string {$/;"	m
clone	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public clone(): TextmateSnippet {$/;"	m
walk	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public walk(visitor: (marker: Marker) => boolean): void {$/;"	m
SnippetParser	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^export class SnippetParser {$/;"	c
escape	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public static escape(value: string): string {$/;"	m
_scanner	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _scanner = new Scanner()$/;"	m
_token	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _token: Token$/;"	m
text	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public text(value: string): string {$/;"	m
parse	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  public parse(value: string, insertFinalTabstop?: boolean): TextmateSnippet {$/;"	m
_accept	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _accept(type?: TokenType): boolean$/;"	m
_accept	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _accept(type: TokenType | undefined, value: true): string$/;"	m
_accept	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _accept(type: TokenType, value?: boolean): boolean | string {$/;"	m
_backTo	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _backTo(token: Token): false {$/;"	m
_until	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _until(type: TokenType): false | string {$/;"	m
_parse	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parse(marker: Marker): boolean {$/;"	m
_parseEscaped	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseEscaped(marker: Marker): boolean {$/;"	m
_parseTabstopOrVariableName	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseTabstopOrVariableName(parent: Marker): boolean {$/;"	m
_parseComplexPlaceholder	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseComplexPlaceholder(parent: Marker): boolean {$/;"	m
_parseChoiceElement	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseChoiceElement(parent: Choice): boolean {$/;"	m
_parseComplexVariable	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseComplexVariable(parent: Marker): boolean {$/;"	m
_parseTransform	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseTransform(parent: TransformableMarker): boolean {$/;"	m
_parseFormatString	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseFormatString(parent: Transform): boolean {$/;"	m
_parseAnything	nvim/plugged/coc.nvim/src/snippets/parser.ts	/^  private _parseAnything(marker: Marker): boolean {$/;"	m
SnippetSession	nvim/plugged/coc.nvim/src/snippets/session.ts	/^export class SnippetSession {$/;"	c
_isActive	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private _isActive = false$/;"	m
_currId	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private _currId = 0$/;"	m
version	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private version = 0$/;"	m
preferComplete	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private preferComplete = false$/;"	m
_snippet	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private _snippet: CocSnippet = null$/;"	m
_onCancelEvent	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private _onCancelEvent = new Emitter<void>()$/;"	m
onCancel	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public readonly onCancel: Event<void> = this._onCancelEvent.event$/;"	m
start	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async start(snippetString: string, select = true, range?: Range): Promise<boolean> {$/;"	m
activate	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private activate(): void {$/;"	m
deactivate	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public deactivate(): void {$/;"	m
isActive	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public get isActive(): boolean {$/;"	m
nextPlaceholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async nextPlaceholder(): Promise<void> {$/;"	m
previousPlaceholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async previousPlaceholder(): Promise<void> {$/;"	m
synchronizeUpdatedPlaceholders	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async synchronizeUpdatedPlaceholders(change: TextDocumentContentChangeEvent): Promise<void> {$/;"	m
selectCurrentPlaceholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async selectCurrentPlaceholder(triggerAutocmd = true): Promise<void> {$/;"	m
selectPlaceholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async selectPlaceholder(placeholder: CocSnippetPlaceholder, triggerAutocmd = true): Promise<void> {$/;"	m
select	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private async select(range: Range, text: string, triggerAutocmd = true): Promise<void> {$/;"	m
getVirtualCol	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private async getVirtualCol(line: number, col: number): Promise<number> {$/;"	m
documentSynchronize	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private async documentSynchronize(): Promise<void> {$/;"	m
checkPosition	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public async checkPosition(): Promise<void> {$/;"	m
findPlaceholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public findPlaceholder(range: Range): CocSnippetPlaceholder | null {$/;"	m
placeholder	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public get placeholder(): CocSnippetPlaceholder {$/;"	m
snippet	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  public get snippet(): CocSnippet {$/;"	m
document	nvim/plugged/coc.nvim/src/snippets/session.ts	/^  private get document(): Document {$/;"	m
normalizeSnippetString	nvim/plugged/coc.nvim/src/snippets/session.ts	/^export function normalizeSnippetString(snippet: string, indent: string, opts: FormattingOptions): string {$/;"	f
normalizeSnippetString	nvim/plugged/coc.nvim/src/snippets/session.ts	/^export function normalizeSnippetString(snippet: string, indent: string, opts: FormattingOptions): string {$/;"	f
normalizeSnippetString	nvim/plugged/coc.nvim/src/snippets/session.ts	/^export function normalizeSnippetString(snippet: string, indent: string, opts: FormattingOptions): string {$/;"	f
Plugin	nvim/plugged/coc.nvim/src/plugin.ts	/^export default class Plugin extends EventEmitter {$/;"	c
_ready	nvim/plugged/coc.nvim/src/plugin.ts	/^  private _ready = false$/;"	m
handler	nvim/plugged/coc.nvim/src/plugin.ts	/^  private handler: Handler$/;"	m
infoChannel	nvim/plugged/coc.nvim/src/plugin.ts	/^  private infoChannel: OutputChannel$/;"	m
cursors	nvim/plugged/coc.nvim/src/plugin.ts	/^  private cursors: Cursors$/;"	m
addMethod	nvim/plugged/coc.nvim/src/plugin.ts	/^  private addMethod(name: string, fn: Function): any {$/;"	m
addCommand	nvim/plugged/coc.nvim/src/plugin.ts	/^  public addCommand(cmd: { id: string, cmd: string, title?: string }): void {$/;"	m
init	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async init(): Promise<void> {$/;"	m
isReady	nvim/plugged/coc.nvim/src/plugin.ts	/^  public get isReady(): boolean {$/;"	m
ready	nvim/plugged/coc.nvim/src/plugin.ts	/^  public get ready(): Promise<void> {$/;"	m
findLocations	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async findLocations(id: string, method: string, params: any, openCommand?: string | false): Promise<void> {$/;"	m
getLocation	nvim/plugged/coc.nvim/src/plugin.ts	/^      function getLocation(item: any): void {$/;"	f
getLocation	nvim/plugged/coc.nvim/src/plugin.ts	/^      function getLocation(item: any): void {$/;"	f
getLocation	nvim/plugged/coc.nvim/src/plugin.ts	/^      function getLocation(item: any): void {$/;"	f
snippetCheck	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async snippetCheck(checkExpand: boolean, checkJump: boolean): Promise<boolean> {$/;"	m
version	nvim/plugged/coc.nvim/src/plugin.ts	/^  public get version(): string {$/;"	m
showInfo	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async showInfo(): Promise<void> {$/;"	m
cocAction	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async cocAction(...args: any[]): Promise<any> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/plugin.ts	/^  public async dispose(): Promise<void> {$/;"	m
Command	nvim/plugged/coc.nvim/src/commands.ts	/^export interface Command {$/;"	i
CommandItem	nvim/plugged/coc.nvim/src/commands.ts	/^class CommandItem implements Disposable, Command {$/;"	c
id	nvim/plugged/coc.nvim/src/commands.ts	/^    public id: string,$/;"	m
impl	nvim/plugged/coc.nvim/src/commands.ts	/^    private impl: (...args: any[]) => void,$/;"	m
thisArg	nvim/plugged/coc.nvim/src/commands.ts	/^    private thisArg: any,$/;"	m
internal	nvim/plugged/coc.nvim/src/commands.ts	/^    public internal = false$/;"	m
execute	nvim/plugged/coc.nvim/src/commands.ts	/^  public execute(...args: any[]): void | Promise<any> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/commands.ts	/^  public dispose(): void {$/;"	m
CommandManager	nvim/plugged/coc.nvim/src/commands.ts	/^export class CommandManager implements Disposable {$/;"	c
commands	nvim/plugged/coc.nvim/src/commands.ts	/^  private readonly commands = new Map<string, CommandItem>()$/;"	m
titles	nvim/plugged/coc.nvim/src/commands.ts	/^  public titles = new Map<string, string>()$/;"	m
mru	nvim/plugged/coc.nvim/src/commands.ts	/^  private mru: Mru$/;"	m
init	nvim/plugged/coc.nvim/src/commands.ts	/^  public init(nvim: Neovim, plugin: Plugin): void {$/;"	m
commandList	nvim/plugged/coc.nvim/src/commands.ts	/^  public get commandList(): CommandItem[] {$/;"	m
dispose	nvim/plugged/coc.nvim/src/commands.ts	/^  public dispose(): void {$/;"	m
execute	nvim/plugged/coc.nvim/src/commands.ts	/^  public execute(command: language.Command): void {$/;"	m
register	nvim/plugged/coc.nvim/src/commands.ts	/^  public register<T extends Command>(command: T, internal = false, description?: string): T {$/;"	m
has	nvim/plugged/coc.nvim/src/commands.ts	/^  public has(id: string): boolean {$/;"	m
unregister	nvim/plugged/coc.nvim/src/commands.ts	/^  public unregister(id: string): void {$/;"	m
registerCommand	nvim/plugged/coc.nvim/src/commands.ts	/^  public registerCommand(id: string, impl: (...args: any[]) => void, thisArg?: any, internal = false): Disposable {$/;"	m
executeCommand	nvim/plugged/coc.nvim/src/commands.ts	/^  public executeCommand(command: string, ...rest: any[]): Promise<any> {$/;"	m
addRecent	nvim/plugged/coc.nvim/src/commands.ts	/^  public async addRecent(cmd: string): Promise<void> {$/;"	m
repeatCommand	nvim/plugged/coc.nvim/src/commands.ts	/^  public async repeatCommand(): Promise<void> {$/;"	m
WatchResponse	nvim/plugged/coc.nvim/src/watchman.ts	/^export interface WatchResponse {$/;"	i
FileChangeItem	nvim/plugged/coc.nvim/src/watchman.ts	/^export interface FileChangeItem {$/;"	i
FileChange	nvim/plugged/coc.nvim/src/watchman.ts	/^export interface FileChange {$/;"	i
ChangeCallback	nvim/plugged/coc.nvim/src/watchman.ts	/^export type ChangeCallback = (FileChange) => void$/;"	t
Watchman	nvim/plugged/coc.nvim/src/watchman.ts	/^export default class Watchman {$/;"	c
client	nvim/plugged/coc.nvim/src/watchman.ts	/^  private client: Client$/;"	m
watch	nvim/plugged/coc.nvim/src/watchman.ts	/^  private watch: string | undefined$/;"	m
relative_path	nvim/plugged/coc.nvim/src/watchman.ts	/^  private relative_path: string | undefined$/;"	m
_disposed	nvim/plugged/coc.nvim/src/watchman.ts	/^  private _disposed = false$/;"	m
checkCapability	nvim/plugged/coc.nvim/src/watchman.ts	/^  public checkCapability(): Promise<boolean> {$/;"	m
watchProject	nvim/plugged/coc.nvim/src/watchman.ts	/^  public async watchProject(root: string): Promise<boolean> {$/;"	m
command	nvim/plugged/coc.nvim/src/watchman.ts	/^  private command(args: any[]): Promise<any> {$/;"	m
subscribe	nvim/plugged/coc.nvim/src/watchman.ts	/^  public async subscribe(globPattern: string, cb: ChangeCallback): Promise<Disposable> {$/;"	m
unsubscribe	nvim/plugged/coc.nvim/src/watchman.ts	/^  public unsubscribe(subscription: string): Promise<any> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/watchman.ts	/^  public dispose(): void {$/;"	m
appendOutput	nvim/plugged/coc.nvim/src/watchman.ts	/^  private appendOutput(message: string, type = "Info"): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/watchman.ts	/^  public static dispose(): void {$/;"	m
createClient	nvim/plugged/coc.nvim/src/watchman.ts	/^  public static createClient(binaryPath: string, root: string, channel?: OutputChannel): Promise<Watchman | null> {$/;"	m
intersect	nvim/plugged/coc.nvim/src/util/array.ts	/^export function intersect<T>(array: T[], other: T[]): boolean {$/;"	f
intersect	nvim/plugged/coc.nvim/src/util/array.ts	/^export function intersect<T>(array: T[], other: T[]): boolean {$/;"	f
intersect	nvim/plugged/coc.nvim/src/util/array.ts	/^export function intersect<T>(array: T[], other: T[]): boolean {$/;"	f
tail	nvim/plugged/coc.nvim/src/util/array.ts	/^export function tail<T>(array: T[], n = 0): T {$/;"	f
tail	nvim/plugged/coc.nvim/src/util/array.ts	/^export function tail<T>(array: T[], n = 0): T {$/;"	f
tail	nvim/plugged/coc.nvim/src/util/array.ts	/^export function tail<T>(array: T[], n = 0): T {$/;"	f
group	nvim/plugged/coc.nvim/src/util/array.ts	/^export function group<T>(array: T[], size: number): T[][] {$/;"	f
group	nvim/plugged/coc.nvim/src/util/array.ts	/^export function group<T>(array: T[], size: number): T[][] {$/;"	f
group	nvim/plugged/coc.nvim/src/util/array.ts	/^export function group<T>(array: T[], size: number): T[][] {$/;"	f
distinct	nvim/plugged/coc.nvim/src/util/array.ts	/^export function distinct<T>(array: T[], keyFn?: (t: T) => string): T[] {$/;"	f
distinct	nvim/plugged/coc.nvim/src/util/array.ts	/^export function distinct<T>(array: T[], keyFn?: (t: T) => string): T[] {$/;"	f
distinct	nvim/plugged/coc.nvim/src/util/array.ts	/^export function distinct<T>(array: T[], keyFn?: (t: T) => string): T[] {$/;"	f
lastIndex	nvim/plugged/coc.nvim/src/util/array.ts	/^export function lastIndex<T>(array: T[], fn: (t: T) => boolean): number {$/;"	f
lastIndex	nvim/plugged/coc.nvim/src/util/array.ts	/^export function lastIndex<T>(array: T[], fn: (t: T) => boolean): number {$/;"	f
lastIndex	nvim/plugged/coc.nvim/src/util/array.ts	/^export function lastIndex<T>(array: T[], fn: (t: T) => boolean): number {$/;"	f
flatMap	nvim/plugged/coc.nvim/src/util/array.ts	/^export const flatMap = <T, U>(xs: T[], f: (item: T) => U[]): U[] =>$/;"	v
MatchResult	nvim/plugged/coc.nvim/src/util/score.ts	/^export interface MatchResult {$/;"	i
getMatchResult	nvim/plugged/coc.nvim/src/util/score.ts	/^export function getMatchResult(text: string, query: string, filename = ''): MatchResult {$/;"	f
getMatchResult	nvim/plugged/coc.nvim/src/util/score.ts	/^export function getMatchResult(text: string, query: string, filename = ''): MatchResult {$/;"	f
getMatchResult	nvim/plugged/coc.nvim/src/util/score.ts	/^export function getMatchResult(text: string, query: string, filename = ''): MatchResult {$/;"	f
nextResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function nextResult(codes: number[], text: string, idx: number, curr: MatchResult): MatchResult | null {$/;"	f
nextResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function nextResult(codes: number[], text: string, idx: number, curr: MatchResult): MatchResult | null {$/;"	f
nextResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function nextResult(codes: number[], text: string, idx: number, curr: MatchResult): MatchResult | null {$/;"	f
getRemianResult	nvim/plugged/coc.nvim/src/util/score.ts	/^  function getRemianResult(index: number): void {$/;"	f
getRemianResult	nvim/plugged/coc.nvim/src/util/score.ts	/^  function getRemianResult(index: number): void {$/;"	f
getRemianResult	nvim/plugged/coc.nvim/src/util/score.ts	/^  function getRemianResult(index: number): void {$/;"	f
bestResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function bestResult(results: MatchResult[]): MatchResult {$/;"	f
bestResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function bestResult(results: MatchResult[]): MatchResult {$/;"	f
bestResult	nvim/plugged/coc.nvim/src/util/score.ts	/^function bestResult(results: MatchResult[]): MatchResult {$/;"	f
getPosition	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getPosition(opt: CompleteOption): Position {$/;"	f
getPosition	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getPosition(opt: CompleteOption): Position {$/;"	f
getPosition	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getPosition(opt: CompleteOption): Position {$/;"	f
getWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getWord(item: CompletionItem, opt: CompleteOption, invalidInsertCharacters: string[]): string {$/;"	f
getWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getWord(item: CompletionItem, opt: CompleteOption, invalidInsertCharacters: string[]): string {$/;"	f
getWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getWord(item: CompletionItem, opt: CompleteOption, invalidInsertCharacters: string[]): string {$/;"	f
getDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getDocumentation(item: CompletionItem): string {$/;"	f
getDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getDocumentation(item: CompletionItem): string {$/;"	f
getDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getDocumentation(item: CompletionItem): string {$/;"	f
completionKindString	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function completionKindString(kind: CompletionItemKind, map: Map<CompletionItemKind, string>, defaultValue = ''): string {$/;"	f
completionKindString	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function completionKindString(kind: CompletionItemKind, map: Map<CompletionItemKind, string>, defaultValue = ''): string {$/;"	f
completionKindString	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function completionKindString(kind: CompletionItemKind, map: Map<CompletionItemKind, string>, defaultValue = ''): string {$/;"	f
getSnippetDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getSnippetDocumentation(languageId: string, body: string): string {$/;"	f
getSnippetDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getSnippetDocumentation(languageId: string, body: string): string {$/;"	f
getSnippetDocumentation	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getSnippetDocumentation(languageId: string, body: string): string {$/;"	f
getValidWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getValidWord(text: string, invalidChars: string[]): string {$/;"	f
getValidWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getValidWord(text: string, invalidChars: string[]): string {$/;"	f
getValidWord	nvim/plugged/coc.nvim/src/util/complete.ts	/^export function getValidWord(text: string, invalidChars: string[]): string {$/;"	f
Change	nvim/plugged/coc.nvim/src/util/diff.ts	/^interface Change {$/;"	i
diffLines	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function diffLines(from: string, to: string): ChangedLines {$/;"	f
diffLines	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function diffLines(from: string, to: string): ChangedLines {$/;"	f
diffLines	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function diffLines(from: string, to: string): ChangedLines {$/;"	f
getChange	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function getChange(oldStr: string, newStr: string, cursorEnd?: number): Change {$/;"	f
getChange	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function getChange(oldStr: string, newStr: string, cursorEnd?: number): Change {$/;"	f
getChange	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function getChange(oldStr: string, newStr: string, cursorEnd?: number): Change {$/;"	f
patchLine	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function patchLine(from: string, to: string, fill = ' '): string {$/;"	f
patchLine	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function patchLine(from: string, to: string, fill = ' '): string {$/;"	f
patchLine	nvim/plugged/coc.nvim/src/util/diff.ts	/^export function patchLine(from: string, to: string, fill = ' '): string {$/;"	f
memorize	nvim/plugged/coc.nvim/src/util/decorator.ts	/^export function memorize<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
memorize	nvim/plugged/coc.nvim/src/util/decorator.ts	/^export function memorize<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
memorize	nvim/plugged/coc.nvim/src/util/decorator.ts	/^export function memorize<R extends (...args: any[]) => Promise<R>>(_target: any, key: string, descriptor: any): void {$/;"	f
getSymbolKind	nvim/plugged/coc.nvim/src/util/convert.ts	/^export function getSymbolKind(kind: SymbolKind): string {$/;"	f
getSymbolKind	nvim/plugged/coc.nvim/src/util/convert.ts	/^export function getSymbolKind(kind: SymbolKind): string {$/;"	f
getSymbolKind	nvim/plugged/coc.nvim/src/util/convert.ts	/^export function getSymbolKind(kind: SymbolKind): string {$/;"	f
Highlight	nvim/plugged/coc.nvim/src/util/highlight.ts	/^export interface Highlight {$/;"	i
Env	nvim/plugged/coc.nvim/src/util/highlight.ts	/^interface Env {$/;"	i
getHiglights	nvim/plugged/coc.nvim/src/util/highlight.ts	/^export function getHiglights(lines: string[], filetype: string): Promise<Highlight[]> {$/;"	f
getHiglights	nvim/plugged/coc.nvim/src/util/highlight.ts	/^export function getHiglights(lines: string[], filetype: string): Promise<Highlight[]> {$/;"	f
getHiglights	nvim/plugged/coc.nvim/src/util/highlight.ts	/^export function getHiglights(lines: string[], filetype: string): Promise<Highlight[]> {$/;"	f
parseAnsiHighlights	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function parseAnsiHighlights(line: string): { line: string, highlights: AnsiHighlight[] } {$/;"	f
parseAnsiHighlights	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function parseAnsiHighlights(line: string): { line: string, highlights: AnsiHighlight[] } {$/;"	f
parseAnsiHighlights	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function parseAnsiHighlights(line: string): { line: string, highlights: AnsiHighlight[] } {$/;"	f
ansiparse	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function ansiparse(str: string): AnsiItem[] {$/;"	f
ansiparse	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function ansiparse(str: string): AnsiItem[] {$/;"	f
ansiparse	nvim/plugged/coc.nvim/src/util/ansiparse.ts	/^export function ansiparse(str: string): AnsiItem[] {$/;"	f
OnReadLine	nvim/plugged/coc.nvim/src/util/fs.ts	/^export type OnReadLine = (line: string) => void$/;"	t
statAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export async function statAsync(filepath: string): Promise<fs.Stats | null> {$/;"	f
isDirectory	nvim/plugged/coc.nvim/src/util/fs.ts	/^export async function isDirectory(filepath: string): Promise<boolean> {$/;"	f
unlinkAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export async function unlinkAsync(filepath: string): Promise<void> {$/;"	f
renameAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function renameAsync(oldPath: string, newPath: string): Promise<void> {$/;"	f
renameAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function renameAsync(oldPath: string, newPath: string): Promise<void> {$/;"	f
renameAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function renameAsync(oldPath: string, newPath: string): Promise<void> {$/;"	f
isGitIgnored	nvim/plugged/coc.nvim/src/util/fs.ts	/^export async function isGitIgnored(fullpath: string): Promise<boolean> {$/;"	f
resolveRoot	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function resolveRoot(dir: string, subs: string[], cwd?: string): string | null {$/;"	f
resolveRoot	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function resolveRoot(dir: string, subs: string[], cwd?: string): string | null {$/;"	f
resolveRoot	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function resolveRoot(dir: string, subs: string[], cwd?: string): string | null {$/;"	f
inDirectory	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function inDirectory(dir: string, subs: string[]): boolean {$/;"	f
inDirectory	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function inDirectory(dir: string, subs: string[]): boolean {$/;"	f
inDirectory	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function inDirectory(dir: string, subs: string[]): boolean {$/;"	f
findUp	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function findUp(name: string | string[], cwd: string): string {$/;"	f
findUp	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function findUp(name: string | string[], cwd: string): string {$/;"	f
findUp	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function findUp(name: string | string[], cwd: string): string {$/;"	f
readFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFile(fullpath: string, encoding: string): Promise<string> {$/;"	f
readFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFile(fullpath: string, encoding: string): Promise<string> {$/;"	f
readFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFile(fullpath: string, encoding: string): Promise<string> {$/;"	f
getFileLineCount	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function getFileLineCount(filepath: string): Promise<number> {$/;"	f
getFileLineCount	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function getFileLineCount(filepath: string): Promise<number> {$/;"	f
getFileLineCount	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function getFileLineCount(filepath: string): Promise<number> {$/;"	f
readFileLines	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLines(fullpath: string, start: number, end: number): Promise<string[]> {$/;"	f
readFileLines	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLines(fullpath: string, start: number, end: number): Promise<string[]> {$/;"	f
readFileLines	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLines(fullpath: string, start: number, end: number): Promise<string[]> {$/;"	f
readFileLine	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLine(fullpath: string, count: number): Promise<string> {$/;"	f
readFileLine	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLine(fullpath: string, count: number): Promise<string> {$/;"	f
readFileLine	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function readFileLine(fullpath: string, count: number): Promise<string> {$/;"	f
writeFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export async function writeFile(fullpath: string, content: string): Promise<void> {$/;"	f
validSocket	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function validSocket(path: string): Promise<boolean> {$/;"	f
validSocket	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function validSocket(path: string): Promise<boolean> {$/;"	f
validSocket	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function validSocket(path: string): Promise<boolean> {$/;"	f
isFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isFile(uri: string): boolean {$/;"	f
isFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isFile(uri: string): boolean {$/;"	f
isFile	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isFile(uri: string): boolean {$/;"	f
readdirAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export const readdirAsync = util.promisify(fs.readdir)$/;"	v
realpathAsync	nvim/plugged/coc.nvim/src/util/fs.ts	/^export const realpathAsync = util.promisify(fs.realpath)$/;"	v
parentDirs	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function parentDirs(pth: string): string[] {$/;"	f
parentDirs	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function parentDirs(pth: string): string[] {$/;"	f
parentDirs	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function parentDirs(pth: string): string[] {$/;"	f
isParentFolder	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isParentFolder(folder: string, filepath: string, checkEqual = false): boolean {$/;"	f
isParentFolder	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isParentFolder(folder: string, filepath: string, checkEqual = false): boolean {$/;"	f
isParentFolder	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function isParentFolder(folder: string, filepath: string, checkEqual = false): boolean {$/;"	f
fixDriver	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function fixDriver(filepath: string): string {$/;"	f
fixDriver	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function fixDriver(filepath: string): string {$/;"	f
fixDriver	nvim/plugged/coc.nvim/src/util/fs.ts	/^export function fixDriver(filepath: string): string {$/;"	f
getCharCodes	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function getCharCodes(str: string): number[] {$/;"	f
getCharCodes	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function getCharCodes(str: string): number[] {$/;"	f
getCharCodes	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function getCharCodes(str: string): number[] {$/;"	f
wordChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function wordChar(ch: number): boolean {$/;"	f
wordChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function wordChar(ch: number): boolean {$/;"	f
wordChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function wordChar(ch: number): boolean {$/;"	f
caseMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function caseMatch(input: number, code: number): boolean {$/;"	f
caseMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function caseMatch(input: number, code: number): boolean {$/;"	f
caseMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function caseMatch(input: number, code: number): boolean {$/;"	f
fuzzyChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyChar(a: string, b: string): boolean {$/;"	f
fuzzyChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyChar(a: string, b: string): boolean {$/;"	f
fuzzyChar	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyChar(a: string, b: string): boolean {$/;"	f
fuzzyMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyMatch(needle: number[], text: string): boolean {$/;"	f
fuzzyMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyMatch(needle: number[], text: string): boolean {$/;"	f
fuzzyMatch	nvim/plugged/coc.nvim/src/util/fuzzy.ts	/^export function fuzzyMatch(needle: number[], text: string): boolean {$/;"	f
getLogFile	nvim/plugged/coc.nvim/src/util/logger.ts	/^function getLogFile(): string {$/;"	f
getLogFile	nvim/plugged/coc.nvim/src/util/logger.ts	/^function getLogFile(): string {$/;"	f
getLogFile	nvim/plugged/coc.nvim/src/util/logger.ts	/^function getLogFile(): string {$/;"	f
terminate	nvim/plugged/coc.nvim/src/util/processes.ts	/^export function terminate(process: ChildProcess, cwd?: string): boolean {$/;"	f
terminate	nvim/plugged/coc.nvim/src/util/processes.ts	/^export function terminate(process: ChildProcess, cwd?: string): boolean {$/;"	f
terminate	nvim/plugged/coc.nvim/src/util/processes.ts	/^export function terminate(process: ChildProcess, cwd?: string): boolean {$/;"	f
boolean	nvim/plugged/coc.nvim/src/util/is.ts	/^export function boolean(value: any): value is boolean {$/;"	f
boolean	nvim/plugged/coc.nvim/src/util/is.ts	/^export function boolean(value: any): value is boolean {$/;"	f
boolean	nvim/plugged/coc.nvim/src/util/is.ts	/^export function boolean(value: any): value is boolean {$/;"	f
string	nvim/plugged/coc.nvim/src/util/is.ts	/^export function string(value: any): value is string {$/;"	f
string	nvim/plugged/coc.nvim/src/util/is.ts	/^export function string(value: any): value is string {$/;"	f
string	nvim/plugged/coc.nvim/src/util/is.ts	/^export function string(value: any): value is string {$/;"	f
number	nvim/plugged/coc.nvim/src/util/is.ts	/^export function number(value: any): value is number {$/;"	f
number	nvim/plugged/coc.nvim/src/util/is.ts	/^export function number(value: any): value is number {$/;"	f
number	nvim/plugged/coc.nvim/src/util/is.ts	/^export function number(value: any): value is number {$/;"	f
array	nvim/plugged/coc.nvim/src/util/is.ts	/^export function array(array: any): array is any[] {$/;"	f
array	nvim/plugged/coc.nvim/src/util/is.ts	/^export function array(array: any): array is any[] {$/;"	f
array	nvim/plugged/coc.nvim/src/util/is.ts	/^export function array(array: any): array is any[] {$/;"	f
func	nvim/plugged/coc.nvim/src/util/is.ts	/^export function func(value: any): value is Function {$/;"	f
func	nvim/plugged/coc.nvim/src/util/is.ts	/^export function func(value: any): value is Function {$/;"	f
func	nvim/plugged/coc.nvim/src/util/is.ts	/^export function func(value: any): value is Function {$/;"	f
objectLiteral	nvim/plugged/coc.nvim/src/util/is.ts	/^export function objectLiteral(obj: any): obj is object {$/;"	f
objectLiteral	nvim/plugged/coc.nvim/src/util/is.ts	/^export function objectLiteral(obj: any): obj is object {$/;"	f
objectLiteral	nvim/plugged/coc.nvim/src/util/is.ts	/^export function objectLiteral(obj: any): obj is object {$/;"	f
emptyObject	nvim/plugged/coc.nvim/src/util/is.ts	/^export function emptyObject(obj: any): boolean {$/;"	f
emptyObject	nvim/plugged/coc.nvim/src/util/is.ts	/^export function emptyObject(obj: any): boolean {$/;"	f
emptyObject	nvim/plugged/coc.nvim/src/util/is.ts	/^export function emptyObject(obj: any): boolean {$/;"	f
typedArray	nvim/plugged/coc.nvim/src/util/is.ts	/^export function typedArray<T>($/;"	f
typedArray	nvim/plugged/coc.nvim/src/util/is.ts	/^export function typedArray<T>($/;"	f
typedArray	nvim/plugged/coc.nvim/src/util/is.ts	/^export function typedArray<T>($/;"	f
rangeInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeInRange(r: Range, range: Range): boolean {$/;"	f
rangeInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeInRange(r: Range, range: Range): boolean {$/;"	f
rangeInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeInRange(r: Range, range: Range): boolean {$/;"	f
rangeOverlap	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeOverlap(r: Range, range: Range): boolean {$/;"	f
rangeOverlap	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeOverlap(r: Range, range: Range): boolean {$/;"	f
rangeOverlap	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeOverlap(r: Range, range: Range): boolean {$/;"	f
rangeIntersect	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeIntersect(r: Range, range: Range): boolean {$/;"	f
rangeIntersect	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeIntersect(r: Range, range: Range): boolean {$/;"	f
rangeIntersect	nvim/plugged/coc.nvim/src/util/position.ts	/^export function rangeIntersect(r: Range, range: Range): boolean {$/;"	f
lineInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function lineInRange(line: number, range: Range): boolean {$/;"	f
lineInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function lineInRange(line: number, range: Range): boolean {$/;"	f
lineInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function lineInRange(line: number, range: Range): boolean {$/;"	f
emptyRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function emptyRange(range: Range): boolean {$/;"	f
emptyRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function emptyRange(range: Range): boolean {$/;"	f
emptyRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function emptyRange(range: Range): boolean {$/;"	f
positionInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionInRange(position: Position, range: Range): number {$/;"	f
positionInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionInRange(position: Position, range: Range): number {$/;"	f
positionInRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionInRange(position: Position, range: Range): number {$/;"	f
comparePosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function comparePosition(position: Position, other: Position): number {$/;"	f
comparePosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function comparePosition(position: Position, other: Position): number {$/;"	f
comparePosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function comparePosition(position: Position, other: Position): number {$/;"	f
isSingleLine	nvim/plugged/coc.nvim/src/util/position.ts	/^export function isSingleLine(range: Range): boolean {$/;"	f
isSingleLine	nvim/plugged/coc.nvim/src/util/position.ts	/^export function isSingleLine(range: Range): boolean {$/;"	f
isSingleLine	nvim/plugged/coc.nvim/src/util/position.ts	/^export function isSingleLine(range: Range): boolean {$/;"	f
getChangedPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedPosition(start: Position, edit: TextEdit): { line: number, character: number } {$/;"	f
getChangedPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedPosition(start: Position, edit: TextEdit): { line: number, character: number } {$/;"	f
getChangedPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedPosition(start: Position, edit: TextEdit): { line: number, character: number } {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function adjustPosition(pos: Position, edit: TextEdit): Position {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function adjustPosition(pos: Position, edit: TextEdit): Position {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/util/position.ts	/^export function adjustPosition(pos: Position, edit: TextEdit): Position {$/;"	f
positionToOffset	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionToOffset(lines: string[], line: number, character: number): number {$/;"	f
positionToOffset	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionToOffset(lines: string[], line: number, character: number): number {$/;"	f
positionToOffset	nvim/plugged/coc.nvim/src/util/position.ts	/^export function positionToOffset(lines: string[], line: number, character: number): number {$/;"	f
editRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function editRange(range: Range, text: string, edit: TextEdit): string {$/;"	f
editRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function editRange(range: Range, text: string, edit: TextEdit): string {$/;"	f
editRange	nvim/plugged/coc.nvim/src/util/position.ts	/^export function editRange(range: Range, text: string, edit: TextEdit): string {$/;"	f
getChangedFromEdits	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedFromEdits(start: Position, edits: TextEdit[]): Position | null {$/;"	f
getChangedFromEdits	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedFromEdits(start: Position, edits: TextEdit[]): Position | null {$/;"	f
getChangedFromEdits	nvim/plugged/coc.nvim/src/util/position.ts	/^export function getChangedFromEdits(start: Position, edits: TextEdit[]): Position | null {$/;"	f
islower	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function islower(s): boolean {$/;"	f
islower	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function islower(s): boolean {$/;"	f
islower	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function islower(s): boolean {$/;"	f
isupper	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function isupper(s): boolean {$/;"	f
isupper	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function isupper(s): boolean {$/;"	f
isupper	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function isupper(s): boolean {$/;"	f
precompute_bonus	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function precompute_bonus(haystack): number[] {$/;"	f
precompute_bonus	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function precompute_bonus(haystack): number[] {$/;"	f
precompute_bonus	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function precompute_bonus(haystack): number[] {$/;"	f
compute	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function compute(needle, haystack, D, M): void {$/;"	f
compute	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function compute(needle, haystack, D, M): void {$/;"	f
compute	nvim/plugged/coc.nvim/src/util/fzy.ts	/^function compute(needle, haystack, D, M): void {$/;"	f
score	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function score(needle, haystack): number {$/;"	f
score	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function score(needle, haystack): number {$/;"	f
score	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function score(needle, haystack): number {$/;"	f
positions	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function positions(needle: string, haystack: string): number[] {$/;"	f
positions	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function positions(needle: string, haystack: string): number[] {$/;"	f
positions	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function positions(needle: string, haystack: string): number[] {$/;"	f
hasMatch	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function hasMatch(needle, haystack): boolean {$/;"	f
hasMatch	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function hasMatch(needle, haystack): boolean {$/;"	f
hasMatch	nvim/plugged/coc.nvim/src/util/fzy.ts	/^export function hasMatch(needle, haystack): boolean {$/;"	f
Lazy	nvim/plugged/coc.nvim/src/util/lazy.ts	/^export class Lazy<T> {$/;"	c
val	nvim/plugged/coc.nvim/src/util/lazy.ts	/^  private val: T$/;"	m
computed	nvim/plugged/coc.nvim/src/util/lazy.ts	/^  private computed: boolean$/;"	m
constructor	nvim/plugged/coc.nvim/src/util/lazy.ts	/^  public constructor(private expr: () => T) {$/;"	m
invalidate	nvim/plugged/coc.nvim/src/util/lazy.ts	/^  public invalidate(): void {$/;"	m
value	nvim/plugged/coc.nvim/src/util/lazy.ts	/^  public value(): T {$/;"	m
ExtensionExport	nvim/plugged/coc.nvim/src/util/factory.ts	/^export interface ExtensionExport {$/;"	i
IModule	nvim/plugged/coc.nvim/src/util/factory.ts	/^export interface IModule {$/;"	i
removedGlobalStub	nvim/plugged/coc.nvim/src/util/factory.ts	/^function removedGlobalStub(name: string): Function {$/;"	f
removedGlobalStub	nvim/plugged/coc.nvim/src/util/factory.ts	/^function removedGlobalStub(name: string): Function {$/;"	f
removedGlobalStub	nvim/plugged/coc.nvim/src/util/factory.ts	/^function removedGlobalStub(name: string): Function {$/;"	f
makeRequireFunction	nvim/plugged/coc.nvim/src/util/factory.ts	/^function makeRequireFunction(this: any): any {$/;"	f
makeRequireFunction	nvim/plugged/coc.nvim/src/util/factory.ts	/^function makeRequireFunction(this: any): any {$/;"	f
makeRequireFunction	nvim/plugged/coc.nvim/src/util/factory.ts	/^function makeRequireFunction(this: any): any {$/;"	f
compileInSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function compileInSandbox(sandbox: ISandbox): Function {$/;"	f
compileInSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function compileInSandbox(sandbox: ISandbox): Function {$/;"	f
compileInSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function compileInSandbox(sandbox: ISandbox): Function {$/;"	f
ISandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^export interface ISandbox {$/;"	i
createSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function createSandbox(filename: string, logger: Logger): ISandbox {$/;"	f
createSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function createSandbox(filename: string, logger: Logger): ISandbox {$/;"	f
createSandbox	nvim/plugged/coc.nvim/src/util/factory.ts	/^function createSandbox(filename: string, logger: Logger): ISandbox {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/util/factory.ts	/^export function createExtension(id: string, filename: string): ExtensionExport {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/util/factory.ts	/^export function createExtension(id: string, filename: string): ExtensionExport {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/util/factory.ts	/^export function createExtension(id: string, filename: string): ExtensionExport {$/;"	f
enum	nvim/plugged/coc.nvim/src/util/charCode.ts	/^export const enum CharCode {$/;"	v
byteLength	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteLength(str: string): number {$/;"	f
byteLength	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteLength(str: string): number {$/;"	f
byteLength	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteLength(str: string): number {$/;"	f
upperFirst	nvim/plugged/coc.nvim/src/util/string.ts	/^export function upperFirst(str: string): string {$/;"	f
upperFirst	nvim/plugged/coc.nvim/src/util/string.ts	/^export function upperFirst(str: string): string {$/;"	f
upperFirst	nvim/plugged/coc.nvim/src/util/string.ts	/^export function upperFirst(str: string): string {$/;"	f
byteIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteIndex(content: string, index: number): number {$/;"	f
byteIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteIndex(content: string, index: number): number {$/;"	f
byteIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteIndex(content: string, index: number): number {$/;"	f
indexOf	nvim/plugged/coc.nvim/src/util/string.ts	/^export function indexOf(str: string, ch: string, count = 1): number {$/;"	f
indexOf	nvim/plugged/coc.nvim/src/util/string.ts	/^export function indexOf(str: string, ch: string, count = 1): number {$/;"	f
indexOf	nvim/plugged/coc.nvim/src/util/string.ts	/^export function indexOf(str: string, ch: string, count = 1): number {$/;"	f
characterIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function characterIndex(content: string, byteIndex: number): number {$/;"	f
characterIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function characterIndex(content: string, byteIndex: number): number {$/;"	f
characterIndex	nvim/plugged/coc.nvim/src/util/string.ts	/^export function characterIndex(content: string, byteIndex: number): number {$/;"	f
byteSlice	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteSlice(content: string, start: number, end?: number): string {$/;"	f
byteSlice	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteSlice(content: string, start: number, end?: number): string {$/;"	f
byteSlice	nvim/plugged/coc.nvim/src/util/string.ts	/^export function byteSlice(content: string, start: number, end?: number): string {$/;"	f
isWord	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isWord(character: string): boolean {$/;"	f
isWord	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isWord(character: string): boolean {$/;"	f
isWord	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isWord(character: string): boolean {$/;"	f
isTriggerCharacter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isTriggerCharacter(character: string): boolean {$/;"	f
isTriggerCharacter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isTriggerCharacter(character: string): boolean {$/;"	f
isTriggerCharacter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isTriggerCharacter(character: string): boolean {$/;"	f
resolveVariables	nvim/plugged/coc.nvim/src/util/string.ts	/^export function resolveVariables(str: string, variables: { [key: string]: string }): string {$/;"	f
resolveVariables	nvim/plugged/coc.nvim/src/util/string.ts	/^export function resolveVariables(str: string, variables: { [key: string]: string }): string {$/;"	f
resolveVariables	nvim/plugged/coc.nvim/src/util/string.ts	/^export function resolveVariables(str: string, variables: { [key: string]: string }): string {$/;"	f
isAsciiLetter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isAsciiLetter(code: number): boolean {$/;"	f
isAsciiLetter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isAsciiLetter(code: number): boolean {$/;"	f
isAsciiLetter	nvim/plugged/coc.nvim/src/util/string.ts	/^export function isAsciiLetter(code: number): boolean {$/;"	f
doEqualsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^function doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {$/;"	f
doEqualsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^function doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {$/;"	f
doEqualsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^function doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {$/;"	f
equalsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^export function equalsIgnoreCase(a: string, b: string): boolean {$/;"	f
equalsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^export function equalsIgnoreCase(a: string, b: string): boolean {$/;"	f
equalsIgnoreCase	nvim/plugged/coc.nvim/src/util/string.ts	/^export function equalsIgnoreCase(a: string, b: string): boolean {$/;"	f
defaults	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function defaults(obj: any, ...sources: any[]): any {$/;"	f
defaults	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function defaults(obj: any, ...sources: any[]): any {$/;"	f
defaults	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function defaults(obj: any, ...sources: any[]): any {$/;"	f
omit	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function omit<T>(obj: T, properties: string[]): T {$/;"	f
omit	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function omit<T>(obj: T, properties: string[]): T {$/;"	f
omit	nvim/plugged/coc.nvim/src/util/lodash.ts	/^export function omit<T>(obj: T, properties: string[]): T {$/;"	f
throttle	nvim/plugged/coc.nvim/src/util/throttle.ts	/^export default function throttle(func: Function, wait: number): Function & { clear(): void; } {$/;"	f
throttle	nvim/plugged/coc.nvim/src/util/throttle.ts	/^export default function throttle(func: Function, wait: number): Function & { clear(): void; } {$/;"	f
throttle	nvim/plugged/coc.nvim/src/util/throttle.ts	/^export default function throttle(func: Function, wait: number): Function & { clear(): void; } {$/;"	f
fn	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function fn(): any {$/;"	f
fn	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function fn(): any {$/;"	f
fn	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function fn(): any {$/;"	f
call	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function call(): any {$/;"	f
call	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function call(): any {$/;"	f
call	nvim/plugged/coc.nvim/src/util/throttle.ts	/^  function call(): any {$/;"	f
CallSequence	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^export default class CallSequence {$/;"	c
funcs	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  private funcs: Set<Function> = new Set()$/;"	m
_canceled	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  private _canceled = false$/;"	m
_resolved	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  private _resolved = false$/;"	m
promise	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  private promise: Promise<boolean>$/;"	m
addFunction	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  public addFunction(fn: Function): void {$/;"	m
start	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  public start(): Promise<boolean> {$/;"	m
ready	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  public ready(): Promise<any> {$/;"	m
cancel	nvim/plugged/coc.nvim/src/util/callSequence.ts	/^  public cancel(): Promise<any> {$/;"	m
score	nvim/plugged/coc.nvim/src/util/match.ts	/^export function score(selector: DocumentSelector | DocumentFilter | string, uri: string, languageId: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/util/match.ts	/^export function score(selector: DocumentSelector | DocumentFilter | string, uri: string, languageId: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/util/match.ts	/^export function score(selector: DocumentSelector | DocumentFilter | string, uri: string, languageId: string): number {$/;"	f
escapeSingleQuote	nvim/plugged/coc.nvim/src/util/index.ts	/^export function escapeSingleQuote(str: string): string {$/;"	f
escapeSingleQuote	nvim/plugged/coc.nvim/src/util/index.ts	/^export function escapeSingleQuote(str: string): string {$/;"	f
escapeSingleQuote	nvim/plugged/coc.nvim/src/util/index.ts	/^export function escapeSingleQuote(str: string): string {$/;"	f
echoErr	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoErr(nvim: Neovim, msg: string): void {$/;"	f
echoErr	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoErr(nvim: Neovim, msg: string): void {$/;"	f
echoErr	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoErr(nvim: Neovim, msg: string): void {$/;"	f
echoWarning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoWarning(nvim: Neovim, msg: string): void {$/;"	f
echoWarning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoWarning(nvim: Neovim, msg: string): void {$/;"	f
echoWarning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoWarning(nvim: Neovim, msg: string): void {$/;"	f
echoMessage	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoMessage(nvim: Neovim, msg: string): void {$/;"	f
echoMessage	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoMessage(nvim: Neovim, msg: string): void {$/;"	f
echoMessage	nvim/plugged/coc.nvim/src/util/index.ts	/^export function echoMessage(nvim: Neovim, msg: string): void {$/;"	f
wait	nvim/plugged/coc.nvim/src/util/index.ts	/^export function wait(ms: number): Promise<any> {$/;"	f
wait	nvim/plugged/coc.nvim/src/util/index.ts	/^export function wait(ms: number): Promise<any> {$/;"	f
wait	nvim/plugged/coc.nvim/src/util/index.ts	/^export function wait(ms: number): Promise<any> {$/;"	f
echoMsg	nvim/plugged/coc.nvim/src/util/index.ts	/^function echoMsg(nvim: Neovim, msg: string, hl: string): void {$/;"	f
echoMsg	nvim/plugged/coc.nvim/src/util/index.ts	/^function echoMsg(nvim: Neovim, msg: string, hl: string): void {$/;"	f
echoMsg	nvim/plugged/coc.nvim/src/util/index.ts	/^function echoMsg(nvim: Neovim, msg: string, hl: string): void {$/;"	f
getUri	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getUri(fullpath: string, id: number, buftype: string, isCygwin: boolean): string {$/;"	f
getUri	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getUri(fullpath: string, id: number, buftype: string, isCygwin: boolean): string {$/;"	f
getUri	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getUri(fullpath: string, id: number, buftype: string, isCygwin: boolean): string {$/;"	f
disposeAll	nvim/plugged/coc.nvim/src/util/index.ts	/^export function disposeAll(disposables: Disposable[]): void {$/;"	f
disposeAll	nvim/plugged/coc.nvim/src/util/index.ts	/^export function disposeAll(disposables: Disposable[]): void {$/;"	f
disposeAll	nvim/plugged/coc.nvim/src/util/index.ts	/^export function disposeAll(disposables: Disposable[]): void {$/;"	f
executable	nvim/plugged/coc.nvim/src/util/index.ts	/^export function executable(command: string): boolean {$/;"	f
executable	nvim/plugged/coc.nvim/src/util/index.ts	/^export function executable(command: string): boolean {$/;"	f
executable	nvim/plugged/coc.nvim/src/util/index.ts	/^export function executable(command: string): boolean {$/;"	f
runCommand	nvim/plugged/coc.nvim/src/util/index.ts	/^export function runCommand(cmd: string, opts: ExecOptions = {}, timeout?: number): Promise<string> {$/;"	f
runCommand	nvim/plugged/coc.nvim/src/util/index.ts	/^export function runCommand(cmd: string, opts: ExecOptions = {}, timeout?: number): Promise<string> {$/;"	f
runCommand	nvim/plugged/coc.nvim/src/util/index.ts	/^export function runCommand(cmd: string, opts: ExecOptions = {}, timeout?: number): Promise<string> {$/;"	f
watchFile	nvim/plugged/coc.nvim/src/util/index.ts	/^export function watchFile(filepath: string, onChange: () => void): Disposable {$/;"	f
watchFile	nvim/plugged/coc.nvim/src/util/index.ts	/^export function watchFile(filepath: string, onChange: () => void): Disposable {$/;"	f
watchFile	nvim/plugged/coc.nvim/src/util/index.ts	/^export function watchFile(filepath: string, onChange: () => void): Disposable {$/;"	f
isRunning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isRunning(pid: number): boolean {$/;"	f
isRunning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isRunning(pid: number): boolean {$/;"	f
isRunning	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isRunning(pid: number): boolean {$/;"	f
getKeymapModifier	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getKeymapModifier(mode: MapMode): string {$/;"	f
getKeymapModifier	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getKeymapModifier(mode: MapMode): string {$/;"	f
getKeymapModifier	nvim/plugged/coc.nvim/src/util/index.ts	/^export function getKeymapModifier(mode: MapMode): string {$/;"	f
mkdirp	nvim/plugged/coc.nvim/src/util/index.ts	/^export async function mkdirp(path: string, mode?: number): Promise<boolean> {$/;"	f
isDocumentEdit	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isDocumentEdit(edit: any): boolean {$/;"	f
isDocumentEdit	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isDocumentEdit(edit: any): boolean {$/;"	f
isDocumentEdit	nvim/plugged/coc.nvim/src/util/index.ts	/^export function isDocumentEdit(edit: any): boolean {$/;"	f
concurrent	nvim/plugged/coc.nvim/src/util/index.ts	/^export function concurrent(fns: (() => Promise<any>)[], limit = Infinity): Promise<any[]> {$/;"	f
concurrent	nvim/plugged/coc.nvim/src/util/index.ts	/^export function concurrent(fns: (() => Promise<any>)[], limit = Infinity): Promise<any[]> {$/;"	f
concurrent	nvim/plugged/coc.nvim/src/util/index.ts	/^export function concurrent(fns: (() => Promise<any>)[], limit = Infinity): Promise<any[]> {$/;"	f
deepClone	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepClone<T>(obj: T): T {$/;"	f
deepClone	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepClone<T>(obj: T): T {$/;"	f
deepClone	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepClone<T>(obj: T): T {$/;"	f
deepFreeze	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepFreeze<T>(obj: T): T {$/;"	f
deepFreeze	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepFreeze<T>(obj: T): T {$/;"	f
deepFreeze	nvim/plugged/coc.nvim/src/util/object.ts	/^export function deepFreeze<T>(obj: T): T {$/;"	f
mixin	nvim/plugged/coc.nvim/src/util/object.ts	/^export function mixin($/;"	f
mixin	nvim/plugged/coc.nvim/src/util/object.ts	/^export function mixin($/;"	f
mixin	nvim/plugged/coc.nvim/src/util/object.ts	/^export function mixin($/;"	f
equals	nvim/plugged/coc.nvim/src/util/object.ts	/^export function equals(one: any, other: any): boolean {$/;"	f
equals	nvim/plugged/coc.nvim/src/util/object.ts	/^export function equals(one: any, other: any): boolean {$/;"	f
equals	nvim/plugged/coc.nvim/src/util/object.ts	/^export function equals(one: any, other: any): boolean {$/;"	f
IProcessEnvironment	nvim/plugged/coc.nvim/src/util/platform.ts	/^export interface IProcessEnvironment {$/;"	i
INodeProcess	nvim/plugged/coc.nvim/src/util/platform.ts	/^interface INodeProcess {$/;"	i
INavigator	nvim/plugged/coc.nvim/src/util/platform.ts	/^interface INavigator {$/;"	i
language	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const language = 'en'$/;"	v
Platform	nvim/plugged/coc.nvim/src/util/platform.ts	/^export enum Platform {$/;"	e
isWindows	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const isWindows = _isWindows$/;"	v
isMacintosh	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const isMacintosh = _isMacintosh$/;"	v
isLinux	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const isLinux = _isLinux$/;"	v
isNative	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const isNative = _isNative$/;"	v
isWeb	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const isWeb = _isWeb$/;"	v
platform	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const platform = _platform$/;"	v
globals	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const globals: any = _globals$/;"	v
enum	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const enum OperatingSystem {$/;"	v
OS	nvim/plugged/coc.nvim/src/util/platform.ts	/^export const OS = _isMacintosh$/;"	v
Callback	nvim/plugged/coc.nvim/src/completion/complete.ts	/^export type Callback = () => void$/;"	t
Complete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^export default class Complete {$/;"	c
results	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public results: CompleteResult[] = []$/;"	m
recentScores	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public readonly recentScores: RecentScore$/;"	m
completing	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private completing: Set<string> = new Set()$/;"	m
_canceled	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private _canceled = false$/;"	m
localBonus	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private localBonus: Map<string, number>$/;"	m
tokenSources	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private tokenSources: Map<string, CancellationTokenSource> = new Map()$/;"	m
_onDidComplete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private readonly _onDidComplete = new Emitter<void>()$/;"	m
onDidComplete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public readonly onDidComplete: Event<void> = this._onDidComplete.event$/;"	m
document	nvim/plugged/coc.nvim/src/completion/complete.ts	/^    private document: Document,$/;"	m
config	nvim/plugged/coc.nvim/src/completion/complete.ts	/^    private config: CompleteConfig,$/;"	m
sources	nvim/plugged/coc.nvim/src/completion/complete.ts	/^    private sources: ISource[],$/;"	m
nvim	nvim/plugged/coc.nvim/src/completion/complete.ts	/^    private nvim: Neovim) {$/;"	m
isCompleting	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get isCompleting(): boolean {$/;"	m
isCanceled	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get isCanceled(): boolean {$/;"	m
isEmpty	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get isEmpty(): boolean {$/;"	m
startcol	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get startcol(): number {$/;"	m
input	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get input(): string {$/;"	m
isIncomplete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public get isIncomplete(): boolean {$/;"	m
completeSource	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private async completeSource(source: ISource): Promise<void> {$/;"	m
completeInComplete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public async completeInComplete(resumeInput: string): Promise<VimCompleteItem[]> {$/;"	m
filterResults	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public filterResults(input: string, cid = 0): VimCompleteItem[] {$/;"	m
limitCompleteItems	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private limitCompleteItems(items: VimCompleteItem[]): VimCompleteItem[] {$/;"	m
hasMatch	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public hasMatch(input: string): boolean {$/;"	m
doComplete	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public async doComplete(): Promise<VimCompleteItem[]> {$/;"	m
resolveCompletionItem	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public resolveCompletionItem(item: VimCompleteItem): VimCompleteItem | null {$/;"	m
getFollowPart	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  private getFollowPart(): string {$/;"	m
dispose	nvim/plugged/coc.nvim/src/completion/complete.ts	/^  public dispose(): void {$/;"	m
Bounding	nvim/plugged/coc.nvim/src/completion/floating.ts	/^interface Bounding {$/;"	i
FloatingConfig	nvim/plugged/coc.nvim/src/completion/floating.ts	/^export interface FloatingConfig {$/;"	i
Floating	nvim/plugged/coc.nvim/src/completion/floating.ts	/^export default class Floating {$/;"	c
window	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private window: Window$/;"	m
floatBuffer	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private floatBuffer: FloatBuffer$/;"	m
config	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private config: FloatingConfig$/;"	m
popup	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private popup: Popup$/;"	m
buffer	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private get buffer(): Buffer {$/;"	m
showDocumentationFloating	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private async showDocumentationFloating(docs: Documentation[], bounding: PumBounding, token: CancellationToken): Promise<void> {$/;"	m
showDocumentationVim	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private async showDocumentationVim(docs: Documentation[], bounding: PumBounding, token: CancellationToken): Promise<void> {$/;"	m
show	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  public async show(docs: Documentation[], bounding: PumBounding, token: CancellationToken): Promise<void> {$/;"	m
calculateBounding	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private async calculateBounding(docs: Documentation[], bounding: PumBounding): Promise<Bounding> {$/;"	m
checkBuffer	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  private async checkBuffer(): Promise<void> {$/;"	m
close	nvim/plugged/coc.nvim/src/completion/floating.ts	/^  public close(): void {$/;"	m
nextWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextWordIndex(start = 0, codes: number[]): number {$/;"	f
nextWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextWordIndex(start = 0, codes: number[]): number {$/;"	f
nextWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextWordIndex(start = 0, codes: number[]): number {$/;"	f
upperCase	nvim/plugged/coc.nvim/src/completion/match.ts	/^function upperCase(code: number): boolean {$/;"	f
upperCase	nvim/plugged/coc.nvim/src/completion/match.ts	/^function upperCase(code: number): boolean {$/;"	f
upperCase	nvim/plugged/coc.nvim/src/completion/match.ts	/^function upperCase(code: number): boolean {$/;"	f
isWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function isWordIndex(index: number, codes: number[]): boolean {$/;"	f
isWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function isWordIndex(index: number, codes: number[]): boolean {$/;"	f
isWordIndex	nvim/plugged/coc.nvim/src/completion/match.ts	/^function isWordIndex(index: number, codes: number[]): boolean {$/;"	f
matchScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^export function matchScore(word: string, input: number[]): number {$/;"	f
matchScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^export function matchScore(word: string, input: number[]): number {$/;"	f
matchScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^export function matchScore(word: string, input: number[]): number {$/;"	f
nextScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextScore(codes: number[], index: number, inputCodes: number[], allowFuzzy = true): number {$/;"	f
nextScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextScore(codes: number[], index: number, inputCodes: number[], allowFuzzy = true): number {$/;"	f
nextScore	nvim/plugged/coc.nvim/src/completion/match.ts	/^function nextScore(codes: number[], index: number, inputCodes: number[], allowFuzzy = true): number {$/;"	f
LastInsert	nvim/plugged/coc.nvim/src/completion/index.ts	/^export interface LastInsert {$/;"	i
Completion	nvim/plugged/coc.nvim/src/completion/index.ts	/^export class Completion implements Disposable {$/;"	c
config	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public config: CompleteConfig$/;"	m
document	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private document: Document$/;"	m
floating	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private floating: Floating$/;"	m
currItem	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private currItem: VimCompleteItem$/;"	m
activated	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private activated = false$/;"	m
input	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private input: string$/;"	m
lastInsert	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private lastInsert?: LastInsert$/;"	m
disposables	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private disposables: Disposable[] = []$/;"	m
complete	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private complete: Complete | null = null$/;"	m
recentScores	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private recentScores: RecentScore = {}$/;"	m
resolveTokenSource	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private resolveTokenSource: CancellationTokenSource$/;"	m
changedTick	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private changedTick = 0$/;"	m
insertCharTs	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private insertCharTs = 0$/;"	m
insertLeaveTs	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private insertLeaveTs = 0$/;"	m
isResolving	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private isResolving = false$/;"	m
init	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public init(): void {$/;"	m
nvim	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private get nvim(): Neovim {$/;"	m
option	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public get option(): CompleteOption {$/;"	m
addRecent	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private addRecent(word: string, bufnr: number): void {$/;"	m
getPreviousContent	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async getPreviousContent(document: Document): Promise<string> {$/;"	m
getResumeInput	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public getResumeInput(pre: string): string {$/;"	m
bufnr	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private get bufnr(): number {$/;"	m
isActivated	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public get isActivated(): boolean {$/;"	m
getCompleteConfig	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private getCompleteConfig(): CompleteConfig {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/completion/index.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/completion/index.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/completion/index.ts	/^    function getConfig<T>(key, defaultValue: T): T {$/;"	f
startCompletion	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public async startCompletion(option: CompleteOption): Promise<void> {$/;"	m
resumeCompletion	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async resumeCompletion(pre: string, search: string | null, force = false): Promise<void> {$/;"	m
hasSelected	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public hasSelected(): boolean {$/;"	m
showCompletion	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async showCompletion(col: number, items: VimCompleteItem[]): Promise<void> {$/;"	m
_doComplete	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async _doComplete(option: CompleteOption): Promise<void> {$/;"	m
onTextChangedP	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onTextChangedP(): Promise<void> {$/;"	m
onTextChangedI	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onTextChangedI(bufnr: number): Promise<void> {$/;"	m
triggerCompletion	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async triggerCompletion(document: Document, pre: string, checkTrigger = true): Promise<void> {$/;"	m
fixCompleteOption	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private fixCompleteOption(opt: CompleteOption): void {$/;"	m
onCompleteDone	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onCompleteDone(item: VimCompleteItem): Promise<void> {$/;"	m
onInsertLeave	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onInsertLeave(bufnr: number): Promise<void> {$/;"	m
onInsertEnter	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onInsertEnter(bufnr: number): Promise<void> {$/;"	m
onInsertCharPre	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private async onInsertCharPre(character: string): Promise<void> {$/;"	m
latestInsert	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private get latestInsert(): LastInsert | null {$/;"	m
latestInsertChar	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private get latestInsertChar(): string {$/;"	m
shouldTrigger	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public async shouldTrigger(document: Document, pre: string): Promise<boolean> {$/;"	m
onPumChange	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public async onPumChange(ev: PopupChangeEvent): Promise<void> {$/;"	m
start	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public start(complete: Complete): void {$/;"	m
cancel	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private cancel(): void {$/;"	m
stop	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public stop(): void {$/;"	m
getInput	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private getInput(document: Document, pre: string): string {$/;"	m
completeOpt	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private get completeOpt(): string {$/;"	m
getCompleteItem	nvim/plugged/coc.nvim/src/completion/index.ts	/^  private getCompleteItem(item: VimCompleteItem): VimCompleteItem | null {$/;"	m
dispose	nvim/plugged/coc.nvim/src/completion/index.ts	/^  public dispose(): void {$/;"	m
DiagnosticConfig	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^export interface DiagnosticConfig {$/;"	i
DiagnosticManager	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^export class DiagnosticManager implements Disposable {$/;"	c
config	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public config: DiagnosticConfig$/;"	m
enabled	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public enabled = true$/;"	m
buffers	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public readonly buffers: DiagnosticBuffer[] = []$/;"	m
lastMessage	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private lastMessage = ''$/;"	m
floatFactory	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private floatFactory: FloatFactory$/;"	m
collections	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private collections: DiagnosticCollection[] = []$/;"	m
disposables	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private disposables: Disposable[] = []$/;"	m
timer	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private timer: NodeJS.Timer$/;"	m
lastChanageTs	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private lastChanageTs = 0$/;"	m
init	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public init(): void {$/;"	m
createDiagnosticBuffer	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private createDiagnosticBuffer(doc: Document): void {$/;"	m
setConfigurationErrors	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public setConfigurationErrors(init?: boolean): void {$/;"	m
create	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public create(name: string): DiagnosticCollection {$/;"	m
getSortedRanges	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public getSortedRanges(uri: string, severity?: string): Range[] {$/;"	m
getDiagnostics	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public getDiagnostics(uri: string): ReadonlyArray<Diagnostic> {$/;"	m
getDiagnosticsInRange	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public getDiagnosticsInRange(document: TextDocument, range: Range): Diagnostic[] {$/;"	m
preview	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async preview(): Promise<void> {$/;"	m
jumpPrevious	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async jumpPrevious(severity?: string): Promise<void> {$/;"	m
jumpNext	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async jumpNext(severity?: string): Promise<void> {$/;"	m
getDiagnosticList	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public getDiagnosticList(): DiagnosticItem[] {$/;"	m
getDiagnosticsAt	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private async getDiagnosticsAt(bufnr: number, cursor: [number, number]): Promise<Diagnostic[]> {$/;"	m
getCurrentDiagnostics	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async getCurrentDiagnostics(): Promise<Diagnostic[]> {$/;"	m
echoMessage	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async echoMessage(truncate = false): Promise<void> {$/;"	m
jumpRelated	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public async jumpRelated(): Promise<void> {$/;"	m
disposeBuffer	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private disposeBuffer(bufnr: number): void {$/;"	m
hideFloat	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public hideFloat(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  public dispose(): void {$/;"	m
nvim	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private get nvim(): Neovim {$/;"	m
setConfiguration	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private setConfiguration(event?: ConfigurationChangeEvent): void {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^    function getConfig<T>(key: string, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^    function getConfig<T>(key: string, defaultValue: T): T {$/;"	f
getConfig	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^    function getConfig<T>(key: string, defaultValue: T): T {$/;"	f
getCollections	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private getCollections(uri: string): DiagnosticCollection[] {$/;"	m
shouldValidate	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private shouldValidate(doc: Document | null): boolean {$/;"	m
refreshBuffer	nvim/plugged/coc.nvim/src/diagnostic/manager.ts	/^  private refreshBuffer(uri: string): boolean {$/;"	m
Collection	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^export default class Collection implements DiagnosticCollection {$/;"	c
diagnosticsMap	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  private diagnosticsMap: Map<string, Diagnostic[]> = new Map()$/;"	m
_onDispose	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  private _onDispose = new Emitter<void>()$/;"	m
_onDidDiagnosticsChange	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  private _onDidDiagnosticsChange = new Emitter<string>()$/;"	m
_onDidDiagnosticsClear	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  private _onDidDiagnosticsClear = new Emitter<string[]>()$/;"	m
name	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public readonly name: string$/;"	m
onDispose	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public readonly onDispose: Event<void> = this._onDispose.event$/;"	m
onDidDiagnosticsChange	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public readonly onDidDiagnosticsChange: Event<string> = this._onDidDiagnosticsChange.event$/;"	m
onDidDiagnosticsClear	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public readonly onDidDiagnosticsClear: Event<string[]> = this._onDidDiagnosticsClear.event$/;"	m
set	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public set(uri: string, diagnostics: Diagnostic[] | null): void$/;"	m
set	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public set(entries: [string, Diagnostic[] | null][]): void$/;"	m
set	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public set(entries: [string, Diagnostic[] | null][] | string, diagnostics?: Diagnostic[]): void {$/;"	m
delete	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public delete(uri: string): void {$/;"	m
clear	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public clear(): void {$/;"	m
forEach	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public forEach(callback: (uri: string, diagnostics: Diagnostic[], collection: DiagnosticCollection) => any, thisArg?: any): void {$/;"	m
get	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public get(uri: string): Diagnostic[] {$/;"	m
has	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public has(uri: string): boolean {$/;"	m
dispose	nvim/plugged/coc.nvim/src/diagnostic/collection.ts	/^  public dispose(): void {$/;"	m
DiagnosticBuffer	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^export class DiagnosticBuffer implements Disposable {$/;"	c
srdId	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private readonly srdId: number$/;"	m
signIds	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private readonly signIds: Set<number> = new Set()$/;"	m
sequence	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private sequence: CallSequence = null$/;"	m
_onDidRefresh	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private readonly _onDidRefresh = new Emitter<void>()$/;"	m
matchIds	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public readonly matchIds: Set<number> = new Set()$/;"	m
diagnostics	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public diagnostics: ReadonlyArray<Diagnostic> = []$/;"	m
onDidRefresh	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public readonly onDidRefresh: Event<void> = this._onDidRefresh.event$/;"	m
bufnr	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public readonly bufnr: number$/;"	m
refresh	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public readonly refresh: (diagnosticItems: ReadonlyArray<Diagnostic>) => void$/;"	m
_refresh	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private _refresh(diagnostics: ReadonlyArray<Diagnostic>): void {$/;"	m
setLocationlist	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public setLocationlist(diagnostics: ReadonlyArray<Diagnostic>, winid: number): void {$/;"	m
clearSigns	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private clearSigns(): void {$/;"	m
checkSigns	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public async checkSigns(): Promise<void> {$/;"	m
addSigns	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public addSigns(diagnostics: ReadonlyArray<Diagnostic>): void {$/;"	m
setDiagnosticInfo	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public setDiagnosticInfo(bufnr: number, diagnostics: ReadonlyArray<Diagnostic>): void {$/;"	m
addDiagnosticVText	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private addDiagnosticVText(diagnostics: ReadonlyArray<Diagnostic>): void {$/;"	m
clearHighlight	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public clearHighlight(): void {$/;"	m
addHighlight	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public addHighlight(diagnostics: ReadonlyArray<Diagnostic>, winid): void {$/;"	m
fixRange	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private fixRange(range: Range): Range {$/;"	m
clear	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public async clear(): Promise<void> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public dispose(): void {$/;"	m
document	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private get document(): Document | null {$/;"	m
uri	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  public get uri(): string | null {$/;"	m
nvim	nvim/plugged/coc.nvim/src/diagnostic/buffer.ts	/^  private get nvim(): Neovim {$/;"	m
getSeverityName	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityName(severity: DiagnosticSeverity): string {$/;"	f
getSeverityName	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityName(severity: DiagnosticSeverity): string {$/;"	f
getSeverityName	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityName(severity: DiagnosticSeverity): string {$/;"	f
getSeverityType	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityType(severity: DiagnosticSeverity): string {$/;"	f
getSeverityType	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityType(severity: DiagnosticSeverity): string {$/;"	f
getSeverityType	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getSeverityType(severity: DiagnosticSeverity): string {$/;"	f
severityLevel	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function severityLevel(level: string): number {$/;"	f
severityLevel	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function severityLevel(level: string): number {$/;"	f
severityLevel	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function severityLevel(level: string): number {$/;"	f
getNameFromSeverity	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getNameFromSeverity(severity: DiagnosticSeverity): string {$/;"	f
getNameFromSeverity	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getNameFromSeverity(severity: DiagnosticSeverity): string {$/;"	f
getNameFromSeverity	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getNameFromSeverity(severity: DiagnosticSeverity): string {$/;"	f
getLocationListItem	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getLocationListItem(owner: string, bufnr: number, diagnostic: Diagnostic): LocationListItem {$/;"	f
getLocationListItem	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getLocationListItem(owner: string, bufnr: number, diagnostic: Diagnostic): LocationListItem {$/;"	f
getLocationListItem	nvim/plugged/coc.nvim/src/diagnostic/util.ts	/^export function getLocationListItem(owner: string, bufnr: number, diagnostic: Diagnostic): LocationListItem {$/;"	f
Configuration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^export class Configuration {$/;"	c
_consolidateConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  private _consolidateConfiguration: ConfigurationModel$/;"	m
_defaultConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^    private _defaultConfiguration: ConfigurationModel,$/;"	m
_userConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^    private _userConfiguration: ConfigurationModel,$/;"	m
_workspaceConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^    private _workspaceConfiguration: ConfigurationModel,$/;"	m
_memoryConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^    private _memoryConfiguration: ConfigurationModel = new ConfigurationModel(),$/;"	m
getConsolidateConfiguration	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  private getConsolidateConfiguration(): ConfigurationModel {$/;"	m
getValue	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public getValue(section?: string): any {$/;"	m
inspect	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public inspect<C>(key: string): {$/;"	m
defaults	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public get defaults(): ConfigurationModel {$/;"	m
user	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public get user(): ConfigurationModel {$/;"	m
workspace	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public get workspace(): ConfigurationModel {$/;"	m
toData	nvim/plugged/coc.nvim/src/configuration/configuration.ts	/^  public toData(): IConfigurationData {$/;"	m
ConfigurationModel	nvim/plugged/coc.nvim/src/configuration/model.ts	/^export class ConfigurationModel implements IConfigurationModel {$/;"	c
contents	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public get contents(): any {$/;"	m
clone	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public clone(): ConfigurationModel {$/;"	m
getValue	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public getValue<V>(section: string): V {$/;"	m
merge	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public merge(...others: ConfigurationModel[]): ConfigurationModel {$/;"	m
freeze	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public freeze(): ConfigurationModel {$/;"	m
mergeContents	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  private mergeContents(source: any, target: any): void {$/;"	m
setValue	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public setValue(key: string, value: any): void {$/;"	m
removeValue	nvim/plugged/coc.nvim/src/configuration/model.ts	/^  public removeValue(key: string): void {$/;"	m
ConfigurationProxy	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^export default class ConfigurationProxy implements ConfigurationShape {$/;"	c
nvim	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^  private get nvim(): Neovim {$/;"	m
modifyConfiguration	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^  private async modifyConfiguration(target: ConfigurationTarget, key: string, value?: any): Promise<void> {$/;"	m
workspaceConfigFile	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^  public get workspaceConfigFile(): string {$/;"	m
$updateConfigurationOption	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^  public $updateConfigurationOption(target: ConfigurationTarget, key: string, value: any): void {$/;"	m
$removeConfigurationOption	nvim/plugged/coc.nvim/src/configuration/shape.ts	/^  public $removeConfigurationOption(target: ConfigurationTarget, key: string): void {$/;"	m
lookUp	nvim/plugged/coc.nvim/src/configuration/index.ts	/^function lookUp(tree: any, key: string): any {$/;"	f
lookUp	nvim/plugged/coc.nvim/src/configuration/index.ts	/^function lookUp(tree: any, key: string): any {$/;"	f
lookUp	nvim/plugged/coc.nvim/src/configuration/index.ts	/^function lookUp(tree: any, key: string): any {$/;"	f
Configurations	nvim/plugged/coc.nvim/src/configuration/index.ts	/^export default class Configurations {$/;"	c
_configuration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private _configuration: Configuration$/;"	m
_errorItems	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private _errorItems: ErrorItem[] = []$/;"	m
_folderConfigurations	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private _folderConfigurations: Map<string, ConfigurationModel> = new Map()$/;"	m
_onError	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private _onError = new Emitter<ErrorItem[]>()$/;"	m
_onChange	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private _onChange = new Emitter<ConfigurationChangeEvent>()$/;"	m
disposables	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private disposables: Disposable[] = []$/;"	m
workspaceConfigFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private workspaceConfigFile: string$/;"	m
onError	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public readonly onError: Event<ErrorItem[]> = this._onError.event$/;"	m
onDidChange	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public readonly onDidChange: Event<ConfigurationChangeEvent> = this._onChange.event$/;"	m
userConfigFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^    private userConfigFile?: string | null,$/;"	m
_proxy	nvim/plugged/coc.nvim/src/configuration/index.ts	/^    private readonly _proxy?: ConfigurationShape$/;"	m
parseContentFromFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private parseContentFromFile(filepath: string): IConfigurationModel {$/;"	m
errorItems	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get errorItems(): ErrorItem[] {$/;"	m
foldConfigurations	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get foldConfigurations(): Map<string, ConfigurationModel> {$/;"	m
extendsDefaults	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public extendsDefaults(props: { [key: string]: any }): void {$/;"	m
updateUserConfig	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public updateUserConfig(props: { [key: string]: any }): void {$/;"	m
defaults	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get defaults(): ConfigurationModel {$/;"	m
user	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get user(): ConfigurationModel {$/;"	m
workspace	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get workspace(): ConfigurationModel {$/;"	m
addFolderFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public addFolderFile(filepath: string): void {$/;"	m
watchFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private watchFile(filepath: string, target: ConfigurationTarget): void {$/;"	m
changeConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public changeConfiguration(target: ConfigurationTarget, model: IConfigurationModel, configFile?: string): void {$/;"	m
setFolderConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public setFolderConfiguration(uri: string): void {$/;"	m
hasFolderConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public hasFolderConfiguration(filepath: string): boolean {$/;"	m
getConfigFile	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public getConfigFile(target: ConfigurationTarget): string {$/;"	m
folders	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private get folders(): string[] {$/;"	m
configuration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public get configuration(): Configuration {$/;"	m
getConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public getConfiguration(section?: string, resource?: string): WorkspaceConfiguration {$/;"	m
getFolderConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private getFolderConfiguration(uri: string): ConfigurationModel {$/;"	m
checkFolderConfiguration	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public checkFolderConfiguration(uri: string): void {$/;"	m
parse	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  private static parse(data: IConfigurationData): Configuration {$/;"	m
dispose	nvim/plugged/coc.nvim/src/configuration/index.ts	/^  public dispose(): void {$/;"	m
ShowError	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export type ShowError = (errors: ErrorItem[]) => void$/;"	t
parseContentFromFile	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseContentFromFile(filepath: string | null, onError?: ShowError): IConfigurationModel {$/;"	f
parseContentFromFile	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseContentFromFile(filepath: string | null, onError?: ShowError): IConfigurationModel {$/;"	f
parseContentFromFile	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseContentFromFile(filepath: string | null, onError?: ShowError): IConfigurationModel {$/;"	f
parseConfiguration	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseConfiguration(content: string): [ParseError[], any] {$/;"	f
parseConfiguration	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseConfiguration(content: string): [ParseError[], any] {$/;"	f
parseConfiguration	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function parseConfiguration(content: string): [ParseError[], any] {$/;"	f
addProperty	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function addProperty(current: object, key: string, remains: string[], value: any): void {$/;"	f
addProperty	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function addProperty(current: object, key: string, remains: string[], value: any): void {$/;"	f
addProperty	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function addProperty(current: object, key: string, remains: string[], value: any): void {$/;"	f
convert	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function convert(obj: any, split = false): any {$/;"	f
convert	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function convert(obj: any, split = false): any {$/;"	f
convert	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function convert(obj: any, split = false): any {$/;"	f
convertErrors	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function convertErrors(uri: string, content: string, errors: ParseError[]): ErrorItem[] {$/;"	f
convertErrors	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function convertErrors(uri: string, content: string, errors: ParseError[]): ErrorItem[] {$/;"	f
convertErrors	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function convertErrors(uri: string, content: string, errors: ParseError[]): ErrorItem[] {$/;"	f
addToValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function addToValueTree($/;"	f
addToValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function addToValueTree($/;"	f
addToValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function addToValueTree($/;"	f
removeFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function removeFromValueTree(valueTree: any, key: string): void {$/;"	f
removeFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function removeFromValueTree(valueTree: any, key: string): void {$/;"	f
removeFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function removeFromValueTree(valueTree: any, key: string): void {$/;"	f
doRemoveFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^function doRemoveFromValueTree(valueTree: any, segments: string[]): void {$/;"	f
doRemoveFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^function doRemoveFromValueTree(valueTree: any, segments: string[]): void {$/;"	f
doRemoveFromValueTree	nvim/plugged/coc.nvim/src/configuration/util.ts	/^function doRemoveFromValueTree(valueTree: any, segments: string[]): void {$/;"	f
getConfigurationValue	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getConfigurationValue<T>($/;"	f
getConfigurationValue	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getConfigurationValue<T>($/;"	f
getConfigurationValue	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getConfigurationValue<T>($/;"	f
accessSetting	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function accessSetting(config: any, path: string[]): any {$/;"	f
accessSetting	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function accessSetting(config: any, path: string[]): any {$/;"	f
accessSetting	nvim/plugged/coc.nvim/src/configuration/util.ts	/^  function accessSetting(config: any, path: string[]): any {$/;"	f
loadDefaultConfigurations	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function loadDefaultConfigurations(): IConfigurationModel {$/;"	f
loadDefaultConfigurations	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function loadDefaultConfigurations(): IConfigurationModel {$/;"	f
loadDefaultConfigurations	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function loadDefaultConfigurations(): IConfigurationModel {$/;"	f
getKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getKeys(obj: { [key: string]: any }, curr?: string): string[] {$/;"	f
getKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getKeys(obj: { [key: string]: any }, curr?: string): string[] {$/;"	f
getKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getKeys(obj: { [key: string]: any }, curr?: string): string[] {$/;"	f
getChangedKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getChangedKeys(from: { [key: string]: any }, to: { [key: string]: any }): string[] {$/;"	f
getChangedKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getChangedKeys(from: { [key: string]: any }, to: { [key: string]: any }): string[] {$/;"	f
getChangedKeys	nvim/plugged/coc.nvim/src/configuration/util.ts	/^export function getChangedKeys(from: { [key: string]: any }, to: { [key: string]: any }): string[] {$/;"	f
ListManager	nvim/plugged/coc.nvim/src/list/manager.ts	/^export class ListManager implements Disposable {$/;"	c
prompt	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public prompt: Prompt$/;"	m
ui	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public ui: UI$/;"	m
history	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public history: History$/;"	m
listOptions	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public listOptions: ListOptions$/;"	m
config	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public config: ListConfiguration$/;"	m
worker	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public worker: Worker$/;"	m
plugTs	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private plugTs = 0$/;"	m
disposables	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private disposables: Disposable[] = []$/;"	m
savedHeight	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private savedHeight: number$/;"	m
args	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private args: string[] = []$/;"	m
listArgs	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private listArgs: string[] = []$/;"	m
charMap	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private charMap: Map<string, string>$/;"	m
listMap	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private listMap: Map<string, IList> = new Map()$/;"	m
mappings	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private mappings: Mappings$/;"	m
currList	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private currList: IList$/;"	m
cwd	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private cwd: string$/;"	m
window	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private window: Window$/;"	m
activated	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private activated = false$/;"	m
executing	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private executing = false$/;"	m
nvim	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private nvim: Neovim$/;"	m
init	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public init(nvim: Neovim): void {$/;"	m
start	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async start(args: string[]): Promise<void> {$/;"	m
resume	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async resume(): Promise<void> {$/;"	m
doAction	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async doAction(name?: string): Promise<void> {$/;"	m
previous	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async previous(): Promise<void> {$/;"	m
next	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async next(): Promise<void> {$/;"	m
cancel	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async cancel(close = true): Promise<void> {$/;"	m
switchMatcher	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async switchMatcher(): Promise<void> {$/;"	m
togglePreview	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async togglePreview(): Promise<void> {$/;"	m
chooseAction	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async chooseAction(): Promise<void> {$/;"	m
name	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public get name(): string {$/;"	m
list	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public get list(): IList {$/;"	m
parseArgs	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public parseArgs(args: string[]): { list: IList, options: ListOptions, listArgs: string[] } | null {$/;"	m
updateStatus	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public updateStatus(): void {$/;"	m
onInputChar	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async onInputChar(ch: string, charmod: number): Promise<void> {$/;"	m
onInsertInput	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async onInsertInput(ch: string, charmod: number): Promise<void> {$/;"	m
onNormalInput	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async onNormalInput(ch: string, _charmod: number): Promise<void> {$/;"	m
onMouseEvent	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public onMouseEvent(key): Promise<void> {$/;"	m
feedkeys	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async feedkeys(key: string, remap = true): Promise<void> {$/;"	m
command	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async command(command: string): Promise<void> {$/;"	m
normal	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async normal(command: string, bang = true): Promise<void> {$/;"	m
call	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async call(fname: string): Promise<any> {$/;"	m
showHelp	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public async showHelp(): Promise<void> {$/;"	m
context	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public get context(): ListContext {$/;"	m
registerList	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public registerList(list: IList): Disposable {$/;"	m
names	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public get names(): string[] {$/;"	m
toggleMode	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public toggleMode(): void {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public getConfig<T>(key: string, defaultValue: T): T {$/;"	m
isActivated	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public get isActivated(): boolean {$/;"	m
stop	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public stop(): void {$/;"	m
reset	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public reset(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/list/manager.ts	/^  public dispose(): void {$/;"	m
getCharMap	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async getCharMap(): Promise<void> {$/;"	m
doItemAction	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async doItemAction(items: ListItem[], action: ListAction): Promise<void> {$/;"	m
resolveItem	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private async resolveItem(): Promise<void> {$/;"	m
defaultAction	nvim/plugged/coc.nvim/src/list/manager.ts	/^  private get defaultAction(): ListAction {$/;"	m
validKeys	nvim/plugged/coc.nvim/src/list/configuration.ts	/^export const validKeys = [$/;"	v
ListConfiguration	nvim/plugged/coc.nvim/src/list/configuration.ts	/^export default class ListConfiguration {$/;"	c
configuration	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  private configuration: WorkspaceConfiguration$/;"	m
disposable	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  private disposable: Disposable$/;"	m
get	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  public get<T>(key: string, defaultValue?: T): T {$/;"	m
previousKey	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  public get previousKey(): string {$/;"	m
nextKey	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  public get nextKey(): string {$/;"	m
dispose	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  public dispose(): void {$/;"	m
fixKey	nvim/plugged/coc.nvim/src/list/configuration.ts	/^  public fixKey(key: string): string {$/;"	m
MouseEvent	nvim/plugged/coc.nvim/src/list/ui.ts	/^export type MouseEvent = 'mouseDown' | 'mouseDrag' | 'mouseUp' | 'doubleClick'$/;"	t
MousePosition	nvim/plugged/coc.nvim/src/list/ui.ts	/^export interface MousePosition {$/;"	i
ListUI	nvim/plugged/coc.nvim/src/list/ui.ts	/^export default class ListUI {$/;"	c
window	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public window: Window$/;"	m
height	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private height: number$/;"	m
newTab	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private newTab = false$/;"	m
_bufnr	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _bufnr = 0$/;"	m
currIndex	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private currIndex = 0$/;"	m
highlights	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private highlights: ListHighlights[] = []$/;"	m
items	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private items: ListItem[] = []$/;"	m
disposables	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private disposables: Disposable[] = []$/;"	m
signOffset	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private signOffset: number$/;"	m
selected	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private selected: Set<number> = new Set()$/;"	m
mouseDown	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private mouseDown: MousePosition$/;"	m
creating	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private creating = false$/;"	m
_onDidChangeLine	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDidChangeLine = new Emitter<number>()$/;"	m
_onDidOpen	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDidOpen = new Emitter<number>()$/;"	m
_onDidClose	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDidClose = new Emitter<number>()$/;"	m
_onDidChange	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDidChange = new Emitter<void>()$/;"	m
_onDidLineChange	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDidLineChange = new Emitter<number>()$/;"	m
_onDoubleClick	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private _onDoubleClick = new Emitter<void>()$/;"	m
onDidChangeLine	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidChangeLine: Event<number> = this._onDidChangeLine.event$/;"	m
onDidLineChange	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidLineChange: Event<number> = this._onDidLineChange.event$/;"	m
onDidOpen	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidOpen: Event<number> = this._onDidOpen.event$/;"	m
onDidClose	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidClose: Event<number> = this._onDidClose.event$/;"	m
onDidChange	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidChange: Event<void> = this._onDidChange.event$/;"	m
onDidDoubleClick	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public readonly onDidDoubleClick: Event<void> = this._onDoubleClick.event$/;"	m
index	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public set index(n: number) {$/;"	m
index	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get index(): number {$/;"	m
getItem	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public getItem(delta: number): ListItem {$/;"	m
item	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get item(): Promise<ListItem> {$/;"	m
echoMessage	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async echoMessage(item: ListItem): Promise<void> {$/;"	m
updateItem	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async updateItem(item: ListItem, index: number): Promise<void> {$/;"	m
getItems	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async getItems(): Promise<ListItem[]> {$/;"	m
onMouse	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async onMouse(event: MouseEvent): Promise<void> {$/;"	m
reset	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public reset(): void {$/;"	m
hide	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public hide(): void {$/;"	m
resume	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async resume(name: string, listOptions: ListOptions): Promise<void> {$/;"	m
toggleSelection	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async toggleSelection(): Promise<void> {$/;"	m
selectLines	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async selectLines(start: number, end: number): Promise<void> {$/;"	m
selectAll	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async selectAll(): Promise<void> {$/;"	m
clearSelection	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public clearSelection(): void {$/;"	m
shown	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get shown(): boolean {$/;"	m
bufnr	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get bufnr(): number {$/;"	m
ready	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get ready(): Promise<void> {$/;"	m
drawItems	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async drawItems(items: ListItem[], name: string, listOptions: ListOptions, reload = false): Promise<void> {$/;"	m
appendItems	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public async appendItems(items: ListItem[]): Promise<void> {$/;"	m
setLines	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private async setLines(lines: string[], append = false, index: number): Promise<void> {$/;"	m
restoreWindow	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public restoreWindow(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public dispose(): void {$/;"	m
length	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get length(): number {$/;"	m
selectedItems	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public get selectedItems(): ListItem[] {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private doHighlight(start: number, end: number): void {$/;"	m
setCursor	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public setCursor(lnum: number, col: number): void {$/;"	m
addHighlights	nvim/plugged/coc.nvim/src/list/ui.ts	/^  public addHighlights(highlights: ListHighlights[], append = false): void {$/;"	m
getSelectedRange	nvim/plugged/coc.nvim/src/list/ui.ts	/^  private async getSelectedRange(): Promise<[number, number]> {$/;"	m
History	nvim/plugged/coc.nvim/src/list/history.ts	/^export default class History {$/;"	c
db	nvim/plugged/coc.nvim/src/list/history.ts	/^  private db: DB$/;"	m
index	nvim/plugged/coc.nvim/src/list/history.ts	/^  private index = -1$/;"	m
loaded	nvim/plugged/coc.nvim/src/list/history.ts	/^  private loaded: string[] = []$/;"	m
current	nvim/plugged/coc.nvim/src/list/history.ts	/^  private current: string[] = []$/;"	m
curr	nvim/plugged/coc.nvim/src/list/history.ts	/^  public get curr(): string | null {$/;"	m
load	nvim/plugged/coc.nvim/src/list/history.ts	/^  public load(): void {$/;"	m
add	nvim/plugged/coc.nvim/src/list/history.ts	/^  public add(): void {$/;"	m
previous	nvim/plugged/coc.nvim/src/list/history.ts	/^  public previous(): void {$/;"	m
next	nvim/plugged/coc.nvim/src/list/history.ts	/^  public next(): void {$/;"	m
ActionOptions	nvim/plugged/coc.nvim/src/list/basic.ts	/^interface ActionOptions {$/;"	i
ArgumentItem	nvim/plugged/coc.nvim/src/list/basic.ts	/^interface ArgumentItem {$/;"	i
name	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public name: string$/;"	m
defaultAction	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public defaultAction = 'open'$/;"	m
actions	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public readonly actions: ListAction[] = []$/;"	m
options	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public options: ListArgument[] = []$/;"	m
disposables	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected disposables: Disposable[] = []$/;"	m
optionMap	nvim/plugged/coc.nvim/src/list/basic.ts	/^  private optionMap: Map<string, ArgumentItem>$/;"	m
config	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public config: ListConfiguration$/;"	m
hlGroup	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected get hlGroup(): string {$/;"	m
previewHeight	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected get previewHeight(): number {$/;"	m
splitRight	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected get splitRight(): boolean {$/;"	m
parseArguments	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public parseArguments(args: string[]): { [key: string]: string | boolean } {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected getConfig(): WorkspaceConfiguration {$/;"	m
addAction	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected addAction(name: string, fn: (item: ListItem, context: ListContext) => ProviderResult<void>, options?: ActionOptions): void {$/;"	m
addMultipleAction	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected addMultipleAction(name: string, fn: (item: ListItem[], context: ListContext) => ProviderResult<void>, options?: ActionOptions): void {$/;"	m
addLocationActions	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public addLocationActions(): void {$/;"	m
convertLocation	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public async convertLocation(location: Location | LocationWithLine | string): Promise<Location> {$/;"	m
jumpTo	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public async jumpTo(location: Location | LocationWithLine | string, command?: string): Promise<void> {$/;"	m
createAction	nvim/plugged/coc.nvim/src/list/basic.ts	/^  private createAction(action: ListAction): void {$/;"	m
previewLocation	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected async previewLocation(location: Location, context: ListContext): Promise<void> {$/;"	m
preview	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public async preview(options: PreiewOptions, context: ListContext): Promise<void> {$/;"	m
getPreviewCommand	nvim/plugged/coc.nvim/src/list/basic.ts	/^  protected getPreviewCommand(context: ListContext): string {$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public abstract loadItems(context: ListContext, token?: CancellationToken): Promise<ListItem[] | ListTask | null | undefined>$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public doHighlight(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/list/basic.ts	/^  public dispose(): void {$/;"	m
Mappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^export default class Mappings {$/;"	c
insertMappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private insertMappings: Map<string, () => void | Promise<void>> = new Map()$/;"	m
normalMappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private normalMappings: Map<string, () => void | Promise<void>> = new Map()$/;"	m
userInsertMappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private userInsertMappings: Map<string, string> = new Map()$/;"	m
userNormalMappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private userNormalMappings: Map<string, string> = new Map()$/;"	m
nvim	nvim/plugged/coc.nvim/src/list/mappings.ts	/^    private nvim: Neovim,$/;"	m
config	nvim/plugged/coc.nvim/src/list/mappings.ts	/^    private config: ListConfiguration) {$/;"	m
fixUserMappings	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private fixUserMappings(mappings: { [key: string]: string }): Map<string, string> {$/;"	m
doInsertKeymap	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  public async doInsertKeymap(key: string): Promise<boolean> {$/;"	m
doNormalKeymap	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  public async doNormalKeymap(key: string): Promise<boolean> {$/;"	m
add	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private add(mode: ListMode, key: string | string[], fn: () => void | Promise<void>): void {$/;"	m
onError	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private async onError(msg: string): Promise<void> {$/;"	m
evalExpression	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private async evalExpression(expr: string, _mode: string): Promise<void> {$/;"	m
doScroll	nvim/plugged/coc.nvim/src/list/mappings.ts	/^  private async doScroll(key: string): Promise<void> {$/;"	m
OutputList	nvim/plugged/coc.nvim/src/list/source/output.ts	/^export default class OutputList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/output.ts	/^  public defaultAction = 'open'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/output.ts	/^  public name = 'output'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/output.ts	/^  public description = 'output channels of coc.nvim'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/output.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
DiagnosticsList	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^export default class DiagnosticsList extends LocationList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^  public readonly defaultAction = 'open'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^  public readonly description = 'diagnostics of current workspace'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^  public name = 'diagnostics'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/diagnostics.ts	/^  public doHighlight(): void {$/;"	m
CommandsList	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^export default class CommandsList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  public defaultAction = 'run'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  public description = 'registered commands of coc.nvim'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  public readonly name = 'commands'$/;"	m
mru	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  private mru: Mru$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^  public doHighlight(): void {$/;"	m
score	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^function score(list: string[], key: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^function score(list: string[], key: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/list/source/commands.ts	/^function score(list: string[], key: string): number {$/;"	f
Symbols	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^export default class Symbols extends LocationList {$/;"	c
interactive	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public readonly interactive = true$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public readonly description = 'search workspace symbols'$/;"	m
detail	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public readonly detail = 'Symbols list is provided by server, it works on interactive mode only.'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public name = 'symbols'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
resolveItem	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public async resolveItem(item: ListItem): Promise<ListItem> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/symbols.ts	/^  public doHighlight(): void {$/;"	m
FoldList	nvim/plugged/coc.nvim/src/list/source/folders.ts	/^export default class FoldList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/folders.ts	/^  public defaultAction = 'edit'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/folders.ts	/^  public description = 'list of current workspace folders'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/folders.ts	/^  public name = 'folders'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/folders.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
Outline	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^export default class Outline extends LocationList {$/;"	c
description	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^  public readonly description = 'symbols of current document'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^  public name = 'outline'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
addSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^      function addSymbols(symbols: DocumentSymbol[], level = 0): void {$/;"	f
addSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^      function addSymbols(symbols: DocumentSymbol[], level = 0): void {$/;"	f
addSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^      function addSymbols(symbols: DocumentSymbol[], level = 0): void {$/;"	f
doHighlight	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^  public doHighlight(): void {$/;"	m
loadCtagsSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^  public async loadCtagsSymbols(document: Document): Promise<ListItem[]> {$/;"	m
sortSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^function sortSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
sortSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^function sortSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
sortSymbols	nvim/plugged/coc.nvim/src/list/source/outline.ts	/^function sortSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
ServicesList	nvim/plugged/coc.nvim/src/list/source/services.ts	/^export default class ServicesList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/services.ts	/^  public defaultAction = 'toggle'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/services.ts	/^  public description = 'registered services of coc.nvim'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/services.ts	/^  public name = 'services'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/services.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/services.ts	/^  public doHighlight(): void {$/;"	m
ExtensionList	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^export default class ExtensionList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^  public defaultAction = 'toggle'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^  public description = 'manage coc extensions'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^  public name = 'extensions'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^  public doHighlight(): void {$/;"	m
getPriority	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^function getPriority(stat: string): number {$/;"	f
getPriority	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^function getPriority(stat: string): number {$/;"	f
getPriority	nvim/plugged/coc.nvim/src/list/source/extensions.ts	/^function getPriority(stat: string): number {$/;"	f
LocationList	nvim/plugged/coc.nvim/src/list/source/location.ts	/^export default class LocationList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/location.ts	/^  public defaultAction = 'open'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/location.ts	/^  public description = 'show locations saved by g:coc_jump_locations variable'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/location.ts	/^  public name = 'location'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/location.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/location.ts	/^  public doHighlight(): void {$/;"	m
LinksList	nvim/plugged/coc.nvim/src/list/source/links.ts	/^export default class LinksList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/links.ts	/^  public defaultAction = 'open'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/links.ts	/^  public description = 'links of current buffer'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/links.ts	/^  public name = 'links'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/links.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
formatUri	nvim/plugged/coc.nvim/src/list/source/links.ts	/^function formatUri(uri: string): string {$/;"	f
formatUri	nvim/plugged/coc.nvim/src/list/source/links.ts	/^function formatUri(uri: string): string {$/;"	f
formatUri	nvim/plugged/coc.nvim/src/list/source/links.ts	/^function formatUri(uri: string): string {$/;"	f
SourcesList	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^export default class SourcesList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^  public readonly defaultAction = 'toggle'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^  public readonly description = 'registered completion sources'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^  public readonly name = 'sources'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/sources.ts	/^  public doHighlight(): void {$/;"	m
LinksList	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^export default class LinksList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  public readonly name = 'lists'$/;"	m
defaultAction	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  public readonly defaultAction = 'open'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  public readonly description = 'registered lists of coc.nvim'$/;"	m
mru	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  private mru: Mru = new Mru('lists')$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  public async loadItems(_context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^  public doHighlight(): void {$/;"	m
score	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^function score(list: string[], key: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^function score(list: string[], key: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/list/source/lists.ts	/^function score(list: string[], key: string): number {$/;"	f
ActionsList	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^export default class ActionsList extends BasicList {$/;"	c
defaultAction	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public defaultAction = 'do'$/;"	m
description	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public description = 'code actions of selected range.'$/;"	m
name	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public name = 'actions'$/;"	m
options	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public options: ListArgument[] = [{$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public async loadItems(context: ListContext): Promise<ListItem[]> {$/;"	m
doHighlight	nvim/plugged/coc.nvim/src/list/source/actions.ts	/^  public doHighlight(): void {$/;"	m
ExtendedItem	nvim/plugged/coc.nvim/src/list/worker.ts	/^export interface ExtendedItem extends ListItem {$/;"	i
Worker	nvim/plugged/coc.nvim/src/list/worker.ts	/^export default class Worker {$/;"	c
recentFiles	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private recentFiles: string[] = []$/;"	m
_loading	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private _loading = false$/;"	m
timer	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private timer: NodeJS.Timer$/;"	m
interval	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private interval: NodeJS.Timer$/;"	m
totalItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private totalItems: ListItem[] = []$/;"	m
tokenSource	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private tokenSource: CancellationTokenSource$/;"	m
_onDidChangeItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private _onDidChangeItems = new Emitter<ListItemsEvent>()$/;"	m
onDidChangeItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public readonly onDidChangeItems: Event<ListItemsEvent> = this._onDidChangeItems.event$/;"	m
loadMru	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private loadMru(): void {$/;"	m
loading	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private set loading(loading: boolean) {$/;"	m
isLoading	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public get isLoading(): boolean {$/;"	m
loadItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public async loadItems(reload = false): Promise<void> {$/;"	m
drawItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public async drawItems(): Promise<void> {$/;"	m
stop	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public stop(): void {$/;"	m
length	nvim/plugged/coc.nvim/src/list/worker.ts	/^  public get length(): number {$/;"	m
input	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private get input(): string {$/;"	m
getItemsHighlight	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private getItemsHighlight(items: ListItem[]): ListHighlights[] {$/;"	m
filterItems	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private filterItems(items: ListItem[]): { items: ListItem[], highlights: ListHighlights[] } {$/;"	m
getHighlights	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private getHighlights(text: string, matches: number[]): ListHighlights {$/;"	m
parseListItemAnsi	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private parseListItemAnsi(item: ListItem): void {$/;"	m
fixLabel	nvim/plugged/coc.nvim/src/list/worker.ts	/^  private fixLabel(label: string): string {$/;"	m
getFilterLabel	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getFilterLabel(item: ListItem): string {$/;"	f
getFilterLabel	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getFilterLabel(item: ListItem): string {$/;"	f
getFilterLabel	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getFilterLabel(item: ListItem): string {$/;"	f
getItemUri	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getItemUri(item: ListItem): string {$/;"	f
getItemUri	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getItemUri(item: ListItem): string {$/;"	f
getItemUri	nvim/plugged/coc.nvim/src/list/worker.ts	/^function getItemUri(item: ListItem): string {$/;"	f
Prompt	nvim/plugged/coc.nvim/src/list/prompt.ts	/^export default class Prompt {$/;"	c
cusorIndex	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private cusorIndex = 0$/;"	m
_input	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private _input = ''$/;"	m
_matcher	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private _matcher: Matcher | ''$/;"	m
_mode	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private _mode: ListMode = 'insert'$/;"	m
interactive	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private interactive = false$/;"	m
requestInput	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private requestInput = false$/;"	m
_onDidChangeInput	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private _onDidChangeInput = new Emitter<string>()$/;"	m
onDidChangeInput	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public readonly onDidChangeInput: Event<string> = this._onDidChangeInput.event$/;"	m
input	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public get input(): string {$/;"	m
input	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public set input(str: string) {$/;"	m
mode	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public get mode(): ListMode {$/;"	m
mode	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public set mode(val: ListMode) {$/;"	m
matcher	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public set matcher(val: Matcher) {$/;"	m
start	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public start(opts?: ListOptions): void {$/;"	m
cancel	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public cancel(): void {$/;"	m
reset	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public reset(): void {$/;"	m
drawPrompt	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public drawPrompt(): void {$/;"	m
moveLeft	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public moveLeft(): void {$/;"	m
moveRight	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public moveRight(): void {$/;"	m
moveToEnd	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public moveToEnd(): void {$/;"	m
moveToStart	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public moveToStart(): void {$/;"	m
onBackspace	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public onBackspace(): void {$/;"	m
removeNext	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public removeNext(): void {$/;"	m
removeWord	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public removeWord(): void {$/;"	m
removeTail	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public removeTail(): void {$/;"	m
removeAhead	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public removeAhead(): void {$/;"	m
acceptCharacter	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public async acceptCharacter(ch: string): Promise<void> {$/;"	m
insertRegister	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public async insertRegister(): Promise<void> {$/;"	m
paste	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public async paste(): Promise<void> {$/;"	m
eval	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  public async eval(expression: string): Promise<void> {$/;"	m
addText	nvim/plugged/coc.nvim/src/list/prompt.ts	/^  private addText(text: string): void {$/;"	m
ProviderItem	nvim/plugged/coc.nvim/src/provider/manager.ts	/^export interface ProviderItem<T> {$/;"	i
Manager	nvim/plugged/coc.nvim/src/provider/manager.ts	/^export default class Manager<T> {$/;"	c
providers	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  protected providers: Set<ProviderItem<T>> = new Set()$/;"	m
hasProvider	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  public hasProvider(document: TextDocument): boolean {$/;"	m
getProvider	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  protected getProvider(document: TextDocument): ProviderItem<T> {$/;"	m
poviderById	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  protected poviderById(id): T {$/;"	m
getProviders	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  protected getProviders(document: TextDocument): ProviderItem<T>[] {$/;"	m
mergeDefinitions	nvim/plugged/coc.nvim/src/provider/manager.ts	/^  protected mergeDefinitions(arr: Definition[]): Location[] {$/;"	m
FormatManager	nvim/plugged/coc.nvim/src/provider/formatManager.ts	/^export default class FormatManager extends Manager<DocumentFormattingEditProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/formatManager.ts	/^  public register(selector: DocumentSelector,$/;"	m
provideDocumentFormattingEdits	nvim/plugged/coc.nvim/src/provider/formatManager.ts	/^  public async provideDocumentFormattingEdits($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/formatManager.ts	/^  public dispose(): void {$/;"	m
DocumentColorManager	nvim/plugged/coc.nvim/src/provider/documentColorManager.ts	/^export default class DocumentColorManager extends Manager<DocumentColorProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/documentColorManager.ts	/^  public register(selector: DocumentSelector, provider: DocumentColorProvider): Disposable {$/;"	m
provideDocumentColors	nvim/plugged/coc.nvim/src/provider/documentColorManager.ts	/^  public async provideDocumentColors(document: TextDocument, token: CancellationToken): Promise<ColorInformation[] | null> {$/;"	m
provideColorPresentations	nvim/plugged/coc.nvim/src/provider/documentColorManager.ts	/^  public async provideColorPresentations(colorInformation: ColorInformation, document: TextDocument, token: CancellationToken): Promise<ColorPresentation[]> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/documentColorManager.ts	/^  public dispose(): void {$/;"	m
TypeDefinitionManager	nvim/plugged/coc.nvim/src/provider/typeDefinitionManager.ts	/^export default class TypeDefinitionManager extends Manager<TypeDefinitionProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/typeDefinitionManager.ts	/^  public register(selector: DocumentSelector, provider: TypeDefinitionProvider): Disposable {$/;"	m
provideTypeDefinition	nvim/plugged/coc.nvim/src/provider/typeDefinitionManager.ts	/^  public async provideTypeDefinition($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/typeDefinitionManager.ts	/^  public dispose(): void {$/;"	m
DeclarationManager	nvim/plugged/coc.nvim/src/provider/declarationManager.ts	/^export default class DeclarationManager extends Manager<DeclarationProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/declarationManager.ts	/^  public register(selector: DocumentSelector, provider: DeclarationProvider): Disposable {$/;"	m
provideDeclaration	nvim/plugged/coc.nvim/src/provider/declarationManager.ts	/^  public async provideDeclaration($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/declarationManager.ts	/^  public dispose(): void {$/;"	m
DocumentLinkManager	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^export default class DocumentLinkManager extends Manager<DocumentLinkProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^  public register(selector: DocumentSelector, provider: DocumentLinkProvider): Disposable {$/;"	m
_provideDocumentLinks	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^  private async _provideDocumentLinks(item: ProviderItem<DocumentLinkProvider>, document: TextDocument, token: CancellationToken): Promise<DocumentLink[]> {$/;"	m
provideDocumentLinks	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^  public async provideDocumentLinks(document: TextDocument, token: CancellationToken): Promise<DocumentLink[]> {$/;"	m
resolveDocumentLink	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^  public async resolveDocumentLink(link: DocumentLink, token: CancellationToken): Promise<DocumentLink> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/documentLinkManager.ts	/^  public dispose(): void {$/;"	m
FormatRangeManager	nvim/plugged/coc.nvim/src/provider/formatRangeManager.ts	/^export default class FormatRangeManager extends Manager<DocumentRangeFormattingEditProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/formatRangeManager.ts	/^  public register(selector: DocumentSelector,$/;"	m
provideDocumentRangeFormattingEdits	nvim/plugged/coc.nvim/src/provider/formatRangeManager.ts	/^  public async provideDocumentRangeFormattingEdits($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/formatRangeManager.ts	/^  public dispose(): void {$/;"	m
CodeActionManager	nvim/plugged/coc.nvim/src/provider/codeActionmanager.ts	/^export default class CodeActionManager extends Manager<CodeActionProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/codeActionmanager.ts	/^  public register(selector: DocumentSelector, provider: CodeActionProvider, clientId: string, codeActionKinds?: CodeActionKind[]): Disposable {$/;"	m
provideCodeActions	nvim/plugged/coc.nvim/src/provider/codeActionmanager.ts	/^  public async provideCodeActions($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/codeActionmanager.ts	/^  public dispose(): void {$/;"	m
FoldingRangeManager	nvim/plugged/coc.nvim/src/provider/foldingRangeManager.ts	/^export default class FoldingRangeManager extends Manager<FoldingRangeProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/foldingRangeManager.ts	/^  public register(selector: DocumentSelector, provider: FoldingRangeProvider): Disposable {$/;"	m
provideFoldingRanges	nvim/plugged/coc.nvim/src/provider/foldingRangeManager.ts	/^  public async provideFoldingRanges(document: TextDocument, context: FoldingContext, token: CancellationToken): Promise<FoldingRange[] | null> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/foldingRangeManager.ts	/^  public dispose(): void {$/;"	m
ProviderItem	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^export interface ProviderItem {$/;"	i
OnTypeFormatManager	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^export default class OnTypeFormatManager implements Disposable {$/;"	c
providers	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  private providers: Set<ProviderItem> = new Set()$/;"	m
register	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  public register(selector: DocumentSelector, provider: OnTypeFormattingEditProvider, triggerCharacters: string[]): Disposable {$/;"	m
hasProvider	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  public hasProvider(document: TextDocument): boolean {$/;"	m
getProvider	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  public getProvider(document: TextDocument, triggerCharacter: string): OnTypeFormattingEditProvider | null {$/;"	m
onCharacterType	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  public async onCharacterType(character: string, document: TextDocument, position: Position, token: CancellationToken): Promise<TextEdit[] | null> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/onTypeFormatManager.ts	/^  public dispose(): void {$/;"	m
CodeLensManager	nvim/plugged/coc.nvim/src/provider/codeLensManager.ts	/^export default class CodeLensManager extends Manager<CodeLensProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/codeLensManager.ts	/^  public register(selector: DocumentSelector, provider: CodeLensProvider): Disposable {$/;"	m
provideCodeLenses	nvim/plugged/coc.nvim/src/provider/codeLensManager.ts	/^  public async provideCodeLenses($/;"	m
resolveCodeLens	nvim/plugged/coc.nvim/src/provider/codeLensManager.ts	/^  public async resolveCodeLens($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/codeLensManager.ts	/^  public dispose(): void {$/;"	m
DocumentSymbolManager	nvim/plugged/coc.nvim/src/provider/documentSymbolManager.ts	/^export default class DocumentSymbolManager extends Manager<DocumentSymbolProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/documentSymbolManager.ts	/^  public register(selector: DocumentSelector, provider: DocumentSymbolProvider): Disposable {$/;"	m
provideDocumentSymbols	nvim/plugged/coc.nvim/src/provider/documentSymbolManager.ts	/^  public async provideDocumentSymbols($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/documentSymbolManager.ts	/^  public dispose(): void {$/;"	m
RenameManager	nvim/plugged/coc.nvim/src/provider/renameManager.ts	/^export default class RenameManager extends Manager<RenameProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/renameManager.ts	/^  public register(selector: DocumentSelector, provider: RenameProvider): Disposable {$/;"	m
provideRenameEdits	nvim/plugged/coc.nvim/src/provider/renameManager.ts	/^  public async provideRenameEdits($/;"	m
prepareRename	nvim/plugged/coc.nvim/src/provider/renameManager.ts	/^  public async prepareRename($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/renameManager.ts	/^  public dispose(): void {$/;"	m
HoverManager	nvim/plugged/coc.nvim/src/provider/hoverManager.ts	/^export default class HoverManager extends Manager<HoverProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/hoverManager.ts	/^  public register(selector: DocumentSelector, provider: HoverProvider): Disposable {$/;"	m
provideHover	nvim/plugged/coc.nvim/src/provider/hoverManager.ts	/^  public async provideHover($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/hoverManager.ts	/^  public dispose(): void {$/;"	m
ReferenceManager	nvim/plugged/coc.nvim/src/provider/referenceManager.ts	/^export default class ReferenceManager extends Manager<ReferenceProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/referenceManager.ts	/^  public register(selector: DocumentSelector, provider: ReferenceProvider): Disposable {$/;"	m
provideReferences	nvim/plugged/coc.nvim/src/provider/referenceManager.ts	/^  public async provideReferences($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/referenceManager.ts	/^  public dispose(): void {$/;"	m
SelectionRangeManager	nvim/plugged/coc.nvim/src/provider/rangeManager.ts	/^export default class SelectionRangeManager extends Manager<SelectionRangeProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/rangeManager.ts	/^  public register(selector: DocumentSelector, provider: SelectionRangeProvider): Disposable {$/;"	m
provideSelectionRanges	nvim/plugged/coc.nvim/src/provider/rangeManager.ts	/^  public async provideSelectionRanges($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/rangeManager.ts	/^  public dispose(): void {$/;"	m
ProviderResult	nvim/plugged/coc.nvim/src/provider/index.ts	/^export type ProviderResult<T> =$/;"	t
CompletionItemProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface CompletionItemProvider {$/;"	i
HoverProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface HoverProvider {$/;"	i
DefinitionProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DefinitionProvider {$/;"	i
DeclarationProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DeclarationProvider {$/;"	i
SignatureHelpProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface SignatureHelpProvider {$/;"	i
TypeDefinitionProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface TypeDefinitionProvider {$/;"	i
ReferenceContext	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface ReferenceContext {$/;"	i
ReferenceProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface ReferenceProvider {$/;"	i
FoldingContext	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface FoldingContext { }$/;"	i
FoldingRangeProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface FoldingRangeProvider {$/;"	i
DocumentSymbolProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentSymbolProvider {$/;"	i
ImplementationProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface ImplementationProvider {$/;"	i
WorkspaceSymbolProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface WorkspaceSymbolProvider {$/;"	i
RenameProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface RenameProvider {$/;"	i
DocumentFormattingEditProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentFormattingEditProvider {$/;"	i
DocumentRangeFormattingEditProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentRangeFormattingEditProvider {$/;"	i
CodeActionProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface CodeActionProvider {$/;"	i
CodeActionProviderMetadata	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface CodeActionProviderMetadata {$/;"	i
DocumentHighlightProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentHighlightProvider {$/;"	i
DocumentLinkProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentLinkProvider {$/;"	i
CodeLensProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface CodeLensProvider {$/;"	i
OnTypeFormattingEditProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface OnTypeFormattingEditProvider {$/;"	i
DocumentColorProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface DocumentColorProvider {$/;"	i
TextDocumentContentProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface TextDocumentContentProvider {$/;"	i
SelectionRangeProvider	nvim/plugged/coc.nvim/src/provider/index.ts	/^export interface SelectionRangeProvider {$/;"	i
DocumentHighlightManager	nvim/plugged/coc.nvim/src/provider/documentHighlightManager.ts	/^export default class DocumentHighlightManager extends Manager<DocumentHighlightProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/documentHighlightManager.ts	/^  public register(selector: DocumentSelector, provider: DocumentHighlightProvider): Disposable {$/;"	m
provideDocumentHighlights	nvim/plugged/coc.nvim/src/provider/documentHighlightManager.ts	/^  public async provideDocumentHighlights($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/documentHighlightManager.ts	/^  public dispose(): void {$/;"	m
ImplementationManager	nvim/plugged/coc.nvim/src/provider/implementationManager.ts	/^export default class ImplementationManager extends Manager<ImplementationProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/implementationManager.ts	/^  public register(selector: DocumentSelector, provider: ImplementationProvider): Disposable {$/;"	m
provideReferences	nvim/plugged/coc.nvim/src/provider/implementationManager.ts	/^  public async provideReferences($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/implementationManager.ts	/^  public dispose(): void {$/;"	m
DefinitionManager	nvim/plugged/coc.nvim/src/provider/definitionManager.ts	/^export default class DefinitionManager extends Manager<DefinitionProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/definitionManager.ts	/^  public register(selector: DocumentSelector, provider: DefinitionProvider): Disposable {$/;"	m
provideDefinition	nvim/plugged/coc.nvim/src/provider/definitionManager.ts	/^  public async provideDefinition($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/definitionManager.ts	/^  public dispose(): void {$/;"	m
SignatureManager	nvim/plugged/coc.nvim/src/provider/signatureManager.ts	/^export default class SignatureManager extends Manager<SignatureHelpProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/signatureManager.ts	/^  public register(selector: DocumentSelector, provider: SignatureHelpProvider, triggerCharacters?: string[]): Disposable {$/;"	m
shouldTrigger	nvim/plugged/coc.nvim/src/provider/signatureManager.ts	/^  public shouldTrigger(document: TextDocument, triggerCharacter: string): boolean {$/;"	m
provideSignatureHelp	nvim/plugged/coc.nvim/src/provider/signatureManager.ts	/^  public async provideSignatureHelp($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/signatureManager.ts	/^  public dispose(): void {$/;"	m
WorkspaceSymbolManager	nvim/plugged/coc.nvim/src/provider/workspaceSymbolsManager.ts	/^export default class WorkspaceSymbolManager extends Manager<WorkspaceSymbolProvider> implements Disposable {$/;"	c
register	nvim/plugged/coc.nvim/src/provider/workspaceSymbolsManager.ts	/^  public register(selector: DocumentSelector, provider: WorkspaceSymbolProvider): Disposable {$/;"	m
provideWorkspaceSymbols	nvim/plugged/coc.nvim/src/provider/workspaceSymbolsManager.ts	/^  public async provideWorkspaceSymbols($/;"	m
resolveWorkspaceSymbol	nvim/plugged/coc.nvim/src/provider/workspaceSymbolsManager.ts	/^  public async resolveWorkspaceSymbol($/;"	m
dispose	nvim/plugged/coc.nvim/src/provider/workspaceSymbolsManager.ts	/^  public dispose(): void {$/;"	m
MsgTypes	nvim/plugged/coc.nvim/src/types.ts	/^export type MsgTypes = 'error' | 'warning' | 'more'$/;"	t
ExtensionState	nvim/plugged/coc.nvim/src/types.ts	/^export type ExtensionState = 'disabled' | 'loaded' | 'activated' | 'unknown'$/;"	t
CodeAction	nvim/plugged/coc.nvim/src/types.ts	/^export interface CodeAction extends protocol.CodeAction {$/;"	i
DidChangeTextDocumentParams	nvim/plugged/coc.nvim/src/types.ts	/^export interface DidChangeTextDocumentParams extends protocol.DidChangeTextDocumentParams {$/;"	i
TaskOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface TaskOptions {$/;"	i
Documentation	nvim/plugged/coc.nvim/src/types.ts	/^export interface Documentation {$/;"	i
KeymapOption	nvim/plugged/coc.nvim/src/types.ts	/^export interface KeymapOption {$/;"	i
Autocmd	nvim/plugged/coc.nvim/src/types.ts	/^export interface Autocmd {$/;"	i
ExtensionInfo	nvim/plugged/coc.nvim/src/types.ts	/^export interface ExtensionInfo {$/;"	i
ErrorItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface ErrorItem {$/;"	i
StatusItemOption	nvim/plugged/coc.nvim/src/types.ts	/^export interface StatusItemOption {$/;"	i
StatusBarItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface StatusBarItem {$/;"	i
TerminalOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface TerminalOptions {$/;"	i
Memento	nvim/plugged/coc.nvim/src/types.ts	/^export interface Memento {$/;"	i
Terminal	nvim/plugged/coc.nvim/src/types.ts	/^export interface Terminal {$/;"	i
Env	nvim/plugged/coc.nvim/src/types.ts	/^export interface Env {$/;"	i
Fragment	nvim/plugged/coc.nvim/src/types.ts	/^export interface Fragment {$/;"	i
EditerState	nvim/plugged/coc.nvim/src/types.ts	/^export interface EditerState {$/;"	i
Snippet	nvim/plugged/coc.nvim/src/types.ts	/^export interface Snippet {$/;"	i
SnippetProvider	nvim/plugged/coc.nvim/src/types.ts	/^export interface SnippetProvider {$/;"	i
SnippetManager	nvim/plugged/coc.nvim/src/types.ts	/^export interface SnippetManager {$/;"	i
ModuleResolve	nvim/plugged/coc.nvim/src/types.ts	/^export type ModuleResolve = () => Promise<string>$/;"	t
MapMode	nvim/plugged/coc.nvim/src/types.ts	/^export type MapMode = 'n' | 'i' | 'v' | 'x' | 's' | 'o'$/;"	t
PatternType	nvim/plugged/coc.nvim/src/types.ts	/^export enum PatternType {$/;"	e
SourceType	nvim/plugged/coc.nvim/src/types.ts	/^export enum SourceType {$/;"	e
MessageLevel	nvim/plugged/coc.nvim/src/types.ts	/^export enum MessageLevel {$/;"	e
ChangeInfo	nvim/plugged/coc.nvim/src/types.ts	/^export interface ChangeInfo {$/;"	i
ConfigurationChangeEvent	nvim/plugged/coc.nvim/src/types.ts	/^export interface ConfigurationChangeEvent {$/;"	i
LanguageServerConfig	nvim/plugged/coc.nvim/src/types.ts	/^export interface LanguageServerConfig {$/;"	i
LocationListItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface LocationListItem {$/;"	i
QuickfixItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface QuickfixItem {$/;"	i
ChangedLines	nvim/plugged/coc.nvim/src/types.ts	/^export interface ChangedLines {$/;"	i
ChangeItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface ChangeItem {$/;"	i
BufferOption	nvim/plugged/coc.nvim/src/types.ts	/^export interface BufferOption {$/;"	i
DiagnosticInfo	nvim/plugged/coc.nvim/src/types.ts	/^export interface DiagnosticInfo {$/;"	i
DiagnosticItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface DiagnosticItem {$/;"	i
RecentScore	nvim/plugged/coc.nvim/src/types.ts	/^export interface RecentScore {$/;"	i
CompletionContext	nvim/plugged/coc.nvim/src/types.ts	/^export interface CompletionContext {$/;"	i
CompleteOption	nvim/plugged/coc.nvim/src/types.ts	/^export interface CompleteOption {$/;"	i
PumBounding	nvim/plugged/coc.nvim/src/types.ts	/^export interface PumBounding {$/;"	i
VimCompleteItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface VimCompleteItem {$/;"	i
PopupProps	nvim/plugged/coc.nvim/src/types.ts	/^export interface PopupProps {$/;"	i
TextItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface TextItem {$/;"	i
PopupOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface PopupOptions {$/;"	i
PopupChangeEvent	nvim/plugged/coc.nvim/src/types.ts	/^export interface PopupChangeEvent {$/;"	i
CompleteResult	nvim/plugged/coc.nvim/src/types.ts	/^export interface CompleteResult {$/;"	i
SourceStat	nvim/plugged/coc.nvim/src/types.ts	/^export interface SourceStat {$/;"	i
CompleteConfig	nvim/plugged/coc.nvim/src/types.ts	/^export interface CompleteConfig {$/;"	i
WorkspaceConfiguration	nvim/plugged/coc.nvim/src/types.ts	/^export interface WorkspaceConfiguration {$/;"	i
ConfigurationInspect	nvim/plugged/coc.nvim/src/types.ts	/^export interface ConfigurationInspect<T> {$/;"	i
RenameEvent	nvim/plugged/coc.nvim/src/types.ts	/^export interface RenameEvent {$/;"	i
TerminalResult	nvim/plugged/coc.nvim/src/types.ts	/^export interface TerminalResult {$/;"	i
ConfigurationShape	nvim/plugged/coc.nvim/src/types.ts	/^export interface ConfigurationShape {$/;"	i
IConfigurationModel	nvim/plugged/coc.nvim/src/types.ts	/^export interface IConfigurationModel {$/;"	i
IOverrides	nvim/plugged/coc.nvim/src/types.ts	/^export interface IOverrides {$/;"	i
IConfigurationData	nvim/plugged/coc.nvim/src/types.ts	/^export interface IConfigurationData {$/;"	i
ConfigurationTarget	nvim/plugged/coc.nvim/src/types.ts	/^export enum ConfigurationTarget {$/;"	e
DiagnosticKind	nvim/plugged/coc.nvim/src/types.ts	/^export enum DiagnosticKind {$/;"	e
ServiceStat	nvim/plugged/coc.nvim/src/types.ts	/^export enum ServiceStat {$/;"	e
IServiceProvider	nvim/plugged/coc.nvim/src/types.ts	/^export interface IServiceProvider {$/;"	i
LocationWithLine	nvim/plugged/coc.nvim/src/types.ts	/^export interface LocationWithLine {$/;"	i
ListItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListItem {$/;"	i
ListHighlights	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListHighlights {$/;"	i
AnsiHighlight	nvim/plugged/coc.nvim/src/types.ts	/^export interface AnsiHighlight {$/;"	i
ListItemsEvent	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListItemsEvent {$/;"	i
ListMode	nvim/plugged/coc.nvim/src/types.ts	/^export type ListMode = 'normal' | 'insert'$/;"	t
Matcher	nvim/plugged/coc.nvim/src/types.ts	/^export type Matcher = 'strict' | 'fuzzy' | 'regex'$/;"	t
ListOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListOptions {$/;"	i
ListContext	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListContext {$/;"	i
ListAction	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListAction {$/;"	i
ListTask	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListTask {$/;"	i
ListArgument	nvim/plugged/coc.nvim/src/types.ts	/^export interface ListArgument {$/;"	i
IList	nvim/plugged/coc.nvim/src/types.ts	/^export interface IList {$/;"	i
PreiewOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface PreiewOptions {$/;"	i
DownloadOptions	nvim/plugged/coc.nvim/src/types.ts	/^export interface DownloadOptions extends RequestOptions {$/;"	i
AnsiItem	nvim/plugged/coc.nvim/src/types.ts	/^export interface AnsiItem {$/;"	i
ISource	nvim/plugged/coc.nvim/src/types.ts	/^export interface ISource {$/;"	i
SourceConfig	nvim/plugged/coc.nvim/src/types.ts	/^export interface SourceConfig extends ISource {$/;"	i
DiagnosticCollection	nvim/plugged/coc.nvim/src/types.ts	/^export interface DiagnosticCollection {$/;"	i
TextDocumentWillSaveEvent	nvim/plugged/coc.nvim/src/types.ts	/^export interface TextDocumentWillSaveEvent {$/;"	i
Thenable	nvim/plugged/coc.nvim/src/types.ts	/^export interface Thenable<T> {$/;"	i
OutputChannel	nvim/plugged/coc.nvim/src/types.ts	/^export interface OutputChannel {$/;"	i
Extension	nvim/plugged/coc.nvim/src/types.ts	/^export interface Extension<T> {$/;"	i
ExtensionContext	nvim/plugged/coc.nvim/src/types.ts	/^export interface ExtensionContext {$/;"	i
IWorkspace	nvim/plugged/coc.nvim/src/types.ts	/^export interface IWorkspace {$/;"	i
getContext	nvim/plugged/coc.nvim/src/__tests__/extensions/test/index.js	/^    getContext: () => {$/;"	M
getContext	nvim/plugged/coc.nvim/src/__tests__/extensions/global/index.js	/^    getContext: () => {$/;"	M
getContext	nvim/plugged/coc.nvim/src/__tests__/extensions/local/index.js	/^    getContext: () => {$/;"	M
assertText	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertText(value: string, expected: string) {$/;"	f
assertText	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertText(value: string, expected: string) {$/;"	f
assertText	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertText(value: string, expected: string) {$/;"	f
assertMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertMarker(input: TextmateSnippet | Marker[] | string, ...ctors: Function[]) {$/;"	f
assertMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertMarker(input: TextmateSnippet | Marker[] | string, ...ctors: Function[]) {$/;"	f
assertMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertMarker(input: TextmateSnippet | Marker[] | string, ...ctors: Function[]) {$/;"	f
assertTextAndMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertTextAndMarker(value: string, escaped: string, ...ctors: Function[]) {$/;"	f
assertTextAndMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertTextAndMarker(value: string, escaped: string, ...ctors: Function[]) {$/;"	f
assertTextAndMarker	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertTextAndMarker(value: string, escaped: string, ...ctors: Function[]) {$/;"	f
assertEscaped	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertEscaped(value: string, expected: string) {$/;"	f
assertEscaped	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertEscaped(value: string, expected: string) {$/;"	f
assertEscaped	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^  function assertEscaped(value: string, expected: string) {$/;"	f
assertTextsnippetString	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertTextsnippetString(input: string, expected: string): void {$/;"	f
assertTextsnippetString	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertTextsnippetString(input: string, expected: string): void {$/;"	f
assertTextsnippetString	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertTextsnippetString(input: string, expected: string): void {$/;"	f
assertIdent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertIdent(input: string): void {$/;"	f
assertIdent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertIdent(input: string): void {$/;"	f
assertIdent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertIdent(input: string): void {$/;"	f
checkCheckChildren	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^      function checkCheckChildren(marker1: Marker, marker2: Marker) {$/;"	f
checkCheckChildren	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^      function checkCheckChildren(marker1: Marker, marker2: Marker) {$/;"	f
checkCheckChildren	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^      function checkCheckChildren(marker1: Marker, marker2: Marker) {$/;"	f
assertLen	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertLen(template: string, ...lengths: number[]): void {$/;"	f
assertLen	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertLen(template: string, ...lengths: number[]): void {$/;"	f
assertLen	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertLen(template: string, ...lengths: number[]): void {$/;"	f
assertParent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertParent(marker: Marker) {$/;"	f
assertParent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertParent(marker: Marker) {$/;"	f
assertParent	nvim/plugged/coc.nvim/src/__tests__/snippets/parser.test.ts	/^    function assertParent(marker: Marker) {$/;"	f
score	nvim/plugged/coc.nvim/src/__tests__/completion/match.test.ts	/^function score(word: string, input: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/__tests__/completion/match.test.ts	/^function score(word: string, input: string): number {$/;"	f
score	nvim/plugged/coc.nvim/src/__tests__/completion/match.test.ts	/^function score(word: string, input: string): number {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticCollection.test.ts	/^function createDiagnostic(msg: string, range?: Range): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticCollection.test.ts	/^function createDiagnostic(msg: string, range?: Range): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticCollection.test.ts	/^function createDiagnostic(msg: string, range?: Range): Diagnostic {$/;"	f
compare	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function compare(a: string): string {$/;"	f
compare	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function compare(a: string): string {$/;"	f
compare	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function compare(a: string): string {$/;"	f
values	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function values(item: { [key: string]: number[] }): number[] {$/;"	f
values	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function values(item: { [key: string]: number[] }): number[] {$/;"	f
values	nvim/plugged/coc.nvim/src/__tests__/modules/array.test.ts	/^    function values(item: { [key: string]: number[] }): number[] {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/attach.test.ts	/^function wait(ms: number): Promise<void> {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/attach.test.ts	/^function wait(ms: number): Promise<void> {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/attach.test.ts	/^function wait(ms: number): Promise<void> {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticManager.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticManager.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticManager.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
createDocument	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticManager.test.ts	/^async function createDocument(): Promise<Document> {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/__tests__/modules/extensions.test.ts	/^  function createExtension(event: string): Extension<API> {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/__tests__/modules/extensions.test.ts	/^  function createExtension(event: string): Extension<API> {$/;"	f
createExtension	nvim/plugged/coc.nvim/src/__tests__/modules/extensions.test.ts	/^  function createExtension(event: string): Extension<API> {$/;"	f
createDiagnosticBuffer	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticBuffer.test.ts	/^async function createDiagnosticBuffer(): Promise<DiagnosticBuffer> {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticBuffer.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticBuffer.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
createDiagnostic	nvim/plugged/coc.nvim/src/__tests__/modules/diagnosticBuffer.test.ts	/^function createDiagnostic(msg: string, range?: Range, severity?: DiagnosticSeverity): Diagnostic {$/;"	f
addPosition	nvim/plugged/coc.nvim/src/__tests__/modules/position.test.ts	/^function addPosition(position: Position, line: number, character: number): Position {$/;"	f
addPosition	nvim/plugged/coc.nvim/src/__tests__/modules/position.test.ts	/^function addPosition(position: Position, line: number, character: number): Position {$/;"	f
addPosition	nvim/plugged/coc.nvim/src/__tests__/modules/position.test.ts	/^function addPosition(position: Position, line: number, character: number): Position {$/;"	f
getColor	nvim/plugged/coc.nvim/src/__tests__/modules/colors.test.ts	/^function getColor(r: number, g: number, b: number): Color {$/;"	f
getColor	nvim/plugged/coc.nvim/src/__tests__/modules/colors.test.ts	/^function getColor(r: number, g: number, b: number): Color {$/;"	f
getColor	nvim/plugged/coc.nvim/src/__tests__/modules/colors.test.ts	/^function getColor(r: number, g: number, b: number): Color {$/;"	f
getConfigurationModel	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function getConfigurationModel(): IConfigurationModel {$/;"	f
getConfigurationModel	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function getConfigurationModel(): IConfigurationModel {$/;"	f
getConfigurationModel	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function getConfigurationModel(): IConfigurationModel {$/;"	f
createConfigurations	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function createConfigurations(): Configurations {$/;"	f
createConfigurations	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function createConfigurations(): Configurations {$/;"	f
createConfigurations	nvim/plugged/coc.nvim/src/__tests__/modules/configurations.test.ts	/^function createConfigurations(): Configurations {$/;"	f
create	nvim/plugged/coc.nvim/src/__tests__/modules/floatBuffer.test.ts	/^async function create(): Promise<FloatBuffer> {$/;"	f
applyEdits	nvim/plugged/coc.nvim/src/__tests__/modules/diff.test.ts	/^  function applyEdits(oldStr: string, newStr: string): void {$/;"	f
applyEdits	nvim/plugged/coc.nvim/src/__tests__/modules/diff.test.ts	/^  function applyEdits(oldStr: string, newStr: string): void {$/;"	f
applyEdits	nvim/plugged/coc.nvim/src/__tests__/modules/diff.test.ts	/^  function applyEdits(oldStr: string, newStr: string): void {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function wait(ms: number): Promise<any> {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function wait(ms: number): Promise<any> {$/;"	f
wait	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function wait(ms: number): Promise<any> {$/;"	f
sendResponse	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendResponse(data: any): void {$/;"	f
sendResponse	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendResponse(data: any): void {$/;"	f
sendResponse	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendResponse(data: any): void {$/;"	f
createFileChange	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function createFileChange(file: string, exists = true): FileChangeItem {$/;"	f
createFileChange	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function createFileChange(file: string, exists = true): FileChangeItem {$/;"	f
createFileChange	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function createFileChange(file: string, exists = true): FileChangeItem {$/;"	f
sendSubscription	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendSubscription(uid: string, root: string, files: FileChangeItem[]): void {$/;"	f
sendSubscription	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendSubscription(uid: string, root: string, files: FileChangeItem[]): void {$/;"	f
sendSubscription	nvim/plugged/coc.nvim/src/__tests__/modules/watchman.test.ts	/^function sendSubscription(uid: string, root: string, files: FileChangeItem[]): void {$/;"	f
rangeCount	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^function rangeCount(): number {$/;"	f
rangeCount	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^function rangeCount(): number {$/;"	f
rangeCount	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^function rangeCount(): number {$/;"	f
setup	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^  async function setup(): Promise<Document> {$/;"	f
setup	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^  async function setup(): Promise<void> {$/;"	f
hasKeymap	nvim/plugged/coc.nvim/src/__tests__/modules/cursors.test.ts	/^  async function hasKeymap(key): Promise<boolean> {$/;"	f
coc#source#email#init	nvim/plugged/coc.nvim/src/__tests__/autoload/coc/source/email.vim	/^function! coc#source#email#init() abort$/;"	f
coc#source#email#should_complete	nvim/plugged/coc.nvim/src/__tests__/autoload/coc/source/email.vim	/^function! coc#source#email#should_complete(opt) abort$/;"	f
coc#source#email#complete	nvim/plugged/coc.nvim/src/__tests__/autoload/coc/source/email.vim	/^function! coc#source#email#complete(opt, cb) abort$/;"	f
CursorPosition	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^export interface CursorPosition {$/;"	i
Helper	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^export class Helper extends Emitter {$/;"	c
nvim	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public nvim: Neovim$/;"	m
proc	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public proc: cp.ChildProcess$/;"	m
plugin	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public plugin: Plugin$/;"	m
setup	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public setup(): Promise<void> {$/;"	m
shutdown	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async shutdown(): Promise<void> {$/;"	m
waitPopup	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async waitPopup(): Promise<void> {$/;"	m
waitFloat	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async waitFloat(): Promise<number> {$/;"	m
selectCompleteItem	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async selectCompleteItem(idx: number): Promise<void> {$/;"	m
reset	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async reset(): Promise<void> {$/;"	m
pumvisible	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async pumvisible(): Promise<boolean> {$/;"	m
wait	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public wait(ms = 30): Promise<void> {$/;"	m
visible	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async visible(word: string, source?: string): Promise<boolean> {$/;"	m
notVisible	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async notVisible(word: string): Promise<boolean> {$/;"	m
getItems	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async getItems(): Promise<VimCompleteItem[]> {$/;"	m
edit	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async edit(file?: string): Promise<Buffer> {$/;"	m
createDocument	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async createDocument(name?: string): Promise<Document> {$/;"	m
getCmdline	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async getCmdline(): Promise<string> {$/;"	m
updateConfiguration	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public updateConfiguration(key: string, value: any): void {$/;"	m
mockFunction	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async mockFunction(name: string, result: string | number | any): Promise<void> {$/;"	m
items	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async items(): Promise<VimCompleteItem[]> {$/;"	m
screenLine	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async screenLine(line: number): Promise<string> {$/;"	m
getFloat	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^  public async getFloat(): Promise<Window> {$/;"	m
createTmpFile	nvim/plugged/coc.nvim/src/__tests__/helper.ts	/^export async function createTmpFile(content: string): Promise<string> {$/;"	f
TaskList	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^class TaskList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public name = 'task'$/;"	m
timeout	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public timeout = 3000$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public loadItems(_context: ListContext, token: CancellationToken): Promise<ListTask> {$/;"	m
InteractiveList	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^class InteractiveList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public name = 'test'$/;"	m
interactive	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public interactive = true$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public loadItems(context: ListContext, _token: CancellationToken): Promise<ListItem[]> {$/;"	m
ErrorList	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^class ErrorList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public name = 'error'$/;"	m
interactive	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public interactive = true$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public loadItems(_context: ListContext, _token: CancellationToken): Promise<ListItem[]> {$/;"	m
ErrorTaskList	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^class ErrorTaskList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public name = 'task'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/worker.test.ts	/^  public loadItems(_context: ListContext, _token: CancellationToken): Promise<ListTask> {$/;"	m
setMouseEvent	nvim/plugged/coc.nvim/src/__tests__/list/manager.test.ts	/^    async function setMouseEvent(line: number): Promise<void> {$/;"	f
OptionList	nvim/plugged/coc.nvim/src/__tests__/list/sources.test.ts	/^class OptionList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/sources.test.ts	/^  public name = 'option'$/;"	m
options	nvim/plugged/coc.nvim/src/__tests__/list/sources.test.ts	/^  public options: ListArgument[] = [{$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/sources.test.ts	/^  public loadItems(_context: ListContext, _token: CancellationToken): Promise<ListItem[]> {$/;"	m
TestList	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^class TestList extends BasicList {$/;"	c
name	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^  public name = 'test'$/;"	m
timeout	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^  public timeout = 3000$/;"	m
text	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^  public text = 'test'$/;"	m
detail	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^  public detail = 'detail'$/;"	m
loadItems	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^  public loadItems(_context: ListContext, token: CancellationToken): Promise<ListItem[]> {$/;"	m
session	nvim/plugged/coc.nvim/src/__tests__/list/mappings.test.ts	/^    async function session(input: string): Promise<void> {$/;"	f
documents	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^let documents = new vscode_languageserver_1.TextDocuments();$/;"	V
capabilities	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^  let capabilities = {$/;"	O
completionProvider	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^    completionProvider: { resolveProvider: true, triggerCharacters: ['"', ':'] },$/;"	P
hoverProvider	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^    hoverProvider: true,$/;"	P
renameProvider	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^    renameProvider: {$/;"	P
prepareProvider	nvim/plugged/coc.nvim/src/__tests__/client/server/testInitializeResult.js	/^      prepareProvider: true$/;"	P
documents	nvim/plugged/coc.nvim/src/__tests__/client/server/testFileWatcher.js	/^let documents = new languageserver.TextDocuments()$/;"	V
capabilities	nvim/plugged/coc.nvim/src/__tests__/client/server/testFileWatcher.js	/^  let capabilities = {$/;"	O
registrations	nvim/plugged/coc.nvim/src/__tests__/client/server/testFileWatcher.js	/^    registrations: [{$/;"	P
registerOptions	nvim/plugged/coc.nvim/src/__tests__/client/server/testFileWatcher.js	/^      registerOptions: {$/;"	P
watchers	nvim/plugged/coc.nvim/src/__tests__/client/server/testFileWatcher.js	/^        watchers: [{ globPattern: "**" }]$/;"	P
createDocument	nvim/plugged/coc.nvim/src/__tests__/client/converter.test.ts	/^  function createDocument(): TextDocument {$/;"	f
createDocument	nvim/plugged/coc.nvim/src/__tests__/client/converter.test.ts	/^  function createDocument(): TextDocument {$/;"	f
createDocument	nvim/plugged/coc.nvim/src/__tests__/client/converter.test.ts	/^  function createDocument(): TextDocument {$/;"	f
testLanguageServer	nvim/plugged/coc.nvim/src/__tests__/client/integration.test.ts	/^async function testLanguageServer(serverOptions: lsclient.ServerOptions): Promise<void> {$/;"	f
CodeLensInfo	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^export interface CodeLensInfo {$/;"	i
CodeLensManager	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^export default class CodeLensManager {$/;"	c
separator	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private separator: string$/;"	m
srcId	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private srcId: number$/;"	m
enabled	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private enabled: boolean$/;"	m
fetching	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private fetching: Set<number> = new Set()$/;"	m
disposables	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private disposables: Disposable[] = []$/;"	m
codeLensMap	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private codeLensMap: Map<number, CodeLensInfo> = new Map()$/;"	m
resolveCodeLens	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private resolveCodeLens: Function & { clear(): void }$/;"	m
init	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private async init(): Promise<void> {$/;"	m
setConfiguration	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private setConfiguration(): void {$/;"	m
fetchDocumentCodeLenes	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private async fetchDocumentCodeLenes(retry = 0): Promise<void> {$/;"	m
setVirtualText	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private async setVirtualText(buffer: Buffer, codeLenes: CodeLens[]): Promise<void> {$/;"	m
_resolveCodeLenes	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private async _resolveCodeLenes(clear = false): Promise<void> {$/;"	m
doAction	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  public async doAction(): Promise<void> {$/;"	m
validDocument	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private validDocument(doc: Document): boolean {$/;"	m
version	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  private get version(): number {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/codelens.ts	/^  public dispose(): void {$/;"	m
Task	nvim/plugged/coc.nvim/src/handler/search.ts	/^class Task extends EventEmitter {$/;"	c
process	nvim/plugged/coc.nvim/src/handler/search.ts	/^  private process: ChildProcess$/;"	m
start	nvim/plugged/coc.nvim/src/handler/search.ts	/^  public start(cmd: string, args: string[], cwd: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/search.ts	/^  public dispose(): void {$/;"	m
Search	nvim/plugged/coc.nvim/src/handler/search.ts	/^export default class Search {$/;"	c
task	nvim/plugged/coc.nvim/src/handler/search.ts	/^  private task: Task$/;"	m
run	nvim/plugged/coc.nvim/src/handler/search.ts	/^  public run(args: string[], cwd: string, refactor: Refactor): Promise<void> {$/;"	m
LineChange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export interface LineChange {$/;"	i
FileRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export interface FileRange {$/;"	i
FileChange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export interface FileChange {$/;"	i
FileItem	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export interface FileItem {$/;"	i
RefactorConfig	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export interface RefactorConfig {$/;"	i
Refactor	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^export default class Refactor {$/;"	c
nvim	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private nvim: Neovim$/;"	m
cwd	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private cwd: string$/;"	m
bufnr	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private bufnr: number$/;"	m
winid	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private winid: number$/;"	m
srcId	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private srcId: number$/;"	m
version	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private version: number$/;"	m
fromWinid	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private fromWinid: number$/;"	m
changing	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private changing = false$/;"	m
matchIds	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private matchIds: Set<number> = new Set()$/;"	m
disposables	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private disposables: Disposable[] = []$/;"	m
fileItems	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private fileItems: FileItem[] = []$/;"	m
config	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public readonly config: RefactorConfig$/;"	m
buffer	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public get buffer(): Buffer {$/;"	m
document	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public get document(): Document | null {$/;"	m
valid	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async valid(): Promise<boolean> {$/;"	m
fromWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async fromWorkspaceEdit(edit: WorkspaceEdit, filetype?: string): Promise<void> {$/;"	m
fromLines	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async fromLines(lines: string[]): Promise<void> {$/;"	m
createRefactorBuffer	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async createRefactorBuffer(filetype?: string): Promise<Buffer> {$/;"	m
addFileItems	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async addFileItems(items: FileItem[]): Promise<void> {$/;"	m
ensureDocument	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async ensureDocument(): Promise<void> {$/;"	m
highlightLineNr	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private highlightLineNr(): void {$/;"	m
getFileChanges	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async getFileChanges(): Promise<FileChange[]> {$/;"	m
saveRefactor	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async saveRefactor(): Promise<boolean> {$/;"	m
getFileRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public getFileRange(lnum: number): FileRange {$/;"	m
onBufferChange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async onBufferChange(e: DidChangeTextDocumentParams): Promise<void> {$/;"	m
getFileRangeRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private getFileRangeRange(range: FileRange, lineOnly = true): Range {$/;"	m
splitOpen	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public async splitOpen(): Promise<void> {$/;"	m
onRefactorChange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async onRefactorChange(e: DidChangeTextDocumentParams): Promise<void> {$/;"	m
getItemsFromWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async getItemsFromWorkspaceEdit(edit: WorkspaceEdit): Promise<FileItem[]> {$/;"	m
getLineCount	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async getLineCount(uri: string): Promise<number> {$/;"	m
getLines	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private async getLines(fsPath: string, start: number, end: number): Promise<string[]> {$/;"	m
getLinesRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  private getLinesRange(lnum: number): [number, number] | null {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public dispose(): void {$/;"	m
createFromWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public static async createFromWorkspaceEdit(edit: WorkspaceEdit, filetype?: string): Promise<Refactor> {$/;"	m
createFromLocations	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public static async createFromLocations(locations: Location[], filetype?: string): Promise<Refactor> {$/;"	m
createFromLines	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^  public static async createFromLines(lines: string[]): Promise<Refactor> {$/;"	m
adjustRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function adjustRange(range: Range, offset: number): Range {$/;"	f
adjustRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function adjustRange(range: Range, offset: number): Range {$/;"	f
adjustRange	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function adjustRange(range: Range, offset: number): Range {$/;"	f
emptyWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function emptyWorkspaceEdit(edit: WorkspaceEdit): boolean {$/;"	f
emptyWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function emptyWorkspaceEdit(edit: WorkspaceEdit): boolean {$/;"	f
emptyWorkspaceEdit	nvim/plugged/coc.nvim/src/handler/refactor.ts	/^function emptyWorkspaceEdit(edit: WorkspaceEdit): boolean {$/;"	f
ColorRanges	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^export interface ColorRanges {$/;"	i
Highlighter	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^export default class Highlighter implements Disposable {$/;"	c
matchIds	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private matchIds: Set<number> = new Set()$/;"	m
_colors	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private _colors: ColorInformation[] = []$/;"	m
_version	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private _version: number$/;"	m
version	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public get version(): number {$/;"	m
bufnr	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public get bufnr(): number {$/;"	m
colors	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public get colors(): ColorInformation[] {$/;"	m
hasColor	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public hasColor(): boolean {$/;"	m
highlight	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public async highlight(colors: ColorInformation[]): Promise<void> {$/;"	m
addHighlight	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private addHighlight(ranges: Range[], color: Color): void {$/;"	m
addColors	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private addColors(colors: Color[]): void {$/;"	m
clearHighlight	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public clearHighlight(): void {$/;"	m
getColorRanges	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  private getColorRanges(infos: ColorInformation[]): ColorRanges[] {$/;"	m
hasColorAtPostion	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public hasColorAtPostion(position: Position): boolean {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^  public dispose(): void {$/;"	m
toHexString	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^export function toHexString(color: Color): string {$/;"	f
toHexString	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^export function toHexString(color: Color): string {$/;"	f
toHexString	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^export function toHexString(color: Color): string {$/;"	f
pad	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function pad(str: string): string {$/;"	f
pad	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function pad(str: string): string {$/;"	f
pad	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function pad(str: string): string {$/;"	f
toHexColor	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function toHexColor(color: Color): { red: number, green: number, blue: number } {$/;"	f
toHexColor	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function toHexColor(color: Color): { red: number, green: number, blue: number } {$/;"	f
toHexColor	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function toHexColor(color: Color): { red: number, green: number, blue: number } {$/;"	f
isDark	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function isDark(color: Color): boolean {$/;"	f
isDark	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function isDark(color: Color): boolean {$/;"	f
isDark	nvim/plugged/coc.nvim/src/handler/highlighter.ts	/^function isDark(color: Color): boolean {$/;"	f
DocumentHighlighter	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^export default class DocumentHighlighter {$/;"	c
disposables	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  private disposables: Disposable[] = []$/;"	m
matchIds	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  private matchIds: Set<number> = new Set()$/;"	m
cursorMoveTs	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  private cursorMoveTs: number$/;"	m
clearHighlight	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  public clearHighlight(): void {$/;"	m
highlight	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  public async highlight(bufnr: number): Promise<void> {$/;"	m
getHighlights	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  public async getHighlights(document: Document | null): Promise<DocumentHighlight[]> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/documentHighlight.ts	/^  public dispose(): void {$/;"	m
Colors	nvim/plugged/coc.nvim/src/handler/colors.ts	/^export default class Colors {$/;"	c
_enabled	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private _enabled = true$/;"	m
srcId	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private srcId = 1090$/;"	m
disposables	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private disposables: Disposable[] = []$/;"	m
highlighters	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private highlighters: Map<number, Highlighter> = new Map()$/;"	m
highlightCurrent	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private highlightCurrent: Function & { clear(): void }$/;"	m
_highlightCurrent	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private async _highlightCurrent(): Promise<void> {$/;"	m
highlightColors	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public async highlightColors(document: Document, force = false): Promise<void> {$/;"	m
pickPresentation	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public async pickPresentation(): Promise<void> {$/;"	m
pickColor	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public async pickColor(): Promise<void> {$/;"	m
enabled	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public get enabled(): boolean {$/;"	m
clearHighlight	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public clearHighlight(bufnr: number): void {$/;"	m
hasColor	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public hasColor(bufnr: number): boolean {$/;"	m
hasColorAtPostion	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public hasColorAtPostion(bufnr: number, position: Position): boolean {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  public dispose(): void {$/;"	m
getHighlighter	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private getHighlighter(bufnr: number): Highlighter {$/;"	m
currentColorInfomation	nvim/plugged/coc.nvim/src/handler/colors.ts	/^  private async currentColorInfomation(): Promise<ColorInformation | null> {$/;"	m
SymbolInfo	nvim/plugged/coc.nvim/src/handler/index.ts	/^interface SymbolInfo {$/;"	i
CommandItem	nvim/plugged/coc.nvim/src/handler/index.ts	/^interface CommandItem {$/;"	i
SignaturePart	nvim/plugged/coc.nvim/src/handler/index.ts	/^interface SignaturePart {$/;"	i
Preferences	nvim/plugged/coc.nvim/src/handler/index.ts	/^interface Preferences {$/;"	i
Handler	nvim/plugged/coc.nvim/src/handler/index.ts	/^export default class Handler {$/;"	c
preferences	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private preferences: Preferences$/;"	m
documentHighlighter	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private documentHighlighter: DocumentHighlighter$/;"	m
hoverPosition	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private hoverPosition: [number, number, number]$/;"	m
colors	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private colors: Colors$/;"	m
hoverFactory	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private hoverFactory: FloatFactory$/;"	m
signatureFactory	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private signatureFactory: FloatFactory$/;"	m
refactorMap	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private refactorMap: Map<number, Refactor> = new Map()$/;"	m
documentLines	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private documentLines: string[] = []$/;"	m
codeLensManager	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private codeLensManager: CodeLensManager$/;"	m
signatureTokenSource	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private signatureTokenSource: CancellationTokenSource$/;"	m
disposables	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private disposables: Disposable[] = []$/;"	m
labels	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private labels: { [key: string]: string } = {}$/;"	m
selectionRange	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private selectionRange: SelectionRange = null$/;"	m
signaturePosition	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private signaturePosition: Position$/;"	m
getCurrentFunctionSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getCurrentFunctionSymbol(): Promise<string> {$/;"	m
hasProvider	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async hasProvider(id: string): Promise<boolean> {$/;"	m
onHover	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async onHover(): Promise<boolean> {$/;"	m
gotoDefinition	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async gotoDefinition(openCommand?: string): Promise<boolean> {$/;"	m
gotoDeclaration	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async gotoDeclaration(openCommand?: string): Promise<boolean> {$/;"	m
gotoTypeDefinition	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async gotoTypeDefinition(openCommand?: string): Promise<boolean> {$/;"	m
gotoImplementation	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async gotoImplementation(openCommand?: string): Promise<boolean> {$/;"	m
gotoReferences	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async gotoReferences(openCommand?: string): Promise<boolean> {$/;"	m
getDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getDocumentSymbols(document?: Document): Promise<SymbolInfo[]> {$/;"	m
getWordEdit	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getWordEdit(): Promise<WorkspaceEdit> {$/;"	m
rename	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async rename(newName?: string): Promise<boolean> {$/;"	m
documentFormatting	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async documentFormatting(): Promise<boolean> {$/;"	m
documentRangeFormatting	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async documentRangeFormatting(mode: string): Promise<number> {$/;"	m
runCommand	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async runCommand(id?: string, ...args: any[]): Promise<any> {$/;"	m
getCodeActions	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getCodeActions(bufnr: number, range?: Range, only?: CodeActionKind[]): Promise<CodeAction[]> {$/;"	m
doCodeAction	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async doCodeAction(mode: string | null, only?: CodeActionKind[] | string): Promise<void> {$/;"	m
getCurrentCodeActions	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getCurrentCodeActions(mode?: string, only?: CodeActionKind[]): Promise<CodeAction[]> {$/;"	m
doQuickfix	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async doQuickfix(): Promise<boolean> {$/;"	m
applyCodeAction	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async applyCodeAction(action: CodeAction): Promise<void> {$/;"	m
doCodeLensAction	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async doCodeLensAction(): Promise<void> {$/;"	m
fold	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async fold(kind?: string): Promise<boolean> {$/;"	m
pickColor	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async pickColor(): Promise<void> {$/;"	m
pickPresentation	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async pickPresentation(): Promise<void> {$/;"	m
highlight	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async highlight(): Promise<void> {$/;"	m
getSymbolsRanges	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getSymbolsRanges(): Promise<Range[]> {$/;"	m
links	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async links(): Promise<DocumentLink[]> {$/;"	m
openLink	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async openLink(): Promise<boolean> {$/;"	m
getCommands	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getCommands(): Promise<CommandItem[]> {$/;"	m
selectFunction	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async selectFunction(inner: boolean, visualmode: string): Promise<void> {$/;"	m
onCharacterType	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private async onCharacterType(ch: string, bufnr: number, insertLeave = false): Promise<void> {$/;"	m
triggerSignatureHelp	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private async triggerSignatureHelp(document: Document, position: Position): Promise<boolean> {$/;"	m
showSignatureHelp	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async showSignatureHelp(): Promise<boolean> {$/;"	m
handleLocations	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async handleLocations(definition: Definition | LocationLink[], openCommand?: string | false): Promise<void> {$/;"	m
getSelectionRanges	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async getSelectionRanges(): Promise<SelectionRange[] | null> {$/;"	m
selectRange	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async selectRange(visualmode: string, forward: boolean): Promise<void> {$/;"	m
codeActionRange	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async codeActionRange(start: number, end: number, only: string): Promise<void> {$/;"	m
doRefactor	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async doRefactor(): Promise<void> {$/;"	m
saveRefactor	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async saveRefactor(bufnr: number): Promise<void> {$/;"	m
search	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public async search(args: string[]): Promise<void> {$/;"	m
previewHover	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private async previewHover(hovers: Hover[]): Promise<void> {$/;"	m
getPreferences	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private getPreferences(): void {$/;"	m
onEmptyLocation	nvim/plugged/coc.nvim/src/handler/index.ts	/^  private onEmptyLocation(name: string, location: any | null): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/handler/index.ts	/^  public dispose(): void {$/;"	m
getPreviousContainer	nvim/plugged/coc.nvim/src/handler/index.ts	/^function getPreviousContainer(containerName: string, symbols: SymbolInfo[]): SymbolInfo {$/;"	f
getPreviousContainer	nvim/plugged/coc.nvim/src/handler/index.ts	/^function getPreviousContainer(containerName: string, symbols: SymbolInfo[]): SymbolInfo {$/;"	f
getPreviousContainer	nvim/plugged/coc.nvim/src/handler/index.ts	/^function getPreviousContainer(containerName: string, symbols: SymbolInfo[]): SymbolInfo {$/;"	f
sortDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortDocumentSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
sortDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortDocumentSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
sortDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortDocumentSymbols(a: DocumentSymbol, b: DocumentSymbol): number {$/;"	f
addDoucmentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function addDoucmentSymbol(res: SymbolInfo[], sym: DocumentSymbol, level: number): void {$/;"	f
addDoucmentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function addDoucmentSymbol(res: SymbolInfo[], sym: DocumentSymbol, level: number): void {$/;"	f
addDoucmentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function addDoucmentSymbol(res: SymbolInfo[], sym: DocumentSymbol, level: number): void {$/;"	f
sortSymbolInformations	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortSymbolInformations(a: SymbolInformation, b: SymbolInformation): number {$/;"	f
sortSymbolInformations	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortSymbolInformations(a: SymbolInformation, b: SymbolInformation): number {$/;"	f
sortSymbolInformations	nvim/plugged/coc.nvim/src/handler/index.ts	/^function sortSymbolInformations(a: SymbolInformation, b: SymbolInformation): number {$/;"	f
isDocumentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbol(a: DocumentSymbol | SymbolInformation): a is DocumentSymbol {$/;"	f
isDocumentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbol(a: DocumentSymbol | SymbolInformation): a is DocumentSymbol {$/;"	f
isDocumentSymbol	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbol(a: DocumentSymbol | SymbolInformation): a is DocumentSymbol {$/;"	f
isEmpty	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isEmpty(location: any): boolean {$/;"	f
isEmpty	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isEmpty(location: any): boolean {$/;"	f
isEmpty	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isEmpty(location: any): boolean {$/;"	f
isDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbols(a: DocumentSymbol[] | SymbolInformation[]): a is DocumentSymbol[] {$/;"	f
isDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbols(a: DocumentSymbol[] | SymbolInformation[]): a is DocumentSymbol[] {$/;"	f
isDocumentSymbols	nvim/plugged/coc.nvim/src/handler/index.ts	/^function isDocumentSymbols(a: DocumentSymbol[] | SymbolInformation[]): a is DocumentSymbol[] {$/;"	f
Config	nvim/plugged/coc.nvim/src/cursors/index.ts	/^interface Config {$/;"	i
Cursors	nvim/plugged/coc.nvim/src/cursors/index.ts	/^export default class Cursors {$/;"	c
_activated	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private _activated = false$/;"	m
_changed	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private _changed = false$/;"	m
ranges	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private ranges: TextRange[] = []$/;"	m
disposables	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private disposables: Disposable[] = []$/;"	m
bufnr	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private bufnr: number$/;"	m
winid	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private winid: number$/;"	m
matchIds	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private matchIds: number[] = []$/;"	m
textDocument	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private textDocument: TextDocument$/;"	m
version	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private version = -1$/;"	m
config	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private config: Config$/;"	m
loadConfig	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private loadConfig(): void {$/;"	m
select	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  public async select(bufnr: number, kind: string, mode: string): Promise<void> {$/;"	m
activate	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private activate(doc: Document, winid): void {$/;"	m
doHighlights	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private doHighlights(): void {$/;"	m
cancel	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  public cancel(): void {$/;"	m
unmap	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private unmap(key: string): void {$/;"	m
addRanges	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  public async addRanges(ranges: Range[]): Promise<void> {$/;"	m
activated	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  public get activated(): boolean {$/;"	m
getTextRange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private getTextRange(range: Range, text: string): TextRange | null {$/;"	m
applySingleEdit	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private async applySingleEdit(textRange: TextRange, edit: TextEdit): Promise<void> {$/;"	m
applyComposedEdit	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private async applyComposedEdit(original: string, edit: TextEdit): Promise<void> {$/;"	m
adjustChange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private adjustChange(textRange: TextRange, range: Range, text: string): void {$/;"	m
addRange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private addRange(range: Range, text: string): void {$/;"	m
lastPosition	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private get lastPosition(): Position {$/;"	m
firstPosition	nvim/plugged/coc.nvim/src/cursors/index.ts	/^  private get firstPosition(): Position {$/;"	m
splitRange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function splitRange(doc: Document, range: Range): Range[] {$/;"	f
splitRange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function splitRange(doc: Document, range: Range): Range[] {$/;"	f
splitRange	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function splitRange(doc: Document, range: Range): Range[] {$/;"	f
getVisualRanges	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function getVisualRanges(doc: Document, range: Range): Range[] {$/;"	f
getVisualRanges	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function getVisualRanges(doc: Document, range: Range): Range[] {$/;"	f
getVisualRanges	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function getVisualRanges(doc: Document, range: Range): Range[] {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function adjustPosition(position: Position, delta: Position): Position {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function adjustPosition(position: Position, delta: Position): Position {$/;"	f
adjustPosition	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function adjustPosition(position: Position, delta: Position): Position {$/;"	f
equalEdit	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function equalEdit(one: TextEdit, two: TextEdit): boolean {$/;"	f
equalEdit	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function equalEdit(one: TextEdit, two: TextEdit): boolean {$/;"	f
equalEdit	nvim/plugged/coc.nvim/src/cursors/index.ts	/^function equalEdit(one: TextEdit, two: TextEdit): boolean {$/;"	f
TextRange	nvim/plugged/coc.nvim/src/cursors/range.ts	/^export default class TextRange {$/;"	c
currStart	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  private currStart: number$/;"	m
currEnd	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  private currEnd: number$/;"	m
start	nvim/plugged/coc.nvim/src/cursors/range.ts	/^    public readonly start: number,$/;"	m
end	nvim/plugged/coc.nvim/src/cursors/range.ts	/^    public readonly end: number,$/;"	m
text	nvim/plugged/coc.nvim/src/cursors/range.ts	/^    public text: string,$/;"	m
preCount	nvim/plugged/coc.nvim/src/cursors/range.ts	/^    public preCount: number) {$/;"	m
add	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public add(offset: number, add: string): void {$/;"	m
replace	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public replace(begin: number, end: number, add = ''): void {$/;"	m
range	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public get range(): Range {$/;"	m
currRange	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public get currRange(): Range {$/;"	m
applyEdit	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public applyEdit(edit: TextEdit): void {$/;"	m
textEdit	nvim/plugged/coc.nvim/src/cursors/range.ts	/^  public get textEdit(): TextEdit {$/;"	m
ServiceInfo	nvim/plugged/coc.nvim/src/services.ts	/^interface ServiceInfo {$/;"	i
getStateName	nvim/plugged/coc.nvim/src/services.ts	/^export function getStateName(state: ServiceStat): string {$/;"	f
getStateName	nvim/plugged/coc.nvim/src/services.ts	/^export function getStateName(state: ServiceStat): string {$/;"	f
getStateName	nvim/plugged/coc.nvim/src/services.ts	/^export function getStateName(state: ServiceStat): string {$/;"	f
ServiceManager	nvim/plugged/coc.nvim/src/services.ts	/^export class ServiceManager extends EventEmitter implements Disposable {$/;"	c
registered	nvim/plugged/coc.nvim/src/services.ts	/^  private readonly registered: Map<string, IServiceProvider> = new Map()$/;"	m
disposables	nvim/plugged/coc.nvim/src/services.ts	/^  private disposables: Disposable[] = []$/;"	m
init	nvim/plugged/coc.nvim/src/services.ts	/^  public init(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/services.ts	/^  public dispose(): void {$/;"	m
regist	nvim/plugged/coc.nvim/src/services.ts	/^  public regist(service: IServiceProvider): Disposable {$/;"	m
getService	nvim/plugged/coc.nvim/src/services.ts	/^  public getService(id: string): IServiceProvider {$/;"	m
hasService	nvim/plugged/coc.nvim/src/services.ts	/^  private hasService(id: string): boolean {$/;"	m
shouldStart	nvim/plugged/coc.nvim/src/services.ts	/^  private shouldStart(service: IServiceProvider): boolean {$/;"	m
start	nvim/plugged/coc.nvim/src/services.ts	/^  private start(document: TextDocument): void {$/;"	m
getServices	nvim/plugged/coc.nvim/src/services.ts	/^  public getServices(document: TextDocument): IServiceProvider[] {$/;"	m
stop	nvim/plugged/coc.nvim/src/services.ts	/^  public stop(id: string): Promise<void> {$/;"	m
stopAll	nvim/plugged/coc.nvim/src/services.ts	/^  public async stopAll(): Promise<void> {$/;"	m
toggle	nvim/plugged/coc.nvim/src/services.ts	/^  public async toggle(id: string): Promise<void> {$/;"	m
getServiceStats	nvim/plugged/coc.nvim/src/services.ts	/^  public getServiceStats(): ServiceInfo[] {$/;"	m
createCustomServices	nvim/plugged/coc.nvim/src/services.ts	/^  private createCustomServices(): void {$/;"	m
waitClient	nvim/plugged/coc.nvim/src/services.ts	/^  private waitClient(id: string): Promise<void> {$/;"	m
registNotification	nvim/plugged/coc.nvim/src/services.ts	/^  public async registNotification(id: string, method: string): Promise<void> {$/;"	m
sendRequest	nvim/plugged/coc.nvim/src/services.ts	/^  public async sendRequest(id: string, method: string, params?: any): Promise<any> {$/;"	m
registLanguageClient	nvim/plugged/coc.nvim/src/services.ts	/^  public registLanguageClient(client: LanguageClient): Disposable {$/;"	m
documentSelectorToLanguageIds	nvim/plugged/coc.nvim/src/services.ts	/^export function documentSelectorToLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
documentSelectorToLanguageIds	nvim/plugged/coc.nvim/src/services.ts	/^export function documentSelectorToLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
documentSelectorToLanguageIds	nvim/plugged/coc.nvim/src/services.ts	/^export function documentSelectorToLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
getLanguageServerOptions	nvim/plugged/coc.nvim/src/services.ts	/^export function getLanguageServerOptions(id: string, name: string, config: LanguageServerConfig): [LanguageClientOptions, ServerOptions] {$/;"	f
getLanguageServerOptions	nvim/plugged/coc.nvim/src/services.ts	/^export function getLanguageServerOptions(id: string, name: string, config: LanguageServerConfig): [LanguageClientOptions, ServerOptions] {$/;"	f
getLanguageServerOptions	nvim/plugged/coc.nvim/src/services.ts	/^export function getLanguageServerOptions(id: string, name: string, config: LanguageServerConfig): [LanguageClientOptions, ServerOptions] {$/;"	f
getRevealOutputChannelOn	nvim/plugged/coc.nvim/src/services.ts	/^export function getRevealOutputChannelOn(revealOn: string | undefined): RevealOutputChannelOn {$/;"	f
getRevealOutputChannelOn	nvim/plugged/coc.nvim/src/services.ts	/^export function getRevealOutputChannelOn(revealOn: string | undefined): RevealOutputChannelOn {$/;"	f
getRevealOutputChannelOn	nvim/plugged/coc.nvim/src/services.ts	/^export function getRevealOutputChannelOn(revealOn: string | undefined): RevealOutputChannelOn {$/;"	f
getTransportKind	nvim/plugged/coc.nvim/src/services.ts	/^export function getTransportKind(config: LanguageServerConfig): Transport {$/;"	f
getTransportKind	nvim/plugged/coc.nvim/src/services.ts	/^export function getTransportKind(config: LanguageServerConfig): Transport {$/;"	f
getTransportKind	nvim/plugged/coc.nvim/src/services.ts	/^export function getTransportKind(config: LanguageServerConfig): Transport {$/;"	f
getForkOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getForkOptions(config: LanguageServerConfig): ForkOptions {$/;"	f
getForkOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getForkOptions(config: LanguageServerConfig): ForkOptions {$/;"	f
getForkOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getForkOptions(config: LanguageServerConfig): ForkOptions {$/;"	f
getSpawnOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getSpawnOptions(config: LanguageServerConfig): SpawnOptions {$/;"	f
getSpawnOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getSpawnOptions(config: LanguageServerConfig): SpawnOptions {$/;"	f
getSpawnOptions	nvim/plugged/coc.nvim/src/services.ts	/^function getSpawnOptions(config: LanguageServerConfig): SpawnOptions {$/;"	f
stateString	nvim/plugged/coc.nvim/src/services.ts	/^function stateString(state: State): string {$/;"	f
stateString	nvim/plugged/coc.nvim/src/services.ts	/^function stateString(state: State): string {$/;"	f
stateString	nvim/plugged/coc.nvim/src/services.ts	/^function stateString(state: State): string {$/;"	f
PathOption	nvim/plugged/coc.nvim/src/source/file.ts	/^interface PathOption {$/;"	i
File	nvim/plugged/coc.nvim/src/source/file.ts	/^export default class File extends Source {$/;"	c
getPathOption	nvim/plugged/coc.nvim/src/source/file.ts	/^  private getPathOption(opt: CompleteOption): PathOption | null {$/;"	m
getFileItem	nvim/plugged/coc.nvim/src/source/file.ts	/^  private async getFileItem(root: string, filename: string): Promise<VimCompleteItem | null> {$/;"	m
filterFiles	nvim/plugged/coc.nvim/src/source/file.ts	/^  public filterFiles(files: string[]): string[] {$/;"	m
getItemsFromRoot	nvim/plugged/coc.nvim/src/source/file.ts	/^  public async getItemsFromRoot(pathstr: string, root: string): Promise<VimCompleteItem[]> {$/;"	m
trimSameExts	nvim/plugged/coc.nvim/src/source/file.ts	/^  public get trimSameExts(): string[] {$/;"	m
doComplete	nvim/plugged/coc.nvim/src/source/file.ts	/^  public async doComplete(opt: CompleteOption): Promise<CompleteResult> {$/;"	m
regist	nvim/plugged/coc.nvim/src/source/file.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/file.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/file.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
Buffer	nvim/plugged/coc.nvim/src/source/buffer.ts	/^export default class Buffer extends Source {$/;"	c
ignoreGitignore	nvim/plugged/coc.nvim/src/source/buffer.ts	/^  public get ignoreGitignore(): boolean {$/;"	m
getWords	nvim/plugged/coc.nvim/src/source/buffer.ts	/^  private getWords(bufnr: number): string[] {$/;"	m
doComplete	nvim/plugged/coc.nvim/src/source/buffer.ts	/^  public async doComplete(opt: CompleteOption): Promise<CompleteResult> {$/;"	m
regist	nvim/plugged/coc.nvim/src/source/buffer.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/buffer.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/buffer.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
Around	nvim/plugged/coc.nvim/src/source/around.ts	/^export default class Around extends Source {$/;"	c
doComplete	nvim/plugged/coc.nvim/src/source/around.ts	/^  public async doComplete(opt: CompleteOption): Promise<CompleteResult> {$/;"	m
regist	nvim/plugged/coc.nvim/src/source/around.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/around.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
regist	nvim/plugged/coc.nvim/src/source/around.ts	/^export function regist(sourceMap: Map<string, ISource>): Disposable {$/;"	f
API	nvim/plugged/coc.nvim/src/extensions.ts	/^export type API = { [index: string]: any } | void | null | undefined$/;"	t
PropertyScheme	nvim/plugged/coc.nvim/src/extensions.ts	/^export interface PropertyScheme {$/;"	i
ExtensionItem	nvim/plugged/coc.nvim/src/extensions.ts	/^export interface ExtensionItem {$/;"	i
loadJson	nvim/plugged/coc.nvim/src/extensions.ts	/^function loadJson(file: string): any {$/;"	f
loadJson	nvim/plugged/coc.nvim/src/extensions.ts	/^function loadJson(file: string): any {$/;"	f
loadJson	nvim/plugged/coc.nvim/src/extensions.ts	/^function loadJson(file: string): any {$/;"	f
Extensions	nvim/plugged/coc.nvim/src/extensions.ts	/^export class Extensions {$/;"	c
list	nvim/plugged/coc.nvim/src/extensions.ts	/^  private list: ExtensionItem[] = []$/;"	m
disabled	nvim/plugged/coc.nvim/src/extensions.ts	/^  private disabled: Set<string> = new Set()$/;"	m
db	nvim/plugged/coc.nvim/src/extensions.ts	/^  private db: DB$/;"	m
memos	nvim/plugged/coc.nvim/src/extensions.ts	/^  private memos: Memos$/;"	m
root	nvim/plugged/coc.nvim/src/extensions.ts	/^  private root: string$/;"	m
_onDidLoadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  private _onDidLoadExtension = new Emitter<Extension<API>>()$/;"	m
_onDidActiveExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  private _onDidActiveExtension = new Emitter<Extension<API>>()$/;"	m
_onDidUnloadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  private _onDidUnloadExtension = new Emitter<string>()$/;"	m
_additionalSchemes	nvim/plugged/coc.nvim/src/extensions.ts	/^  private _additionalSchemes: { [key: string]: PropertyScheme } = {}$/;"	m
activated	nvim/plugged/coc.nvim/src/extensions.ts	/^  private activated = false$/;"	m
manager	nvim/plugged/coc.nvim/src/extensions.ts	/^  private manager: ExtensionManager$/;"	m
ready	nvim/plugged/coc.nvim/src/extensions.ts	/^  public ready = true$/;"	m
onDidLoadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public readonly onDidLoadExtension: Event<Extension<API>> = this._onDidLoadExtension.event$/;"	m
onDidActiveExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public readonly onDidActiveExtension: Event<Extension<API>> = this._onDidActiveExtension.event$/;"	m
onDidUnloadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public readonly onDidUnloadExtension: Event<string> = this._onDidUnloadExtension.event$/;"	m
init	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async init(): Promise<void> {$/;"	m
activateExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async activateExtensions(): Promise<void> {$/;"	m
updateExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async updateExtensions(): Promise<Disposable | null> {$/;"	m
checkExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async checkExtensions(): Promise<void> {$/;"	m
installExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async installExtensions(list: string[] = []): Promise<void> {$/;"	m
getMissingExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public getMissingExtensions(): string[] {$/;"	m
npm	nvim/plugged/coc.nvim/src/extensions.ts	/^  private get npm(): string {$/;"	m
all	nvim/plugged/coc.nvim/src/extensions.ts	/^  public get all(): Extension<API>[] {$/;"	m
getExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public getExtension(id: string): ExtensionItem {$/;"	m
getExtensionState	nvim/plugged/coc.nvim/src/extensions.ts	/^  public getExtensionState(id: string): ExtensionState {$/;"	m
getExtensionStates	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async getExtensionStates(): Promise<ExtensionInfo[]> {$/;"	m
getLockedList	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async getLockedList(): Promise<string[]> {$/;"	m
toggleLock	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async toggleLock(id: string): Promise<void> {$/;"	m
toggleExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async toggleExtension(id: string): Promise<void> {$/;"	m
reloadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async reloadExtension(id: string): Promise<void> {$/;"	m
cleanExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async cleanExtensions(): Promise<void> {$/;"	m
uninstallExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async uninstallExtension(ids: string[]): Promise<void> {$/;"	m
isDisabled	nvim/plugged/coc.nvim/src/extensions.ts	/^  public isDisabled(id: string): boolean {$/;"	m
onExtensionInstall	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async onExtensionInstall(id: string): Promise<void> {$/;"	m
has	nvim/plugged/coc.nvim/src/extensions.ts	/^  public has(id: string): boolean {$/;"	m
isActivated	nvim/plugged/coc.nvim/src/extensions.ts	/^  public isActivated(id: string): boolean {$/;"	m
loadExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async loadExtension(folder: string, isLocal = false): Promise<void> {$/;"	m
loadFileExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async loadFileExtensions(): Promise<void> {$/;"	m
loadExtensionFile	nvim/plugged/coc.nvim/src/extensions.ts	/^  public loadExtensionFile(filepath: string): void {$/;"	m
activate	nvim/plugged/coc.nvim/src/extensions.ts	/^  public activate(id, silent = true): void {$/;"	m
deactivate	nvim/plugged/coc.nvim/src/extensions.ts	/^  public deactivate(id): boolean {$/;"	m
call	nvim/plugged/coc.nvim/src/extensions.ts	/^  public async call(id: string, method: string, args: any[]): Promise<any> {$/;"	m
getExtensionApi	nvim/plugged/coc.nvim/src/extensions.ts	/^  public getExtensionApi(id: string): API | null {$/;"	m
registerExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  public registerExtension(extension: Extension<API>, deactivate?: () => void): void {$/;"	m
globalExtensions	nvim/plugged/coc.nvim/src/extensions.ts	/^  public get globalExtensions(): string[] {$/;"	m
globalExtensionStats	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async globalExtensionStats(): Promise<ExtensionInfo[]> {$/;"	m
localExtensionStats	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async localExtensionStats(exclude: ExtensionInfo[]): Promise<ExtensionInfo[]> {$/;"	m
isGlobalExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  private isGlobalExtension(id: string): boolean {$/;"	m
loadJson	nvim/plugged/coc.nvim/src/extensions.ts	/^  private loadJson(): any {$/;"	m
schemes	nvim/plugged/coc.nvim/src/extensions.ts	/^  public get schemes(): { [key: string]: PropertyScheme } {$/;"	m
addSchemeProperty	nvim/plugged/coc.nvim/src/extensions.ts	/^  public addSchemeProperty(key: string, def: PropertyScheme): void {$/;"	m
setupActiveEvents	nvim/plugged/coc.nvim/src/extensions.ts	/^  private setupActiveEvents(id: string, packageJSON: any): void {$/;"	m
createExtension	nvim/plugged/coc.nvim/src/extensions.ts	/^  private createExtension(root: string, packageJSON: any, isLocal = false): string {$/;"	m
initializeRoot	nvim/plugged/coc.nvim/src/extensions.ts	/^  private async initializeRoot(): Promise<void> {$/;"	m
HighlightItem	nvim/plugged/coc.nvim/src/model/highligher.ts	/^export interface HighlightItem {$/;"	i
Highlighter	nvim/plugged/coc.nvim/src/model/highligher.ts	/^export default class Highlighter {$/;"	c
lines	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  private lines: string[] = []$/;"	m
highlights	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  private highlights: HighlightItem[] = []$/;"	m
addLine	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public addLine(line: string, hlGroup?: string): void {$/;"	m
addLines	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public addLines(lines): void {$/;"	m
addText	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public addText(text: string, hlGroup?: string): void {$/;"	m
length	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public get length(): number {$/;"	m
getline	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public getline(line: number): string {$/;"	m
render	nvim/plugged/coc.nvim/src/model/highligher.ts	/^  public render(buffer: Buffer, start = 0, end = -1): void {$/;"	m
DB	nvim/plugged/coc.nvim/src/model/db.ts	/^export default class DB {$/;"	c
fetch	nvim/plugged/coc.nvim/src/model/db.ts	/^  public fetch(key: string): any {$/;"	m
exists	nvim/plugged/coc.nvim/src/model/db.ts	/^  public exists(key: string): boolean {$/;"	m
delete	nvim/plugged/coc.nvim/src/model/db.ts	/^  public delete(key: string): void {$/;"	m
push	nvim/plugged/coc.nvim/src/model/db.ts	/^  public push(key: string, data: number | null | boolean | string | { [index: string]: any }): void {$/;"	m
load	nvim/plugged/coc.nvim/src/model/db.ts	/^  private load(): any {$/;"	m
clear	nvim/plugged/coc.nvim/src/model/db.ts	/^  public clear(): void {$/;"	m
destroy	nvim/plugged/coc.nvim/src/model/db.ts	/^  public destroy(): void {$/;"	m
TerminalModel	nvim/plugged/coc.nvim/src/model/terminal.ts	/^export default class TerminalModel implements Terminal {$/;"	c
bufnr	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public bufnr: number$/;"	m
pid	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  private pid = 0$/;"	m
args	nvim/plugged/coc.nvim/src/model/terminal.ts	/^    private args: string[],$/;"	m
nvim	nvim/plugged/coc.nvim/src/model/terminal.ts	/^    private nvim: Neovim,$/;"	m
_name	nvim/plugged/coc.nvim/src/model/terminal.ts	/^    private _name?: string) {$/;"	m
start	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public async start(cwd?: string, env?: { [key: string]: string | null }): Promise<void> {$/;"	m
name	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public get name(): string {$/;"	m
processId	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public get processId(): Promise<number> {$/;"	m
sendText	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public sendText(text: string, addNewLine = true): void {$/;"	m
show	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public async show(preserveFocus?: boolean): Promise<boolean> {$/;"	m
hide	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public async hide(): Promise<void> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/terminal.ts	/^  public dispose(): void {$/;"	m
Callback	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^export type Callback = (event: TextDocumentWillSaveEvent) => void$/;"	t
PromiseCallback	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^export type PromiseCallback = (event: TextDocumentWillSaveEvent) => Promise<void>$/;"	t
WillSaveUntilHandler	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^export default class WillSaveUntilHandler {$/;"	c
callbacks	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^  private callbacks: PromiseCallback[] = []$/;"	m
nvim	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^  private get nvim(): Neovim {$/;"	m
addCallback	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^  public addCallback(callback: Callback, thisArg: any, clientId: string): Disposable {$/;"	m
hasCallback	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^  public get hasCallback(): boolean {$/;"	m
handeWillSaveUntil	nvim/plugged/coc.nvim/src/model/willSaveHandler.ts	/^  public async handeWillSaveUntil(event: TextDocumentWillSaveEvent): Promise<void> {$/;"	m
BufferChannel	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^export default class BufferChannel implements OutputChannel {$/;"	c
_content	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private _content = ''$/;"	m
disposables	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private disposables: Disposable[] = []$/;"	m
_showing	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private _showing = false$/;"	m
promise	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private promise = Promise.resolve(void 0)$/;"	m
content	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public get content(): string {$/;"	m
_append	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private async _append(value: string, isLine: boolean): Promise<void> {$/;"	m
append	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public append(value: string): void {$/;"	m
appendLine	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public appendLine(value: string): void {$/;"	m
clear	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public clear(): void {$/;"	m
hide	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public hide(): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public dispose(): void {$/;"	m
buffer	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private get buffer(): Buffer | null {$/;"	m
openBuffer	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  private async openBuffer(preserveFocus?: boolean): Promise<void> {$/;"	m
show	nvim/plugged/coc.nvim/src/model/outputChannel.ts	/^  public show(preserveFocus?: boolean): void {$/;"	m
Source	nvim/plugged/coc.nvim/src/model/source.ts	/^export default class Source implements ISource {$/;"	c
name	nvim/plugged/coc.nvim/src/model/source.ts	/^  public readonly name: string$/;"	m
filepath	nvim/plugged/coc.nvim/src/model/source.ts	/^  public readonly filepath: string$/;"	m
sourceType	nvim/plugged/coc.nvim/src/model/source.ts	/^  public readonly sourceType: SourceType$/;"	m
isSnippet	nvim/plugged/coc.nvim/src/model/source.ts	/^  public readonly isSnippet: boolean$/;"	m
nvim	nvim/plugged/coc.nvim/src/model/source.ts	/^  protected readonly nvim: Neovim$/;"	m
_disabled	nvim/plugged/coc.nvim/src/model/source.ts	/^  private _disabled = false$/;"	m
defaults	nvim/plugged/coc.nvim/src/model/source.ts	/^  private defaults: any$/;"	m
priority	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get priority(): number {$/;"	m
triggerOnly	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get triggerOnly(): boolean {$/;"	m
triggerCharacters	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get triggerCharacters(): string[] {$/;"	m
optionalFns	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get optionalFns(): string[] {$/;"	m
triggerPatterns	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get triggerPatterns(): RegExp[] | null {$/;"	m
shortcut	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get shortcut(): string {$/;"	m
enable	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get enable(): boolean {$/;"	m
filetypes	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get filetypes(): string[] | null {$/;"	m
disableSyntaxes	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get disableSyntaxes(): string[] {$/;"	m
getConfig	nvim/plugged/coc.nvim/src/model/source.ts	/^  public getConfig<T>(key: string, defaultValue?: T): T | null {$/;"	m
toggle	nvim/plugged/coc.nvim/src/model/source.ts	/^  public toggle(): void {$/;"	m
firstMatch	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get firstMatch(): boolean {$/;"	m
menu	nvim/plugged/coc.nvim/src/model/source.ts	/^  public get menu(): string {$/;"	m
filterWords	nvim/plugged/coc.nvim/src/model/source.ts	/^  protected filterWords(words: string[], opt: CompleteOption): string[] {$/;"	m
fixStartcol	nvim/plugged/coc.nvim/src/model/source.ts	/^  protected fixStartcol(opt: CompleteOption, valids: string[]): number {$/;"	m
shouldComplete	nvim/plugged/coc.nvim/src/model/source.ts	/^  public async shouldComplete(opt: CompleteOption): Promise<boolean> {$/;"	m
refresh	nvim/plugged/coc.nvim/src/model/source.ts	/^  public async refresh(): Promise<void> {$/;"	m
onCompleteDone	nvim/plugged/coc.nvim/src/model/source.ts	/^  public async onCompleteDone(item: VimCompleteItem, opt: CompleteOption): Promise<void> {$/;"	m
doComplete	nvim/plugged/coc.nvim/src/model/source.ts	/^  public async doComplete(opt: CompleteOption, token: CancellationToken): Promise<CompleteResult | null> {$/;"	m
Info	nvim/plugged/coc.nvim/src/model/extension.ts	/^export interface Info {$/;"	i
registryUrl	nvim/plugged/coc.nvim/src/model/extension.ts	/^function registryUrl(scope = ''): string {$/;"	f
registryUrl	nvim/plugged/coc.nvim/src/model/extension.ts	/^function registryUrl(scope = ''): string {$/;"	f
registryUrl	nvim/plugged/coc.nvim/src/model/extension.ts	/^function registryUrl(scope = ''): string {$/;"	f
ExtensionManager	nvim/plugged/coc.nvim/src/model/extension.ts	/^export default class ExtensionManager {$/;"	c
checked	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private checked = false$/;"	m
checkFolder	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private checkFolder(): void {$/;"	m
getInfo	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private async getInfo(ref: string): Promise<Info> {$/;"	m
removeFolder	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private async removeFolder(folder: string): Promise<void> {$/;"	m
_install	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private async _install(npm: string, def: string, info: Info, onMessage: (msg: string) => void): Promise<void> {$/;"	m
install	nvim/plugged/coc.nvim/src/model/extension.ts	/^  public async install(npm: string, def: string): Promise<string> {$/;"	m
update	nvim/plugged/coc.nvim/src/model/extension.ts	/^  public async update(npm: string, name: string, uri?: string): Promise<boolean> {$/;"	m
getInfoFromUri	nvim/plugged/coc.nvim/src/model/extension.ts	/^  private async getInfoFromUri(uri: string): Promise<Info> {$/;"	m
StatusLine	nvim/plugged/coc.nvim/src/model/status.ts	/^export default class StatusLine implements Disposable {$/;"	c
items	nvim/plugged/coc.nvim/src/model/status.ts	/^  private items: Map<string, StatusBarItem> = new Map()$/;"	m
shownIds	nvim/plugged/coc.nvim/src/model/status.ts	/^  private shownIds: Set<string> = new Set()$/;"	m
_text	nvim/plugged/coc.nvim/src/model/status.ts	/^  private _text = ''$/;"	m
interval	nvim/plugged/coc.nvim/src/model/status.ts	/^  private interval: NodeJS.Timer$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/status.ts	/^  public dispose(): void {$/;"	m
createStatusBarItem	nvim/plugged/coc.nvim/src/model/status.ts	/^  public createStatusBarItem(priority = 0, isProgress = false): StatusBarItem {$/;"	m
getText	nvim/plugged/coc.nvim/src/model/status.ts	/^  private getText(): string {$/;"	m
setStatusText	nvim/plugged/coc.nvim/src/model/status.ts	/^  private async setStatusText(): Promise<void> {$/;"	m
FloatBuffer	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^export default class FloatBuffer {$/;"	c
lines	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private lines: string[] = []$/;"	m
highlights	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private highlights: Highlight[]$/;"	m
positions	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private positions: [number, number, number?][] = []$/;"	m
enableHighlight	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private enableHighlight = true$/;"	m
tabstop	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private tabstop = 2$/;"	m
width	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public width = 0$/;"	m
nvim	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^    private nvim: Neovim,$/;"	m
buffer	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^    public buffer: Buffer,$/;"	m
window	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^    private window?: Window$/;"	m
getHeight	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public getHeight(docs: Documentation[], maxWidth: number): number {$/;"	m
valid	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public get valid(): Promise<boolean> {$/;"	m
calculateFragments	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public calculateFragments(docs: Documentation[], maxWidth: number): Fragment[] {$/;"	m
getWidth	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private getWidth(line: string): number {$/;"	m
setDocuments	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public async setDocuments(docs: Documentation[], maxWidth: number): Promise<void> {$/;"	m
splitFragment	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public splitFragment(fragment: Fragment, defaultFileType: string): Fragment[] {$/;"	m
fixFiletype	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  private fixFiletype(filetype: string): string {$/;"	m
setLines	nvim/plugged/coc.nvim/src/model/floatBuffer.ts	/^  public setLines(): void {$/;"	m
LastChangeType	nvim/plugged/coc.nvim/src/model/document.ts	/^export type LastChangeType = 'insert' | 'change' | 'delete'$/;"	t
Document	nvim/plugged/coc.nvim/src/model/document.ts	/^export default class Document {$/;"	c
paused	nvim/plugged/coc.nvim/src/model/document.ts	/^  public paused = false$/;"	m
buftype	nvim/plugged/coc.nvim/src/model/document.ts	/^  public buftype: string$/;"	m
isIgnored	nvim/plugged/coc.nvim/src/model/document.ts	/^  public isIgnored = false$/;"	m
chars	nvim/plugged/coc.nvim/src/model/document.ts	/^  public chars: Chars$/;"	m
textDocument	nvim/plugged/coc.nvim/src/model/document.ts	/^  public textDocument: TextDocument$/;"	m
fireContentChanges	nvim/plugged/coc.nvim/src/model/document.ts	/^  public fireContentChanges: Function & { clear(): void }$/;"	m
fetchContent	nvim/plugged/coc.nvim/src/model/document.ts	/^  public fetchContent: Function & { clear(): void }$/;"	m
colorId	nvim/plugged/coc.nvim/src/model/document.ts	/^  private colorId = 1080$/;"	m
nvim	nvim/plugged/coc.nvim/src/model/document.ts	/^  private nvim: Neovim$/;"	m
eol	nvim/plugged/coc.nvim/src/model/document.ts	/^  private eol = true$/;"	m
attached	nvim/plugged/coc.nvim/src/model/document.ts	/^  private attached = false$/;"	m
variables	nvim/plugged/coc.nvim/src/model/document.ts	/^  private variables: { [key: string]: any }$/;"	m
lines	nvim/plugged/coc.nvim/src/model/document.ts	/^  private lines: string[] = []$/;"	m
_filetype	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _filetype: string$/;"	m
_uri	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _uri: string$/;"	m
_changedtick	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _changedtick: number$/;"	m
_words	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _words: string[] = []$/;"	m
_onDocumentChange	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _onDocumentChange = new Emitter<DidChangeTextDocumentParams>()$/;"	m
_onDocumentDetach	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _onDocumentDetach = new Emitter<string>()$/;"	m
onDocumentChange	nvim/plugged/coc.nvim/src/model/document.ts	/^  public readonly onDocumentChange: Event<DidChangeTextDocumentParams> = this._onDocumentChange.event$/;"	m
onDocumentDetach	nvim/plugged/coc.nvim/src/model/document.ts	/^  public readonly onDocumentDetach: Event<string> = this._onDocumentDetach.event$/;"	m
buffer	nvim/plugged/coc.nvim/src/model/document.ts	/^    public readonly buffer: Buffer,$/;"	m
env	nvim/plugged/coc.nvim/src/model/document.ts	/^    private env: Env) {$/;"	m
shouldAttach	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get shouldAttach(): boolean {$/;"	m
enabled	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get enabled(): boolean {$/;"	m
words	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get words(): string[] {$/;"	m
convertFiletype	nvim/plugged/coc.nvim/src/model/document.ts	/^  public convertFiletype(filetype: string): string {$/;"	m
changedtick	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get changedtick(): number {$/;"	m
schema	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get schema(): string {$/;"	m
lineCount	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get lineCount(): number {$/;"	m
init	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async init(nvim: Neovim, token: CancellationToken): Promise<boolean> {$/;"	m
attach	nvim/plugged/coc.nvim/src/model/document.ts	/^  private async attach(): Promise<boolean> {$/;"	m
onChange	nvim/plugged/coc.nvim/src/model/document.ts	/^  private onChange($/;"	m
checkDocument	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async checkDocument(): Promise<void> {$/;"	m
dirty	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get dirty(): boolean {$/;"	m
_fireContentChanges	nvim/plugged/coc.nvim/src/model/document.ts	/^  private _fireContentChanges(force = false): void {$/;"	m
bufnr	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get bufnr(): number {$/;"	m
content	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get content(): string {$/;"	m
filetype	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get filetype(): string {$/;"	m
uri	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get uri(): string {$/;"	m
version	nvim/plugged/coc.nvim/src/model/document.ts	/^  public get version(): number {$/;"	m
applyEdits	nvim/plugged/coc.nvim/src/model/document.ts	/^  public applyEdits(textEdit: TextEdit[], sync?: boolean): Promise<void>$/;"	m
applyEdits	nvim/plugged/coc.nvim/src/model/document.ts	/^  public applyEdits(nvim: Neovim, textEdit: TextEdit[], sync?: boolean): Promise<void>$/;"	m
applyEdits	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async applyEdits(nvim: Neovim | TextEdit[], _edits: TextEdit[] | boolean, sync = true): Promise<void> {$/;"	m
changeLines	nvim/plugged/coc.nvim/src/model/document.ts	/^  public changeLines(lines: [number, string][], sync = true, check = false): void {$/;"	m
forceSync	nvim/plugged/coc.nvim/src/model/document.ts	/^  public forceSync(ignorePause = true): void {$/;"	m
getOffset	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getOffset(lnum: number, col: number): number {$/;"	m
isWord	nvim/plugged/coc.nvim/src/model/document.ts	/^  public isWord(word: string): boolean {$/;"	m
getMoreWords	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getMoreWords(): string[] {$/;"	m
getWordRangeAtPosition	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getWordRangeAtPosition(position: Position, extraChars?: string, current = true): Range | null {$/;"	m
gitCheck	nvim/plugged/coc.nvim/src/model/document.ts	/^  private gitCheck(): void {$/;"	m
createDocument	nvim/plugged/coc.nvim/src/model/document.ts	/^  private createDocument(changeCount = 1): void {$/;"	m
_fetchContent	nvim/plugged/coc.nvim/src/model/document.ts	/^  private async _fetchContent(): Promise<void> {$/;"	m
patchChange	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async patchChange(): Promise<void> {$/;"	m
patchChangedTick	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async patchChangedTick(): Promise<void> {$/;"	m
getSymbolRanges	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getSymbolRanges(word: string): Range[] {$/;"	m
fixStartcol	nvim/plugged/coc.nvim/src/model/document.ts	/^  public fixStartcol(position: Position, valids: string[]): number {$/;"	m
matchAddRanges	nvim/plugged/coc.nvim/src/model/document.ts	/^  public matchAddRanges(ranges: Range[], hlGroup: string, priority = 10): number[] {$/;"	m
highlightRanges	nvim/plugged/coc.nvim/src/model/document.ts	/^  public highlightRanges(ranges: Range[], hlGroup: string, srcId: number, priority = 10): number[] {$/;"	m
clearMatchIds	nvim/plugged/coc.nvim/src/model/document.ts	/^  public clearMatchIds(ids: Set<number> | number[]): void {$/;"	m
getcwd	nvim/plugged/coc.nvim/src/model/document.ts	/^  public async getcwd(): Promise<string> {$/;"	m
getline	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getline(line: number, current = true): string {$/;"	m
getLines	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getLines(start: number, end: number): string[] {$/;"	m
getDocumentContent	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getDocumentContent(): string {$/;"	m
getVar	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getVar<T>(key: string, defaultValue?: T): T {$/;"	m
getPosition	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getPosition(lnum: number, col: number): Position {$/;"	m
getEndOffset	nvim/plugged/coc.nvim/src/model/document.ts	/^  private getEndOffset(lnum: number, col: number, insert: boolean): number {$/;"	m
setFiletype	nvim/plugged/coc.nvim/src/model/document.ts	/^  public setFiletype(filetype: string): void {$/;"	m
setIskeyword	nvim/plugged/coc.nvim/src/model/document.ts	/^  public setIskeyword(iskeyword: string): void {$/;"	m
detach	nvim/plugged/coc.nvim/src/model/document.ts	/^  public detach(): void {$/;"	m
getLocalifyBonus	nvim/plugged/coc.nvim/src/model/document.ts	/^  public getLocalifyBonus(sp: Position, ep: Position): Map<string, number> {$/;"	m
download	nvim/plugged/coc.nvim/src/model/download.ts	/^export default function download(url: string, options: DownloadOptions): Promise<void> {$/;"	f
download	nvim/plugged/coc.nvim/src/model/download.ts	/^export default function download(url: string, options: DownloadOptions): Promise<void> {$/;"	f
download	nvim/plugged/coc.nvim/src/model/download.ts	/^export default function download(url: string, options: DownloadOptions): Promise<void> {$/;"	f
Popup	nvim/plugged/coc.nvim/src/model/popup.ts	/^export class Popup {$/;"	c
id	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public id: number$/;"	m
bufferId	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public bufferId: number$/;"	m
create	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public async create(text: string[] | TextItem[], options: PopupOptions): Promise<void> {$/;"	m
hide	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public hide(): void {$/;"	m
valid	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public async valid(): Promise<boolean> {$/;"	m
visible	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public async visible(): Promise<boolean> {$/;"	m
show	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public show(): void {$/;"	m
move	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public move(options: Partial<PopupOptions>): void {$/;"	m
getPosition	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public async getPosition(): Promise<any> {$/;"	m
setFiletype	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public setFiletype(filetype: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/popup.ts	/^  public dispose(): void {$/;"	m
createPopup	nvim/plugged/coc.nvim/src/model/popup.ts	/^export default async function createPopup(nvim: Neovim, text: string[] | TextItem[], options: PopupOptions): Promise<Popup> {$/;"	f
Memos	nvim/plugged/coc.nvim/src/model/memos.ts	/^export default class Memos {$/;"	c
fetchContent	nvim/plugged/coc.nvim/src/model/memos.ts	/^  private fetchContent(id: string, key: string): any {$/;"	m
update	nvim/plugged/coc.nvim/src/model/memos.ts	/^  private async update(id: string, key: string, value: any): Promise<void> {$/;"	m
createMemento	nvim/plugged/coc.nvim/src/model/memos.ts	/^  public createMemento(id: string): Memento {$/;"	m
Resolver	nvim/plugged/coc.nvim/src/model/resolver.ts	/^export default class Resolver {$/;"	c
nodeFolder	nvim/plugged/coc.nvim/src/model/resolver.ts	/^  private get nodeFolder(): Promise<string> {$/;"	m
yarnFolder	nvim/plugged/coc.nvim/src/model/resolver.ts	/^  private get yarnFolder(): Promise<string> {$/;"	m
resolveModule	nvim/plugged/coc.nvim/src/model/resolver.ts	/^  public async resolveModule(mod: string): Promise<string> {$/;"	m
Task	nvim/plugged/coc.nvim/src/model/task.ts	/^export default class Task implements Disposable {$/;"	c
disposables	nvim/plugged/coc.nvim/src/model/task.ts	/^  private disposables: Disposable[] = []$/;"	m
_onExit	nvim/plugged/coc.nvim/src/model/task.ts	/^  private readonly _onExit = new Emitter<number>()$/;"	m
_onStderr	nvim/plugged/coc.nvim/src/model/task.ts	/^  private readonly _onStderr = new Emitter<string[]>()$/;"	m
_onStdout	nvim/plugged/coc.nvim/src/model/task.ts	/^  private readonly _onStdout = new Emitter<string[]>()$/;"	m
onExit	nvim/plugged/coc.nvim/src/model/task.ts	/^  public readonly onExit: Event<number> = this._onExit.event$/;"	m
onStdout	nvim/plugged/coc.nvim/src/model/task.ts	/^  public readonly onStdout: Event<string[]> = this._onStdout.event$/;"	m
onStderr	nvim/plugged/coc.nvim/src/model/task.ts	/^  public readonly onStderr: Event<string[]> = this._onStderr.event$/;"	m
start	nvim/plugged/coc.nvim/src/model/task.ts	/^  public async start(opts: TaskOptions): Promise<boolean> {$/;"	m
stop	nvim/plugged/coc.nvim/src/model/task.ts	/^  public async stop(): Promise<void> {$/;"	m
running	nvim/plugged/coc.nvim/src/model/task.ts	/^  public get running(): Promise<boolean> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/task.ts	/^  public dispose(): void {$/;"	m
Range	nvim/plugged/coc.nvim/src/model/chars.ts	/^export class Range {$/;"	c
start	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public start: number$/;"	m
end	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public end: number$/;"	m
fromKeywordOption	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public static fromKeywordOption(keywordOption: string): Range[] {$/;"	m
contains	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public contains(c: number): boolean {$/;"	m
Chars	nvim/plugged/coc.nvim/src/model/chars.ts	/^export class Chars {$/;"	c
ranges	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public ranges: Range[] = []$/;"	m
addKeyword	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public addKeyword(ch: string): void {$/;"	m
clone	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public clone(): Chars {$/;"	m
setKeywordOption	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public setKeywordOption(keywordOption: string): void {$/;"	m
matchKeywords	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public matchKeywords(content: string, min = 3): string[] {$/;"	m
isKeywordCode	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public isKeywordCode(code: number): boolean {$/;"	m
isKeywordChar	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public isKeywordChar(ch: string): boolean {$/;"	m
isKeyword	nvim/plugged/coc.nvim/src/model/chars.ts	/^  public isKeyword(word: string): boolean {$/;"	m
getAgent	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export function getAgent(endpoint: UrlWithStringQuery): Agent {$/;"	f
getAgent	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export function getAgent(endpoint: UrlWithStringQuery): Agent {$/;"	f
getAgent	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export function getAgent(endpoint: UrlWithStringQuery): Agent {$/;"	f
fetch	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export default function fetch(url: string, data?: string | { [key: string]: any }, options: RequestOptions = {}): Promise<string | { [key: string]: any }> {$/;"	f
fetch	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export default function fetch(url: string, data?: string | { [key: string]: any }, options: RequestOptions = {}): Promise<string | { [key: string]: any }> {$/;"	f
fetch	nvim/plugged/coc.nvim/src/model/fetch.ts	/^export default function fetch(url: string, data?: string | { [key: string]: any }, options: RequestOptions = {}): Promise<string | { [key: string]: any }> {$/;"	f
WindowConfig	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^export interface WindowConfig {$/;"	i
FloatFactory	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^export default class FloatFactory implements Disposable {$/;"	c
targetBufnr	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private targetBufnr: number$/;"	m
window	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private window: Window$/;"	m
disposables	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private disposables: Disposable[] = []$/;"	m
floatBuffer	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private floatBuffer: FloatBuffer$/;"	m
tokenSource	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private tokenSource: CancellationTokenSource$/;"	m
alignTop	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private alignTop = false$/;"	m
pumAlignTop	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private pumAlignTop = false$/;"	m
createTs	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private createTs = 0$/;"	m
cursor	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private cursor: [number, number] = [0, 0]$/;"	m
popup	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private popup: Popup$/;"	m
shown	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public shown = false$/;"	m
env	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^    private env: Env,$/;"	m
preferTop	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^    private preferTop = false,$/;"	m
maxHeight	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^    private maxHeight = 999,$/;"	m
maxWidth	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^    private maxWidth?: number,$/;"	m
autoHide	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^    private autoHide = true) {$/;"	m
onCursorMoved	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private onCursorMoved(insertMode: boolean, bufnr: number, cursor: [number, number]): void {$/;"	m
checkFloatBuffer	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private async checkFloatBuffer(): Promise<void> {$/;"	m
columns	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private get columns(): number {$/;"	m
lines	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private get lines(): number {$/;"	m
getBoundings	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public async getBoundings(docs: Documentation[], offsetX = 0): Promise<WindowConfig> {$/;"	m
create	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public async create(docs: Documentation[], allowSelection = false, offsetX = 0): Promise<void> {$/;"	m
createPopup	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private async createPopup(docs: Documentation[], allowSelection = false, offsetX = 0): Promise<boolean> {$/;"	m
checkMode	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  private checkMode(mode: string, allowSelection: boolean): boolean {$/;"	m
close	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public close(cancel = true): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public dispose(): void {$/;"	m
buffer	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public get buffer(): Buffer {$/;"	m
activated	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^  public async activated(): Promise<boolean> {$/;"	m
cursorPostion	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^function cursorPostion(n: number): string {$/;"	f
cursorPostion	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^function cursorPostion(n: number): string {$/;"	f
cursorPostion	nvim/plugged/coc.nvim/src/model/floatFactory.ts	/^function cursorPostion(n: number): string {$/;"	f
VimSource	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^export default class VimSource extends Source {$/;"	c
callOptinalFunc	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  private async callOptinalFunc(fname: string, args: any[]): Promise<any> {$/;"	m
shouldComplete	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  public async shouldComplete(opt: CompleteOption): Promise<boolean> {$/;"	m
refresh	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  public async refresh(): Promise<void> {$/;"	m
onCompleteDone	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  public async onCompleteDone(item: VimCompleteItem, opt: CompleteOption): Promise<void> {$/;"	m
onEnter	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  public onEnter(bufnr: number): void {$/;"	m
doComplete	nvim/plugged/coc.nvim/src/model/source-vim.ts	/^  public async doComplete(opt: CompleteOption, token: CancellationToken): Promise<CompleteResult | null> {$/;"	m
Mru	nvim/plugged/coc.nvim/src/model/mru.ts	/^export default class Mru {$/;"	c
file	nvim/plugged/coc.nvim/src/model/mru.ts	/^  private file: string$/;"	m
load	nvim/plugged/coc.nvim/src/model/mru.ts	/^  public async load(): Promise<string[]> {$/;"	m
add	nvim/plugged/coc.nvim/src/model/mru.ts	/^  public async add(item: string): Promise<void> {$/;"	m
remove	nvim/plugged/coc.nvim/src/model/mru.ts	/^  public async remove(item: string): Promise<void> {$/;"	m
clean	nvim/plugged/coc.nvim/src/model/mru.ts	/^  public async clean(): Promise<void> {$/;"	m
FileSystemWatcher	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^export default class FileSystemWatcher implements Disposable {$/;"	c
_onDidCreate	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private _onDidCreate = new Emitter<URI>()$/;"	m
_onDidChange	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private _onDidChange = new Emitter<URI>()$/;"	m
_onDidDelete	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private _onDidDelete = new Emitter<URI>()$/;"	m
_onDidRename	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private _onDidRename = new Emitter<RenameEvent>()$/;"	m
onDidCreate	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  public readonly onDidCreate: Event<URI> = this._onDidCreate.event$/;"	m
onDidChange	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  public readonly onDidChange: Event<URI> = this._onDidChange.event$/;"	m
onDidDelete	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  public readonly onDidDelete: Event<URI> = this._onDidDelete.event$/;"	m
onDidRename	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  public readonly onDidRename: Event<RenameEvent> = this._onDidRename.event$/;"	m
disposables	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private disposables: Disposable[] = []$/;"	m
globPattern	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^    private globPattern: string,$/;"	m
ignoreCreateEvents	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^    public ignoreCreateEvents: boolean,$/;"	m
ignoreChangeEvents	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^    public ignoreChangeEvents: boolean,$/;"	m
ignoreDeleteEvents	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^    public ignoreDeleteEvents: boolean$/;"	m
listen	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  private async listen(client: Watchman): Promise<Disposable> {$/;"	m
dispose	nvim/plugged/coc.nvim/src/model/fileSystemWatcher.ts	/^  public dispose(): void {$/;"	m
Result	nvim/plugged/coc.nvim/src/events.ts	/^export type Result = void | Promise<void>$/;"	t
BufEvents	nvim/plugged/coc.nvim/src/events.ts	/^export type BufEvents = 'TextChangedI' | 'BufHidden' | 'BufEnter' | 'TextChanged'$/;"	t
EmptyEvents	nvim/plugged/coc.nvim/src/events.ts	/^export type EmptyEvents = 'FocusGained'$/;"	t
TextChangedEvent	nvim/plugged/coc.nvim/src/events.ts	/^export type TextChangedEvent = 'TextChanged'$/;"	t
TaskEvents	nvim/plugged/coc.nvim/src/events.ts	/^export type TaskEvents = 'TaskExit' | 'TaskStderr' | 'TaskStdout'$/;"	t
AllEvents	nvim/plugged/coc.nvim/src/events.ts	/^export type AllEvents = BufEvents | EmptyEvents | MoveEvents | TaskEvents |$/;"	t
MoveEvents	nvim/plugged/coc.nvim/src/events.ts	/^export type MoveEvents = 'CursorMoved' | 'CursorMovedI'$/;"	t
OptionValue	nvim/plugged/coc.nvim/src/events.ts	/^export type OptionValue = string | number | boolean$/;"	t
CursorPosition	nvim/plugged/coc.nvim/src/events.ts	/^export interface CursorPosition {$/;"	i
Events	nvim/plugged/coc.nvim/src/events.ts	/^class Events {$/;"	c
handlers	nvim/plugged/coc.nvim/src/events.ts	/^  private handlers: Map<string, Function[]> = new Map()$/;"	m
_cursor	nvim/plugged/coc.nvim/src/events.ts	/^  private _cursor: CursorPosition$/;"	m
insertMode	nvim/plugged/coc.nvim/src/events.ts	/^  private insertMode = false$/;"	m
cursor	nvim/plugged/coc.nvim/src/events.ts	/^  public get cursor(): CursorPosition {$/;"	m
fire	nvim/plugged/coc.nvim/src/events.ts	/^  public async fire(event: string, args: any[]): Promise<void> {$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: EmptyEvents | AllEvents[], handler: () => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: BufEvents, handler: (bufnr: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: MoveEvents, handler: (bufnr: number, cursor: [number, number]) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: TextChangedEvent, handler: (bufnr: number, changedtick: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'TaskExit', handler: (id: string, code: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'TaskStderr' | 'TaskStdout', handler: (id: string, lines: string[]) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'BufReadCmd', handler: (scheme: string, fullpath: string) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'VimResized', handler: (columns: number, lines: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'Command', handler: (name: string) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'MenuPopupChanged', handler: (event: PopupChangeEvent, cursorline: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'CompleteDone', handler: (item: VimCompleteItem) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'InsertCharPre', handler: (character: string) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'FileType', handler: (filetype: string, bufnr: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'BufWinEnter' | 'BufWinLeave', handler: (bufnr: number, winid: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'DirChanged', handler: (cwd: string) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'OptionSet' | 'GlobalChange', handler: (option: string, oldVal: OptionValue, newVal: OptionValue) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: 'InputChar', handler: (character: string, mode: number) => Result, thisArg?: any, disposables?: Disposable[]): Disposable$/;"	m
on	nvim/plugged/coc.nvim/src/events.ts	/^  public on(event: AllEvents[] | AllEvents, handler: (...args: any[]) => Result, thisArg?: any, disposables?: Disposable[]): Disposable {$/;"	m
Sources	nvim/plugged/coc.nvim/src/sources.ts	/^export class Sources {$/;"	c
sourceMap	nvim/plugged/coc.nvim/src/sources.ts	/^  private sourceMap: Map<string, ISource> = new Map()$/;"	m
disposables	nvim/plugged/coc.nvim/src/sources.ts	/^  private disposables: Disposable[] = []$/;"	m
remoteSourcePaths	nvim/plugged/coc.nvim/src/sources.ts	/^  private remoteSourcePaths: string[] = []$/;"	m
nvim	nvim/plugged/coc.nvim/src/sources.ts	/^  private get nvim(): Neovim {$/;"	m
createNativeSources	nvim/plugged/coc.nvim/src/sources.ts	/^  private async createNativeSources(): Promise<void> {$/;"	m
createVimSourceExtension	nvim/plugged/coc.nvim/src/sources.ts	/^  private async createVimSourceExtension(nvim: Neovim, filepath: string): Promise<void> {$/;"	m
createRemoteSources	nvim/plugged/coc.nvim/src/sources.ts	/^  private async createRemoteSources(): Promise<void> {$/;"	m
createVimSources	nvim/plugged/coc.nvim/src/sources.ts	/^  private async createVimSources(pluginPath: string): Promise<void> {$/;"	m
init	nvim/plugged/coc.nvim/src/sources.ts	/^  public init(): void {$/;"	m
names	nvim/plugged/coc.nvim/src/sources.ts	/^  public get names(): string[] {$/;"	m
sources	nvim/plugged/coc.nvim/src/sources.ts	/^  public get sources(): ISource[] {$/;"	m
has	nvim/plugged/coc.nvim/src/sources.ts	/^  public has(name): boolean {$/;"	m
getSource	nvim/plugged/coc.nvim/src/sources.ts	/^  public getSource(name: string): ISource | null {$/;"	m
doCompleteResolve	nvim/plugged/coc.nvim/src/sources.ts	/^  public async doCompleteResolve(item: VimCompleteItem, token: CancellationToken): Promise<void> {$/;"	m
doCompleteDone	nvim/plugged/coc.nvim/src/sources.ts	/^  public async doCompleteDone(item: VimCompleteItem, opt: CompleteOption): Promise<void> {$/;"	m
shouldCommit	nvim/plugged/coc.nvim/src/sources.ts	/^  public shouldCommit(item: VimCompleteItem, commitCharacter: string): boolean {$/;"	m
getCompleteSources	nvim/plugged/coc.nvim/src/sources.ts	/^  public getCompleteSources(opt: CompleteOption): ISource[] {$/;"	m
checkTrigger	nvim/plugged/coc.nvim/src/sources.ts	/^  public checkTrigger(source: ISource, pre: string, character: string): boolean {$/;"	m
shouldTrigger	nvim/plugged/coc.nvim/src/sources.ts	/^  public shouldTrigger(pre: string, languageId: string): boolean {$/;"	m
getTriggerSources	nvim/plugged/coc.nvim/src/sources.ts	/^  public getTriggerSources(pre: string, languageId: string): ISource[] {$/;"	m
getSourcesForFiletype	nvim/plugged/coc.nvim/src/sources.ts	/^  public getSourcesForFiletype(filetype: string, isTriggered: boolean): ISource[] {$/;"	m
addSource	nvim/plugged/coc.nvim/src/sources.ts	/^  public addSource(source: ISource): Disposable {$/;"	m
removeSource	nvim/plugged/coc.nvim/src/sources.ts	/^  public removeSource(source: ISource | string): void {$/;"	m
refresh	nvim/plugged/coc.nvim/src/sources.ts	/^  public async refresh(name?: string): Promise<void> {$/;"	m
toggleSource	nvim/plugged/coc.nvim/src/sources.ts	/^  public toggleSource(name: string): void {$/;"	m
sourceStats	nvim/plugged/coc.nvim/src/sources.ts	/^  public sourceStats(): SourceStat[] {$/;"	m
onDocumentEnter	nvim/plugged/coc.nvim/src/sources.ts	/^  private onDocumentEnter(bufnr: number): void {$/;"	m
createSource	nvim/plugged/coc.nvim/src/sources.ts	/^  public createSource(config: SourceConfig): Disposable {$/;"	m
dispose	nvim/plugged/coc.nvim/src/sources.ts	/^  public dispose(): void {$/;"	m
ConfigurationWorkspaceMiddleware	nvim/plugged/coc.nvim/src/language-client/configuration.ts	/^export interface ConfigurationWorkspaceMiddleware {$/;"	i
ConfigurationFeature	nvim/plugged/coc.nvim/src/language-client/configuration.ts	/^export class ConfigurationFeature implements StaticFeature {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/configuration.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/configuration.ts	/^  public initialize(): void {$/;"	m
getConfiguration	nvim/plugged/coc.nvim/src/language-client/configuration.ts	/^  private getConfiguration($/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ProvideImplementationSignature	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^export interface ProvideImplementationSignature {$/;"	i
ImplementationMiddleware	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^export interface ImplementationMiddleware {$/;"	i
ImplementationFeature	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^export class ImplementationFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/implementation.ts	/^  protected registerLanguageProvider(options: TextDocumentRegistrationOptions): Disposable {$/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ProvideTypeDefinitionSignature	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^export interface ProvideTypeDefinitionSignature {$/;"	i
TypeDefinitionMiddleware	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^export interface TypeDefinitionMiddleware {$/;"	i
TypeDefinitionFeature	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^export class TypeDefinitionFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/typeDefinition.ts	/^  protected registerLanguageProvider(options: TextDocumentRegistrationOptions): Disposable {$/;"	m
access	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^function access<T, K extends keyof T>(target: T | undefined, key: K): T[K] | undefined {$/;"	f
access	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^function access<T, K extends keyof T>(target: T | undefined, key: K): T[K] | undefined {$/;"	f
access	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^function access<T, K extends keyof T>(target: T | undefined, key: K): T[K] | undefined {$/;"	f
WorkspaceFolderWorkspaceMiddleware	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^export interface WorkspaceFolderWorkspaceMiddleware {$/;"	i
WorkspaceFoldersFeature	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^export class WorkspaceFoldersFeature implements DynamicFeature<undefined> {$/;"	c
_listeners	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  private _listeners: Map<string, Disposable> = new Map<string, Disposable>()$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillInitializeParams	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public fillInitializeParams(params: InitializeParams): void {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public initialize(capabilities: ServerCapabilities): void {$/;"	m
register	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public register(_message: RPCMessageType, data: RegistrationData<undefined>): void {$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/workspaceFolders.ts	/^  public dispose(): void {$/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ProvideFoldingRangeSignature	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^export type ProvideFoldingRangeSignature = ($/;"	t
FoldingRangeProviderMiddleware	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^export interface FoldingRangeProviderMiddleware {$/;"	i
FoldingRangeFeature	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^export class FoldingRangeFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/foldingRange.ts	/^  protected registerLanguageProvider($/;"	m
generateUuid	nvim/plugged/coc.nvim/src/language-client/utils/uuid.ts	/^export function generateUuid(): string {$/;"	f
generateUuid	nvim/plugged/coc.nvim/src/language-client/utils/uuid.ts	/^export function generateUuid(): string {$/;"	f
generateUuid	nvim/plugged/coc.nvim/src/language-client/utils/uuid.ts	/^export function generateUuid(): string {$/;"	f
asLanguageIds	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
asLanguageIds	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
asLanguageIds	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asLanguageIds(documentSelector: DocumentSelector): string[] {$/;"	f
convertToTextDocumentItem	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function convertToTextDocumentItem(document: TextDocument): TextDocumentItem {$/;"	f
convertToTextDocumentItem	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function convertToTextDocumentItem(document: TextDocument): TextDocumentItem {$/;"	f
convertToTextDocumentItem	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function convertToTextDocumentItem(document: TextDocument): TextDocumentItem {$/;"	f
asCloseTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCloseTextDocumentParams(document: TextDocument): DidCloseTextDocumentParams {$/;"	f
asCloseTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCloseTextDocumentParams(document: TextDocument): DidCloseTextDocumentParams {$/;"	f
asCloseTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCloseTextDocumentParams(document: TextDocument): DidCloseTextDocumentParams {$/;"	f
asChangeTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asChangeTextDocumentParams(document: TextDocument): DidChangeTextDocumentParams {$/;"	f
asChangeTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asChangeTextDocumentParams(document: TextDocument): DidChangeTextDocumentParams {$/;"	f
asChangeTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asChangeTextDocumentParams(document: TextDocument): DidChangeTextDocumentParams {$/;"	f
asWillSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asWillSaveTextDocumentParams(event: TextDocumentWillSaveEvent): WillSaveTextDocumentParams {$/;"	f
asWillSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asWillSaveTextDocumentParams(event: TextDocumentWillSaveEvent): WillSaveTextDocumentParams {$/;"	f
asWillSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asWillSaveTextDocumentParams(event: TextDocumentWillSaveEvent): WillSaveTextDocumentParams {$/;"	f
asVersionedTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asVersionedTextDocumentIdentifier(textDocument: TextDocument): VersionedTextDocumentIdentifier {$/;"	f
asVersionedTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asVersionedTextDocumentIdentifier(textDocument: TextDocument): VersionedTextDocumentIdentifier {$/;"	f
asVersionedTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asVersionedTextDocumentIdentifier(textDocument: TextDocument): VersionedTextDocumentIdentifier {$/;"	f
asSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asSaveTextDocumentParams(document: TextDocument, includeText: boolean): DidSaveTextDocumentParams {$/;"	f
asSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asSaveTextDocumentParams(document: TextDocument, includeText: boolean): DidSaveTextDocumentParams {$/;"	f
asSaveTextDocumentParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asSaveTextDocumentParams(document: TextDocument, includeText: boolean): DidSaveTextDocumentParams {$/;"	f
asUri	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asUri(resource: URI): string {$/;"	f
asUri	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asUri(resource: URI): string {$/;"	f
asUri	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asUri(resource: URI): string {$/;"	f
asCompletionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCompletionParams(textDocument: TextDocument, position: Position, context: CompletionContext): CompletionParams {$/;"	f
asCompletionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCompletionParams(textDocument: TextDocument, position: Position, context: CompletionContext): CompletionParams {$/;"	f
asCompletionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCompletionParams(textDocument: TextDocument, position: Position, context: CompletionContext): CompletionParams {$/;"	f
asTextDocumentPositionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentPositionParams(textDocument: TextDocument, position: Position): TextDocumentPositionParams {$/;"	f
asTextDocumentPositionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentPositionParams(textDocument: TextDocument, position: Position): TextDocumentPositionParams {$/;"	f
asTextDocumentPositionParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentPositionParams(textDocument: TextDocument, position: Position): TextDocumentPositionParams {$/;"	f
asTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentIdentifier(textDocument: TextDocument): TextDocumentIdentifier {$/;"	f
asTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentIdentifier(textDocument: TextDocument): TextDocumentIdentifier {$/;"	f
asTextDocumentIdentifier	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asTextDocumentIdentifier(textDocument: TextDocument): TextDocumentIdentifier {$/;"	f
asReferenceParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asReferenceParams(textDocument: TextDocument, position: Position, options: { includeDeclaration: boolean; }): ReferenceParams {$/;"	f
asReferenceParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asReferenceParams(textDocument: TextDocument, position: Position, options: { includeDeclaration: boolean; }): ReferenceParams {$/;"	f
asReferenceParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asReferenceParams(textDocument: TextDocument, position: Position, options: { includeDeclaration: boolean; }): ReferenceParams {$/;"	f
asDocumentSymbolParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asDocumentSymbolParams(textDocument: TextDocument): DocumentSymbolParams {$/;"	f
asDocumentSymbolParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asDocumentSymbolParams(textDocument: TextDocument): DocumentSymbolParams {$/;"	f
asDocumentSymbolParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asDocumentSymbolParams(textDocument: TextDocument): DocumentSymbolParams {$/;"	f
asCodeLensParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCodeLensParams(textDocument: TextDocument): CodeLensParams {$/;"	f
asCodeLensParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCodeLensParams(textDocument: TextDocument): CodeLensParams {$/;"	f
asCodeLensParams	nvim/plugged/coc.nvim/src/language-client/utils/converter.ts	/^export function asCodeLensParams(textDocument: TextDocument): CodeLensParams {$/;"	f
Task	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^export interface Task<T> {$/;"	i
Delayer	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^export class Delayer<T> implements Disposable {$/;"	c
timeout	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private timeout: any$/;"	m
completionPromise	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private completionPromise: Thenable<any> | null$/;"	m
doResolve	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private doResolve: ((value?: any | Thenable<any>) => void) | null$/;"	m
doReject	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private doReject: (err: any) => void$/;"	m
task	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private task: Task<T | Thenable<T>> | null$/;"	m
cancelTimeout	nvim/plugged/coc.nvim/src/language-client/utils/async.ts	/^  private cancelTimeout(): void {$/;"	m
IConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface IConnection {$/;"	i
ConsoleLogger	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class ConsoleLogger implements Logger {$/;"	c
error	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public error(message: string): void {$/;"	m
warn	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public warn(message: string): void {$/;"	m
info	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public info(message: string): void {$/;"	m
log	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public log(message: string): void {$/;"	m
ConnectionErrorHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface ConnectionErrorHandler {$/;"	i
ConnectionCloseHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface ConnectionCloseHandler {$/;"	i
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function createConnection($/;"	f
ErrorAction	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export enum ErrorAction {$/;"	e
CloseAction	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export enum CloseAction {$/;"	e
ErrorHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ErrorHandler {$/;"	i
DefaultErrorHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DefaultErrorHandler implements ErrorHandler {$/;"	c
restarts	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private restarts: number[]$/;"	m
error	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public error(_error: Error, _message: Message, count: number): ErrorAction {$/;"	m
closed	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public closed(): CloseAction {$/;"	m
InitializationFailedHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface InitializationFailedHandler {$/;"	i
SynchronizeOptions	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface SynchronizeOptions {$/;"	i
RevealOutputChannelOn	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export enum RevealOutputChannelOn {$/;"	e
HandleDiagnosticsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface HandleDiagnosticsSignature {$/;"	i
ProvideCompletionItemsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideCompletionItemsSignature {$/;"	i
ResolveCompletionItemSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ResolveCompletionItemSignature {$/;"	i
ProvideHoverSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideHoverSignature {$/;"	i
ProvideSignatureHelpSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideSignatureHelpSignature {$/;"	i
ProvideDefinitionSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDefinitionSignature {$/;"	i
ProvideReferencesSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideReferencesSignature {$/;"	i
ProvideDocumentHighlightsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDocumentHighlightsSignature {$/;"	i
ProvideDocumentSymbolsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDocumentSymbolsSignature {$/;"	i
ProvideWorkspaceSymbolsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideWorkspaceSymbolsSignature {$/;"	i
ProvideCodeActionsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideCodeActionsSignature {$/;"	i
ProvideCodeLensesSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideCodeLensesSignature {$/;"	i
ResolveCodeLensSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ResolveCodeLensSignature {$/;"	i
ProvideDocumentFormattingEditsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDocumentFormattingEditsSignature {$/;"	i
ProvideDocumentRangeFormattingEditsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDocumentRangeFormattingEditsSignature {$/;"	i
ProvideOnTypeFormattingEditsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideOnTypeFormattingEditsSignature {$/;"	i
PrepareRenameSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface PrepareRenameSignature {$/;"	i
ProvideRenameEditsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideRenameEditsSignature {$/;"	i
ProvideDocumentLinksSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ProvideDocumentLinksSignature {$/;"	i
ResolveDocumentLinkSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface ResolveDocumentLinkSignature {$/;"	i
NextSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface NextSignature<P, R> {$/;"	i
DidChangeConfigurationSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface DidChangeConfigurationSignature {$/;"	i
_WorkspaceMiddleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface _WorkspaceMiddleware {$/;"	i
WorkspaceMiddleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export type WorkspaceMiddleware = _WorkspaceMiddleware & ConfigurationWorkspaceMiddleware & WorkspaceFolderWorkspaceMiddleware$/;"	t
_Middleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface _Middleware {$/;"	i
Middleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export type Middleware = _Middleware &$/;"	t
LanguageClientOptions	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface LanguageClientOptions {$/;"	i
ResolvedClientOptions	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface ResolvedClientOptions {$/;"	i
State	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export enum State {$/;"	e
StateChangeEvent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface StateChangeEvent {$/;"	i
ClientState	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export enum ClientState {$/;"	e
ensure	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/client.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ResolvedTextDocumentSyncCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface ResolvedTextDocumentSyncCapabilities {$/;"	i
RegistrationData	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface RegistrationData<T> {$/;"	i
StaticFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface StaticFeature {$/;"	i
DynamicFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface DynamicFeature<T> {$/;"	i
DynamicFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^namespace DynamicFeature {$/;"	c
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is<T>(value: any): value is DynamicFeature<T> {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is<T>(value: any): value is DynamicFeature<T> {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is<T>(value: any): value is DynamicFeature<T> {$/;"	f
CreateParamsSignature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface CreateParamsSignature<E, P> {$/;"	i
OnReady	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class OnReady {$/;"	c
_used	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _used: boolean$/;"	m
isUsed	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get isUsed(): boolean {$/;"	m
resolve	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public resolve(): void {$/;"	m
reject	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public reject(error: any): void {$/;"	m
_listener	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _listener: Disposable | undefined$/;"	m
_selectors	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected _selectors: Map<string, DocumentSelector> = new Map()$/;"	m
textDocumentFilter	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public static textDocumentFilter($/;"	m
_client	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _client: BaseLanguageClient,$/;"	m
_event	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    private _event: Event<E>,$/;"	m
_type	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _type: NotificationType<P, TextDocumentRegistrationOptions>,$/;"	m
_middleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _middleware: NextSignature<E, void> | undefined,$/;"	m
_createParams	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _createParams: CreateParamsSignature<E, P>,$/;"	m
_selectorFilter	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _selectorFilter?: ($/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract messages: RPCMessageType | RPCMessageType[]$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract fillClientCapabilities(capabilities: ClientCapabilities): void$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
callback	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private callback(data: E): void {$/;"	m
notificationSent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected notificationSent(_data: E): void { }$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
DidOpenTextDocumentFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DidOpenTextDocumentFeature extends DocumentNotifiactions<DidOpenTextDocumentParams, TextDocument> {$/;"	c
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): typeof DidOpenTextDocumentNotification.type {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
notificationSent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected notificationSent(textDocument: TextDocument): void {$/;"	m
DidCloseTextDocumentFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DidCloseTextDocumentFeature extends DocumentNotifiactions<$/;"	c
_syncedDocuments	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    private _syncedDocuments: Map<string, TextDocument>$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): typeof DidCloseTextDocumentNotification.type {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
notificationSent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected notificationSent(textDocument: TextDocument): void {$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
DidChangeTextDocumentData	nvim/plugged/coc.nvim/src/language-client/client.ts	/^interface DidChangeTextDocumentData {$/;"	i
DidChangeTextDocumentFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DidChangeTextDocumentFeature$/;"	c
_listener	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _listener: Disposable | undefined$/;"	m
_changeData	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _changeData: Map<string, DidChangeTextDocumentData> = new Map<string, DidChangeTextDocumentData>()$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): typeof DidChangeTextDocumentNotification.type {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
callback	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private callback(event: DidChangeTextDocumentParams): void {$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
WillSaveFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class WillSaveFeature extends DocumentNotifiactions<WillSaveTextDocumentParams, TextDocumentWillSaveEvent> {$/;"	c
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
WillSaveWaitUntilFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class WillSaveWaitUntilFeature implements DynamicFeature<TextDocumentRegistrationOptions> {$/;"	c
_listener	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _listener: Disposable | undefined$/;"	m
_selectors	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _selectors: Map<string, DocumentSelector> = new Map<string, DocumentSelector>()$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
callback	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private callback(event: TextDocumentWillSaveEvent): void {$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
DidSaveTextDocumentFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DidSaveTextDocumentFeature extends DocumentNotifiactions<$/;"	c
_includeText	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _includeText: boolean$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
FileSystemWatcherFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class FileSystemWatcherFeature$/;"	c
_watchers	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _watchers: Map<string, Disposable[]> = new Map<string, Disposable[]>()$/;"	m
_notifyFileEvent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    private _notifyFileEvent: (event: FileEvent) => void$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
registerRaw	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public registerRaw(id: string, fileSystemWatchers: FileWatcher[]) {$/;"	m
hookListeners	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private hookListeners($/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
TextDocumentFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export abstract class TextDocumentFeature<$/;"	c
_providers	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected _providers: Map<string, Disposable> = new Map<string, Disposable>()$/;"	m
_client	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _client: BaseLanguageClient,$/;"	m
_message	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    private _message: RPCMessageType$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract fillClientCapabilities(capabilities: ClientCapabilities): void$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register(message: RPCMessageType, data: RegistrationData<T>): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected abstract registerLanguageProvider(languageIds: T): Disposable$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
_providers	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected _providers: Map<string, Disposable> = new Map<string, Disposable>()$/;"	m
_client	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    protected _client: BaseLanguageClient,$/;"	m
_message	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    private _message: RPCMessageType$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract fillClientCapabilities(capabilities: ClientCapabilities): void$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public abstract initialize($/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register(message: RPCMessageType, data: RegistrationData<T>): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected abstract registerLanguageProvider(options: T): Disposable$/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
CompletionItemFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class CompletionItemFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
HoverFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class HoverFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
SignatureHelpFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class SignatureHelpFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DefinitionFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DefinitionFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
ReferencesFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class ReferencesFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DocumentHighlightFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentHighlightFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DocumentSymbolFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentSymbolFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
WorkspaceSymbolFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class WorkspaceSymbolFeature extends WorkspaceFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider(options: TextDocumentRegistrationOptions): Disposable {$/;"	m
CodeActionFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class CodeActionFeature extends TextDocumentFeature<CodeActionRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
CodeLensFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class CodeLensFeature extends TextDocumentFeature<CodeLensRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DocumentFormattingFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentFormattingFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DocumentRangeFormattingFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentRangeFormattingFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
DocumentOnTypeFormattingFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentOnTypeFormattingFeature extends TextDocumentFeature<DocumentOnTypeFormattingRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider(options: DocumentOnTypeFormattingRegistrationOptions): Disposable {$/;"	m
RenameFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class RenameFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider(options: RenameRegistrationOptions): Disposable {$/;"	m
DocumentLinkFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class DocumentLinkFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerLanguageProvider($/;"	m
ConfigurationFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class ConfigurationFeature$/;"	c
_listeners	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _listeners: Map<string, Disposable> = new Map<string, Disposable>()$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize(): void {$/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
onDidChangeConfiguration	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private onDidChangeConfiguration(configurationSection: string | string[]): void {$/;"	m
getConfiguredSettings	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private getConfiguredSettings(key: string): any {$/;"	m
extractSettingsInformation	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private extractSettingsInformation(keys: string[]): any {$/;"	m
ensurePath	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    function ensurePath(config: any, path: string[]): any {$/;"	f
ensurePath	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    function ensurePath(config: any, path: string[]): any {$/;"	f
ensurePath	nvim/plugged/coc.nvim/src/language-client/client.ts	/^    function ensurePath(config: any, path: string[]): any {$/;"	f
getMiddleware	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private getMiddleware() {$/;"	m
ExecuteCommandFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^class ExecuteCommandFeature$/;"	c
_commands	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _commands: Map<string, Disposable[]> = new Map<string, Disposable[]>()$/;"	m
messages	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get messages(): RPCMessageType {$/;"	m
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public fillClientCapabilities(capabilities: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public initialize(capabilities: ServerCapabilities): void {$/;"	m
register	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public register($/;"	m
unregister	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public unregister(id: string): void {$/;"	m
dispose	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public dispose(): void {$/;"	m
MessageTransports	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export interface MessageTransports {$/;"	i
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is(value: any): value is MessageTransports {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is(value: any): value is MessageTransports {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  export function is(value: any): value is MessageTransports {$/;"	f
BaseLanguageClient	nvim/plugged/coc.nvim/src/language-client/client.ts	/^export abstract class BaseLanguageClient {$/;"	c
_id	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _id: string$/;"	m
_name	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _name: string$/;"	m
_clientOptions	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _clientOptions: Lazy<ResolvedClientOptions>$/;"	m
_state	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected _state: ClientState$/;"	m
_onReady	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _onReady: Promise<void>$/;"	m
_onReadyCallbacks	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _onReadyCallbacks: OnReady$/;"	m
_onStop	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _onStop: Thenable<void> | undefined$/;"	m
_connectionPromise	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _connectionPromise: Thenable<IConnection> | undefined$/;"	m
_resolvedConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _resolvedConnection: IConnection | undefined$/;"	m
_initializeResult	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _initializeResult: InitializeResult | undefined$/;"	m
_disposeOutputChannel	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _disposeOutputChannel: boolean$/;"	m
_outputChannel	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _outputChannel: OutputChannel | undefined$/;"	m
_capabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _capabilities: ServerCapabilities &$/;"	m
_listeners	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _listeners: Disposable[] | undefined$/;"	m
_providers	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _providers: Disposable[] | undefined$/;"	m
_diagnostics	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _diagnostics: DiagnosticCollection | undefined$/;"	m
_syncedDocuments	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _syncedDocuments: Map<string, TextDocument>$/;"	m
_fileEvents	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _fileEvents: FileEvent[]$/;"	m
_fileEventDelayer	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _fileEventDelayer: Delayer<void>$/;"	m
_stateChangeEmitter	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _stateChangeEmitter: Emitter<StateChangeEvent>$/;"	m
_traceFormat	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _traceFormat: TraceFormat$/;"	m
_trace	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _trace: Trace$/;"	m
_tracer	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _tracer: Tracer$/;"	m
constructor	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public constructor($/;"	m
state	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private get state(): ClientState {$/;"	m
id	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get id(): string {$/;"	m
name	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get name(): string {$/;"	m
state	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private set state(value: ClientState) {$/;"	m
getPublicState	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public getPublicState(): State {$/;"	m
initializeResult	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get initializeResult(): InitializeResult | undefined {$/;"	m
sendRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendRequest<R, E, RO>($/;"	m
sendRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendRequest<P, R, E, RO>($/;"	m
sendRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendRequest<R>(method: string, token?: CancellationToken): Thenable<R>$/;"	m
sendRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendRequest<R>($/;"	m
sendRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendRequest<R>($/;"	m
onRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onRequest<R, E, RO>($/;"	m
onRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onRequest<P, R, E, RO>($/;"	m
onRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onRequest<R, E>($/;"	m
onRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onRequest<R, E>($/;"	m
sendNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendNotification<RO>(type: NotificationType0<RO>): void$/;"	m
sendNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendNotification<P, RO>($/;"	m
sendNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendNotification(method: string): void$/;"	m
sendNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendNotification(method: string, params: any): void$/;"	m
sendNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public sendNotification<P>(type: string | RPCMessageType, params?: P): void {$/;"	m
onNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onNotification<RO>(type: NotificationType0<RO>, handler: NotificationHandler0): void$/;"	m
onNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onNotification<P, RO>($/;"	m
onNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onNotification($/;"	m
onNotification	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onNotification($/;"	m
clientOptions	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get clientOptions(): LanguageClientOptions {$/;"	m
onDidChangeState	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get onDidChangeState(): Event<StateChangeEvent> {$/;"	m
outputChannel	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get outputChannel(): OutputChannel {$/;"	m
diagnostics	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get diagnostics(): DiagnosticCollection | undefined {$/;"	m
createDefaultErrorHandler	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public createDefaultErrorHandler(): ErrorHandler {$/;"	m
trace	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public set trace(value: Trace) {$/;"	m
logObjectTrace	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private logObjectTrace(data: any): void {$/;"	m
data2String	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private data2String(data: any): string {$/;"	m
_appendOutput	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private _appendOutput(type: string, message: string, data?: any): void {$/;"	m
info	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public info(message: string, data?: any): void {$/;"	m
warn	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public warn(message: string, data?: any): void {$/;"	m
error	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public error(message: string, data?: any): void {$/;"	m
logTrace	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private logTrace(message: string, data?: any): void {$/;"	m
needsStart	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public needsStart(): boolean {$/;"	m
needsStop	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public needsStop(): boolean {$/;"	m
onReady	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public onReady(): Promise<void> {$/;"	m
started	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public get started(): boolean {$/;"	m
isConnectionActive	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private isConnectionActive(): boolean {$/;"	m
start	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public start(): Disposable {$/;"	m
resolveConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private resolveConnection(): Thenable<IConnection> {$/;"	m
resolveRootPath	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private resolveRootPath(): string | null {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private initialize(connection: IConnection): Thenable<InitializeResult> {$/;"	m
stop	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public stop(): Thenable<void> {$/;"	m
cleanUp	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private cleanUp(channel: boolean = true, diagnostics: boolean = true): void {$/;"	m
notifyFileEvent	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private notifyFileEvent(event: FileEvent): void {$/;"	m
forceDocumentSync	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private forceDocumentSync(): void {$/;"	m
handleDiagnostics	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private handleDiagnostics(params: PublishDiagnosticsParams) {$/;"	m
setDiagnostics	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private setDiagnostics(uri: string, diagnostics: Diagnostic[] | undefined) {$/;"	m
createMessageTransports	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected abstract createMessageTransports($/;"	m
createConnection	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private createConnection(): Thenable<IConnection> {$/;"	m
handleConnectionClosed	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected handleConnectionClosed() {$/;"	m
restart	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public restart(): void {$/;"	m
handleConnectionError	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private handleConnectionError(error: Error, message: Message, count: number) {$/;"	m
hookConfigurationChanged	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private hookConfigurationChanged(connection: IConnection): void {$/;"	m
refreshTrace	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private refreshTrace($/;"	m
hookFileEvents	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private hookFileEvents(_connection: IConnection): void {$/;"	m
_features	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private readonly _features: (StaticFeature | DynamicFeature<any>)[] = []$/;"	m
_method2Message	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private readonly _method2Message: Map<string, RPCMessageType> = new Map<$/;"	m
_dynamicFeatures	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private readonly _dynamicFeatures: Map<string, DynamicFeature<any>> = new Map<$/;"	m
registerFeatures	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public registerFeatures($/;"	m
registerFeature	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public registerFeature(feature: StaticFeature | DynamicFeature<any>): void {$/;"	m
registerBuiltinFeatures	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  protected registerBuiltinFeatures() {$/;"	m
fillInitializeParams	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private fillInitializeParams(params: InitializeParams): void {$/;"	m
computeClientCapabilities	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private computeClientCapabilities(): ClientCapabilities {$/;"	m
initializeFeatures	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private initializeFeatures(_connection: IConnection): void {$/;"	m
handleRegistrationRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private handleRegistrationRequest($/;"	m
handleUnregistrationRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private handleUnregistrationRequest($/;"	m
handleApplyWorkspaceEdit	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  private handleApplyWorkspaceEdit($/;"	m
logFailedRequest	nvim/plugged/coc.nvim/src/language-client/client.ts	/^  public logFailedRequest(type: RPCMessageType, error: any): void {$/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
SelectionRangeProviderMiddleware	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^export interface SelectionRangeProviderMiddleware {$/;"	i
ProvideSelectionRangeSignature	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^export interface ProvideSelectionRangeSignature {$/;"	i
SelectionRangeFeature	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^export class SelectionRangeFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities & SelectionRangeClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^  public initialize(capabilities: ServerCapabilities & SelectionRangeServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/selectionRange.ts	/^  protected registerLanguageProvider(options: TextDocumentRegistrationOptions): Disposable {$/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ProvideDocumentColorsSignature	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^export type ProvideDocumentColorsSignature = (document: TextDocument, token: CancellationToken) => ProviderResult<ColorInformation[]>$/;"	t
ProvideColorPresentationSignature	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^export type ProvideColorPresentationSignature = ($/;"	t
ColorProviderMiddleware	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^export interface ColorProviderMiddleware {$/;"	i
ColorProviderFeature	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^export class ColorProviderFeature extends TextDocumentFeature<$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^  public initialize($/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/colorProvider.ts	/^  protected registerLanguageProvider($/;"	m
ensure	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ensure	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^function ensure<T, K extends keyof T>(target: T, key: K): T[K] {$/;"	f
ProvideDeclarationSignature	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^export interface ProvideDeclarationSignature {$/;"	i
DeclarationMiddleware	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^export interface DeclarationMiddleware {$/;"	i
DeclarationFeature	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^export class DeclarationFeature extends TextDocumentFeature<TextDocumentRegistrationOptions> {$/;"	c
fillClientCapabilities	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^  public fillClientCapabilities(capabilites: ClientCapabilities): void {$/;"	m
initialize	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^  public initialize(capabilities: ServerCapabilities, documentSelector: DocumentSelector): void {$/;"	m
registerLanguageProvider	nvim/plugged/coc.nvim/src/language-client/declaration.ts	/^  protected registerLanguageProvider(options: TextDocumentRegistrationOptions): Disposable {$/;"	m
SpawnOptions	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface SpawnOptions {$/;"	i
Executable	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface Executable {$/;"	i
Executable	nvim/plugged/coc.nvim/src/language-client/index.ts	/^namespace Executable {$/;"	c
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is Executable {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is Executable {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is Executable {$/;"	f
ForkOptions	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface ForkOptions {$/;"	i
TransportKind	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export enum TransportKind {$/;"	e
SocketTransport	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface SocketTransport {$/;"	i
Transport	nvim/plugged/coc.nvim/src/language-client/index.ts	/^namespace Transport {$/;"	c
isSocket	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function isSocket(value: Transport): value is SocketTransport {$/;"	f
isSocket	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function isSocket(value: Transport): value is SocketTransport {$/;"	f
isSocket	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function isSocket(value: Transport): value is SocketTransport {$/;"	f
Transport	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export type Transport = TransportKind | SocketTransport$/;"	t
NodeModule	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface NodeModule {$/;"	i
NodeModule	nvim/plugged/coc.nvim/src/language-client/index.ts	/^namespace NodeModule {$/;"	c
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is NodeModule {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is NodeModule {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is NodeModule {$/;"	f
StreamInfo	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface StreamInfo {$/;"	i
StreamInfo	nvim/plugged/coc.nvim/src/language-client/index.ts	/^namespace StreamInfo {$/;"	c
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is StreamInfo {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is StreamInfo {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is StreamInfo {$/;"	f
ChildProcessInfo	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface ChildProcessInfo {$/;"	i
ChildProcessInfo	nvim/plugged/coc.nvim/src/language-client/index.ts	/^namespace ChildProcessInfo {$/;"	c
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is ChildProcessInfo {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is ChildProcessInfo {$/;"	f
is	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function is(value: any): value is ChildProcessInfo {$/;"	f
ServerOptions	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export type ServerOptions =$/;"	t
DeferredLanguageClientServerOptions	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export interface DeferredLanguageClientServerOptions {$/;"	i
LanguageClient	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export class LanguageClient extends BaseLanguageClient {$/;"	c
_forceDebug	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _forceDebug: boolean$/;"	m
_serverProcess	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _serverProcess: ChildProcess | undefined$/;"	m
_isDetached	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _isDetached: boolean | undefined$/;"	m
_options	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _options: () => [LanguageClientOptions, ServerOptions]$/;"	m
constructor	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public constructor($/;"	m
constructor	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public constructor($/;"	m
constructor	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public constructor($/;"	m
constructor	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public constructor($/;"	m
stop	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public stop(): Thenable<void> {$/;"	m
serviceState	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public get serviceState(): ServiceStat {$/;"	m
stateName	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public static stateName(state: ClientState): string {$/;"	m
checkProcessDied	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private checkProcessDied(childProcess: ChildProcess | undefined): void {$/;"	m
handleConnectionClosed	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  protected handleConnectionClosed(): void {$/;"	m
createMessageTransports	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  protected async createMessageTransports(encoding: string): Promise<MessageTransports | null> {$/;"	m
getEnvironment	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function getEnvironment(env: any): any {$/;"	f
getEnvironment	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function getEnvironment(env: any): any {$/;"	f
getEnvironment	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function getEnvironment(env: any): any {$/;"	f
startedInDebugMode	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function startedInDebugMode(): boolean {$/;"	f
startedInDebugMode	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function startedInDebugMode(): boolean {$/;"	f
startedInDebugMode	nvim/plugged/coc.nvim/src/language-client/index.ts	/^    function startedInDebugMode(): boolean {$/;"	f
registerProposedFeatures	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public registerProposedFeatures(): void {$/;"	m
registerBuiltinFeatures	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  protected registerBuiltinFeatures(): void {$/;"	m
_getServerWorkingDir	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _getServerWorkingDir(options?: { cwd?: string }): Promise<string | undefined> {$/;"	m
appendOutput	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private appendOutput(data: any, encoding: string): void {$/;"	m
SettingMonitor	nvim/plugged/coc.nvim/src/language-client/index.ts	/^export class SettingMonitor {$/;"	c
_listeners	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private _listeners: Disposable[]$/;"	m
start	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  public start(): Disposable {$/;"	m
onDidChangeConfiguration	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  private onDidChangeConfiguration(): void {$/;"	m
createAll	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function createAll(_client: BaseLanguageClient): (StaticFeature | DynamicFeature<any>)[] {$/;"	f
createAll	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function createAll(_client: BaseLanguageClient): (StaticFeature | DynamicFeature<any>)[] {$/;"	f
createAll	nvim/plugged/coc.nvim/src/language-client/index.ts	/^  export function createAll(_client: BaseLanguageClient): (StaticFeature | DynamicFeature<any>)[] {$/;"	f
value	nvim/plugged/coc.nvim/build/index.js	/^  value: function () {$/;"	M
msg	nvim/plugged/coc.nvim/build/index.js	/^  let msg = 'Uncaught exception: ' + err.stack$/;"	V
debug	nvim/plugged/coc.nvim/build/index.js	/^  debug = function () {$/;"	M
debug	nvim/plugged/coc.nvim/build/index.js	/^  debug = function () {}$/;"	M
MAX_LENGTH	nvim/plugged/coc.nvim/build/index.js	/^var MAX_LENGTH = 256$/;"	V
MAX_SAFE_COMPONENT_LENGTH	nvim/plugged/coc.nvim/build/index.js	/^var MAX_SAFE_COMPONENT_LENGTH = 16$/;"	V
R	nvim/plugged/coc.nvim/build/index.js	/^var R = 0$/;"	V
tok	nvim/plugged/coc.nvim/build/index.js	/^function tok (n) {$/;"	F
tildeTrimReplace	nvim/plugged/coc.nvim/build/index.js	/^var tildeTrimReplace = '$1~'$/;"	V
caretTrimReplace	nvim/plugged/coc.nvim/build/index.js	/^var caretTrimReplace = '$1^'$/;"	V
comparatorTrimReplace	nvim/plugged/coc.nvim/build/index.js	/^var comparatorTrimReplace = '$1$2$3'$/;"	V
parse	nvim/plugged/coc.nvim/build/index.js	/^function parse (version, options) {$/;"	F
includePrerelease	nvim/plugged/coc.nvim/build/index.js	/^      includePrerelease: false$/;"	P
valid	nvim/plugged/coc.nvim/build/index.js	/^function valid (version, options) {$/;"	F
clean	nvim/plugged/coc.nvim/build/index.js	/^function clean (version, options) {$/;"	F
SemVer	nvim/plugged/coc.nvim/build/index.js	/^function SemVer (version, options) {$/;"	F
includePrerelease	nvim/plugged/coc.nvim/build/index.js	/^      includePrerelease: false$/;"	P
format	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.format = function () {$/;"	M
toString	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.toString = function () {$/;"	M
compare	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.compare = function (other) {$/;"	M
compareMain	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.compareMain = function (other) {$/;"	M
comparePre	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.comparePre = function (other) {$/;"	M
i	nvim/plugged/coc.nvim/build/index.js	/^  var i = 0$/;"	V
compareBuild	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.compareBuild = function (other) {$/;"	M
i	nvim/plugged/coc.nvim/build/index.js	/^  var i = 0$/;"	V
inc	nvim/plugged/coc.nvim/build/index.js	/^SemVer.prototype.inc = function (release, identifier) {$/;"	M
inc	nvim/plugged/coc.nvim/build/index.js	/^function inc (version, release, loose, identifier) {$/;"	F
diff	nvim/plugged/coc.nvim/build/index.js	/^function diff (version1, version2) {$/;"	F
prefix	nvim/plugged/coc.nvim/build/index.js	/^    var prefix = ''$/;"	V
defaultResult	nvim/plugged/coc.nvim/build/index.js	/^      var defaultResult = 'prerelease'$/;"	V
numeric	nvim/plugged/coc.nvim/build/index.js	/^var numeric = \/^[0-9]+$\/$/;"	V
compareIdentifiers	nvim/plugged/coc.nvim/build/index.js	/^function compareIdentifiers (a, b) {$/;"	F
rcompareIdentifiers	nvim/plugged/coc.nvim/build/index.js	/^function rcompareIdentifiers (a, b) {$/;"	F
major	nvim/plugged/coc.nvim/build/index.js	/^function major (a, loose) {$/;"	F
minor	nvim/plugged/coc.nvim/build/index.js	/^function minor (a, loose) {$/;"	F
patch	nvim/plugged/coc.nvim/build/index.js	/^function patch (a, loose) {$/;"	F
compare	nvim/plugged/coc.nvim/build/index.js	/^function compare (a, b, loose) {$/;"	F
compareLoose	nvim/plugged/coc.nvim/build/index.js	/^function compareLoose (a, b) {$/;"	F
compareBuild	nvim/plugged/coc.nvim/build/index.js	/^function compareBuild (a, b, loose) {$/;"	F
versionA	nvim/plugged/coc.nvim/build/index.js	/^  var versionA = new SemVer(a, loose)$/;"	V
versionB	nvim/plugged/coc.nvim/build/index.js	/^  var versionB = new SemVer(b, loose)$/;"	V
rcompare	nvim/plugged/coc.nvim/build/index.js	/^function rcompare (a, b, loose) {$/;"	F
sort	nvim/plugged/coc.nvim/build/index.js	/^function sort (list, loose) {$/;"	F
rsort	nvim/plugged/coc.nvim/build/index.js	/^function rsort (list, loose) {$/;"	F
gt	nvim/plugged/coc.nvim/build/index.js	/^function gt (a, b, loose) {$/;"	F
lt	nvim/plugged/coc.nvim/build/index.js	/^function lt (a, b, loose) {$/;"	F
eq	nvim/plugged/coc.nvim/build/index.js	/^function eq (a, b, loose) {$/;"	F
neq	nvim/plugged/coc.nvim/build/index.js	/^function neq (a, b, loose) {$/;"	F
gte	nvim/plugged/coc.nvim/build/index.js	/^function gte (a, b, loose) {$/;"	F
lte	nvim/plugged/coc.nvim/build/index.js	/^function lte (a, b, loose) {$/;"	F
cmp	nvim/plugged/coc.nvim/build/index.js	/^function cmp (a, op, b, loose) {$/;"	F
Comparator	nvim/plugged/coc.nvim/build/index.js	/^function Comparator (comp, options) {$/;"	F
includePrerelease	nvim/plugged/coc.nvim/build/index.js	/^      includePrerelease: false$/;"	P
ANY	nvim/plugged/coc.nvim/build/index.js	/^var ANY = {}$/;"	O
parse	nvim/plugged/coc.nvim/build/index.js	/^Comparator.prototype.parse = function (comp) {$/;"	M
toString	nvim/plugged/coc.nvim/build/index.js	/^Comparator.prototype.toString = function () {$/;"	M
test	nvim/plugged/coc.nvim/build/index.js	/^Comparator.prototype.test = function (version) {$/;"	M
intersects	nvim/plugged/coc.nvim/build/index.js	/^Comparator.prototype.intersects = function (comp, options) {$/;"	M
includePrerelease	nvim/plugged/coc.nvim/build/index.js	/^      includePrerelease: false$/;"	P
Range	nvim/plugged/coc.nvim/build/index.js	/^function Range (range, options) {$/;"	F
includePrerelease	nvim/plugged/coc.nvim/build/index.js	/^      includePrerelease: false$/;"	P
format	nvim/plugged/coc.nvim/build/index.js	/^Range.prototype.format = function () {$/;"	M
toString	nvim/plugged/coc.nvim/build/index.js	/^Range.prototype.toString = function () {$/;"	M
parseRange	nvim/plugged/coc.nvim/build/index.js	/^Range.prototype.parseRange = function (range) {$/;"	M
intersects	nvim/plugged/coc.nvim/build/index.js	/^Range.prototype.intersects = function (range, options) {$/;"	M
isSatisfiable	nvim/plugged/coc.nvim/build/index.js	/^function isSatisfiable (comparators, options) {$/;"	F
toComparators	nvim/plugged/coc.nvim/build/index.js	/^function toComparators (range, options) {$/;"	F
parseComparator	nvim/plugged/coc.nvim/build/index.js	/^function parseComparator (comp, options) {$/;"	F
isX	nvim/plugged/coc.nvim/build/index.js	/^function isX (id) {$/;"	F
replaceTildes	nvim/plugged/coc.nvim/build/index.js	/^function replaceTildes (comp, options) {$/;"	F
replaceTilde	nvim/plugged/coc.nvim/build/index.js	/^function replaceTilde (comp, options) {$/;"	F
replaceCarets	nvim/plugged/coc.nvim/build/index.js	/^function replaceCarets (comp, options) {$/;"	F
replaceCaret	nvim/plugged/coc.nvim/build/index.js	/^function replaceCaret (comp, options) {$/;"	F
replaceXRanges	nvim/plugged/coc.nvim/build/index.js	/^function replaceXRanges (comp, options) {$/;"	F
replaceXRange	nvim/plugged/coc.nvim/build/index.js	/^function replaceXRange (comp, options) {$/;"	F
replaceStars	nvim/plugged/coc.nvim/build/index.js	/^function replaceStars (comp, options) {$/;"	F
hyphenReplace	nvim/plugged/coc.nvim/build/index.js	/^function hyphenReplace ($0,$/;"	F
test	nvim/plugged/coc.nvim/build/index.js	/^Range.prototype.test = function (version) {$/;"	M
testSet	nvim/plugged/coc.nvim/build/index.js	/^function testSet (set, version, options) {$/;"	F
satisfies	nvim/plugged/coc.nvim/build/index.js	/^function satisfies (version, range, options) {$/;"	F
maxSatisfying	nvim/plugged/coc.nvim/build/index.js	/^function maxSatisfying (versions, range, options) {$/;"	F
rangeObj	nvim/plugged/coc.nvim/build/index.js	/^    var rangeObj = new Range(range, options)$/;"	V
minSatisfying	nvim/plugged/coc.nvim/build/index.js	/^function minSatisfying (versions, range, options) {$/;"	F
rangeObj	nvim/plugged/coc.nvim/build/index.js	/^    var rangeObj = new Range(range, options)$/;"	V
minVersion	nvim/plugged/coc.nvim/build/index.js	/^function minVersion (range, loose) {$/;"	F
minver	nvim/plugged/coc.nvim/build/index.js	/^  var minver = new SemVer('0.0.0')$/;"	V
compver	nvim/plugged/coc.nvim/build/index.js	/^      var compver = new SemVer(comparator.semver.version)$/;"	V
validRange	nvim/plugged/coc.nvim/build/index.js	/^function validRange (range, options) {$/;"	F
ltr	nvim/plugged/coc.nvim/build/index.js	/^function ltr (version, range, options) {$/;"	F
gtr	nvim/plugged/coc.nvim/build/index.js	/^function gtr (version, range, options) {$/;"	F
outside	nvim/plugged/coc.nvim/build/index.js	/^function outside (version, range, hilo, options) {$/;"	F
gtfn	nvim/plugged/coc.nvim/build/index.js	/^  var gtfn, ltefn, ltfn, comp, ecomp$/;"	V
ltefn	nvim/plugged/coc.nvim/build/index.js	/^  var gtfn, ltefn, ltfn, comp, ecomp$/;"	V
ltfn	nvim/plugged/coc.nvim/build/index.js	/^  var gtfn, ltefn, ltfn, comp, ecomp$/;"	V
ltefn	nvim/plugged/coc.nvim/build/index.js	/^        ltefn(version, low.semver)) {$/;"	M
prerelease	nvim/plugged/coc.nvim/build/index.js	/^function prerelease (version, options) {$/;"	F
intersects	nvim/plugged/coc.nvim/build/index.js	/^function intersects (r1, r2, options) {$/;"	F
coerce	nvim/plugged/coc.nvim/build/index.js	/^function coerce (version, options) {$/;"	F
getLogFile	nvim/plugged/coc.nvim/build/index.js	/^function getLogFile() {$/;"	F
MAX_LOG_SIZE	nvim/plugged/coc.nvim/build/index.js	/^const MAX_LOG_SIZE = 1024 * 1024;$/;"	V
MAX_LOG_BACKUPS	nvim/plugged/coc.nvim/build/index.js	/^const MAX_LOG_BACKUPS = 10;$/;"	V
disableClustering	nvim/plugged/coc.nvim/build/index.js	/^    disableClustering: true,$/;"	P
appenders	nvim/plugged/coc.nvim/build/index.js	/^    appenders: {$/;"	P
out	nvim/plugged/coc.nvim/build/index.js	/^        out: {$/;"	P
mode	nvim/plugged/coc.nvim/build/index.js	/^            mode: 0o666,$/;"	P
filename	nvim/plugged/coc.nvim/build/index.js	/^            filename: logfile,$/;"	P
maxLogSize	nvim/plugged/coc.nvim/build/index.js	/^            maxLogSize: MAX_LOG_SIZE,$/;"	P
backups	nvim/plugged/coc.nvim/build/index.js	/^            backups: MAX_LOG_BACKUPS,$/;"	P
layout	nvim/plugged/coc.nvim/build/index.js	/^            layout: {$/;"	P
categories	nvim/plugged/coc.nvim/build/index.js	/^    categories: {$/;"	P
default	nvim/plugged/coc.nvim/build/index.js	/^        default: { appenders: ['out'], level }$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = (name = 'coc-nvim') => {$/;"	M
getLogFile	nvim/plugged/coc.nvim/build/index.js	/^    logger.getLogFile = () => {$/;"	M
extendStatics	nvim/plugged/coc.nvim/build/index.js	/^var extendStatics = function(d, b) {$/;"	F
__extends	nvim/plugged/coc.nvim/build/index.js	/^function __extends(d, b) {$/;"	F
__	nvim/plugged/coc.nvim/build/index.js	/^    function __() { this.constructor = d; }$/;"	F
__rest	nvim/plugged/coc.nvim/build/index.js	/^function __rest(s, e) {$/;"	F
t	nvim/plugged/coc.nvim/build/index.js	/^    var t = {};$/;"	O
__decorate	nvim/plugged/coc.nvim/build/index.js	/^function __decorate(decorators, target, key, desc) {$/;"	F
__param	nvim/plugged/coc.nvim/build/index.js	/^function __param(paramIndex, decorator) {$/;"	F
__metadata	nvim/plugged/coc.nvim/build/index.js	/^function __metadata(metadataKey, metadataValue) {$/;"	F
__awaiter	nvim/plugged/coc.nvim/build/index.js	/^function __awaiter(thisArg, _arguments, P, generator) {$/;"	F
fulfilled	nvim/plugged/coc.nvim/build/index.js	/^        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }$/;"	F
rejected	nvim/plugged/coc.nvim/build/index.js	/^        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }$/;"	F
__generator	nvim/plugged/coc.nvim/build/index.js	/^function __generator(thisArg, body) {$/;"	F
_	nvim/plugged/coc.nvim/build/index.js	/^    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;$/;"	O
verb	nvim/plugged/coc.nvim/build/index.js	/^    function verb(n) { return function (v) { return step([n, v]); }; }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^    function step(op) {$/;"	F
__exportStar	nvim/plugged/coc.nvim/build/index.js	/^function __exportStar(m, exports) {$/;"	F
__values	nvim/plugged/coc.nvim/build/index.js	/^function __values(o) {$/;"	F
next	nvim/plugged/coc.nvim/build/index.js	/^        next: function () {$/;"	M
__read	nvim/plugged/coc.nvim/build/index.js	/^function __read(o, n) {$/;"	F
__spread	nvim/plugged/coc.nvim/build/index.js	/^function __spread() {$/;"	F
__spreadArrays	nvim/plugged/coc.nvim/build/index.js	/^function __spreadArrays() {$/;"	F
__await	nvim/plugged/coc.nvim/build/index.js	/^function __await(v) {$/;"	F
__asyncGenerator	nvim/plugged/coc.nvim/build/index.js	/^function __asyncGenerator(thisArg, _arguments, generator) {$/;"	F
verb	nvim/plugged/coc.nvim/build/index.js	/^    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }$/;"	F
resume	nvim/plugged/coc.nvim/build/index.js	/^    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }$/;"	F
fulfill	nvim/plugged/coc.nvim/build/index.js	/^    function fulfill(value) { resume("next", value); }$/;"	F
reject	nvim/plugged/coc.nvim/build/index.js	/^    function reject(value) { resume("throw", value); }$/;"	F
settle	nvim/plugged/coc.nvim/build/index.js	/^    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }$/;"	F
__asyncDelegator	nvim/plugged/coc.nvim/build/index.js	/^function __asyncDelegator(o) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^    var i, p;$/;"	V
p	nvim/plugged/coc.nvim/build/index.js	/^    var i, p;$/;"	V
verb	nvim/plugged/coc.nvim/build/index.js	/^    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }$/;"	F
__asyncValues	nvim/plugged/coc.nvim/build/index.js	/^function __asyncValues(o) {$/;"	F
verb	nvim/plugged/coc.nvim/build/index.js	/^    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }$/;"	F
settle	nvim/plugged/coc.nvim/build/index.js	/^    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }$/;"	F
__makeTemplateObject	nvim/plugged/coc.nvim/build/index.js	/^function __makeTemplateObject(cooked, raw) {$/;"	F
__importStar	nvim/plugged/coc.nvim/build/index.js	/^function __importStar(mod) {$/;"	F
result	nvim/plugged/coc.nvim/build/index.js	/^    var result = {};$/;"	O
__importDefault	nvim/plugged/coc.nvim/build/index.js	/^function __importDefault(mod) {$/;"	F
sendLogEventToAppender	nvim/plugged/coc.nvim/build/index.js	/^function sendLogEventToAppender(logEvent) {$/;"	F
loadConfigurationFile	nvim/plugged/coc.nvim/build/index.js	/^function loadConfigurationFile(filename) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(configurationFileOrObject) {$/;"	F
shutdown	nvim/plugged/coc.nvim/build/index.js	/^function shutdown(cb) {$/;"	F
completed	nvim/plugged/coc.nvim/build/index.js	/^  let completed = 0;$/;"	V
error	nvim/plugged/coc.nvim/build/index.js	/^  let error;$/;"	V
complete	nvim/plugged/coc.nvim/build/index.js	/^  function complete(err) {$/;"	F
getLogger	nvim/plugged/coc.nvim/build/index.js	/^function getLogger(category) {$/;"	F
appenders	nvim/plugged/coc.nvim/build/index.js	/^        appenders: { out: { type: "stdout" } },$/;"	P
categories	nvim/plugged/coc.nvim/build/index.js	/^        categories: { default: { appenders: ["out"], level: "OFF" } }$/;"	P
log4js	nvim/plugged/coc.nvim/build/index.js	/^const log4js = {$/;"	O
useColors	nvim/plugged/coc.nvim/build/index.js	/^function useColors() {$/;"	F
formatArgs	nvim/plugged/coc.nvim/build/index.js	/^function formatArgs(args) {$/;"	F
c	nvim/plugged/coc.nvim/build/index.js	/^	const c = 'color: ' + this.color;$/;"	V
index	nvim/plugged/coc.nvim/build/index.js	/^	let index = 0;$/;"	V
lastC	nvim/plugged/coc.nvim/build/index.js	/^	let lastC = 0;$/;"	V
log	nvim/plugged/coc.nvim/build/index.js	/^function log(...args) {$/;"	F
save	nvim/plugged/coc.nvim/build/index.js	/^function save(namespaces) {$/;"	F
XXX	nvim/plugged/coc.nvim/build/index.js	/^		\/\/ XXX (@Qix-) should we be logging these?$/;"	T
load	nvim/plugged/coc.nvim/build/index.js	/^function load() {$/;"	F
r	nvim/plugged/coc.nvim/build/index.js	/^	let r;$/;"	V
XXX	nvim/plugged/coc.nvim/build/index.js	/^		\/\/ XXX (@Qix-) should we be logging these?$/;"	T
localstorage	nvim/plugged/coc.nvim/build/index.js	/^function localstorage() {$/;"	F
XXX	nvim/plugged/coc.nvim/build/index.js	/^		\/\/ XXX (@Qix-) should we be logging these?$/;"	T
j	nvim/plugged/coc.nvim/build/index.js	/^formatters.j = function (v) {$/;"	M
setup	nvim/plugged/coc.nvim/build/index.js	/^function setup(env) {$/;"	F
formatters	nvim/plugged/coc.nvim/build/index.js	/^	createDebug.formatters = {};$/;"	P
selectColor	nvim/plugged/coc.nvim/build/index.js	/^	function selectColor(namespace) {$/;"	F
hash	nvim/plugged/coc.nvim/build/index.js	/^		let hash = 0;$/;"	V
hash	nvim/plugged/coc.nvim/build/index.js	/^			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);$/;"	M
createDebug	nvim/plugged/coc.nvim/build/index.js	/^	function createDebug(namespace) {$/;"	F
prevTime	nvim/plugged/coc.nvim/build/index.js	/^		let prevTime;$/;"	V
debug	nvim/plugged/coc.nvim/build/index.js	/^		function debug(...args) {$/;"	F
index	nvim/plugged/coc.nvim/build/index.js	/^			let index = 0;$/;"	V
destroy	nvim/plugged/coc.nvim/build/index.js	/^	function destroy() {$/;"	F
extend	nvim/plugged/coc.nvim/build/index.js	/^	function extend(namespace, delimiter) {$/;"	F
enable	nvim/plugged/coc.nvim/build/index.js	/^	function enable(namespaces) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^		let i;$/;"	V
disable	nvim/plugged/coc.nvim/build/index.js	/^	function disable() {$/;"	F
namespaces	nvim/plugged/coc.nvim/build/index.js	/^		const namespaces = [$/;"	A
enabled	nvim/plugged/coc.nvim/build/index.js	/^	function enabled(name) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^		let i;$/;"	V
len	nvim/plugged/coc.nvim/build/index.js	/^		let len;$/;"	V
toNamespace	nvim/plugged/coc.nvim/build/index.js	/^	function toNamespace(regexp) {$/;"	F
coerce	nvim/plugged/coc.nvim/build/index.js	/^	function coerce(val) {$/;"	F
s	nvim/plugged/coc.nvim/build/index.js	/^var s = 1000;$/;"	V
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = function(val, options) {$/;"	M
parse	nvim/plugged/coc.nvim/build/index.js	/^function parse(str) {$/;"	F
match	nvim/plugged/coc.nvim/build/index.js	/^  var match = \/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$\/i.exec($/;"	V
fmtShort	nvim/plugged/coc.nvim/build/index.js	/^function fmtShort(ms) {$/;"	F
fmtLong	nvim/plugged/coc.nvim/build/index.js	/^function fmtLong(ms) {$/;"	F
plural	nvim/plugged/coc.nvim/build/index.js	/^function plural(ms, msAbs, n, name) {$/;"	F
useColors	nvim/plugged/coc.nvim/build/index.js	/^function useColors() {$/;"	F
formatArgs	nvim/plugged/coc.nvim/build/index.js	/^function formatArgs(args) {$/;"	F
colorCode	nvim/plugged/coc.nvim/build/index.js	/^		const colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);$/;"	V
getDate	nvim/plugged/coc.nvim/build/index.js	/^function getDate() {$/;"	F
log	nvim/plugged/coc.nvim/build/index.js	/^function log(...args) {$/;"	F
save	nvim/plugged/coc.nvim/build/index.js	/^function save(namespaces) {$/;"	F
load	nvim/plugged/coc.nvim/build/index.js	/^function load() {$/;"	F
init	nvim/plugged/coc.nvim/build/index.js	/^function init(debug) {$/;"	F
inspectOpts	nvim/plugged/coc.nvim/build/index.js	/^	debug.inspectOpts = {};$/;"	P
o	nvim/plugged/coc.nvim/build/index.js	/^formatters.o = function (v) {$/;"	M
O	nvim/plugged/coc.nvim/build/index.js	/^formatters.O = function (v) {$/;"	M
forceColor	nvim/plugged/coc.nvim/build/index.js	/^let forceColor;$/;"	V
hasFlag	nvim/plugged/coc.nvim/build/index.js	/^	hasFlag('color=never')) {$/;"	M
hasFlag	nvim/plugged/coc.nvim/build/index.js	/^	hasFlag('color=always')) {$/;"	M
translateLevel	nvim/plugged/coc.nvim/build/index.js	/^function translateLevel(level) {$/;"	F
hasBasic	nvim/plugged/coc.nvim/build/index.js	/^		hasBasic: true,$/;"	P
supportsColor	nvim/plugged/coc.nvim/build/index.js	/^function supportsColor(stream) {$/;"	F
hasFlag	nvim/plugged/coc.nvim/build/index.js	/^		hasFlag('color=truecolor')) {$/;"	M
getSupportLevel	nvim/plugged/coc.nvim/build/index.js	/^function getSupportLevel(stream) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
supportsColor	nvim/plugged/coc.nvim/build/index.js	/^	supportsColor: getSupportLevel,$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = (flag, argv) => {$/;"	M
rfdc	nvim/plugged/coc.nvim/build/index.js	/^function rfdc (opts) {$/;"	F
cloneArray	nvim/plugged/coc.nvim/build/index.js	/^  function cloneArray (a, fn) {$/;"	F
a2	nvim/plugged/coc.nvim/build/index.js	/^    var a2 = new Array(keys.length)$/;"	V
clone	nvim/plugged/coc.nvim/build/index.js	/^  function clone (o) {$/;"	F
o2	nvim/plugged/coc.nvim/build/index.js	/^    var o2 = {}$/;"	O
cloneProto	nvim/plugged/coc.nvim/build/index.js	/^  function cloneProto (o) {$/;"	F
o2	nvim/plugged/coc.nvim/build/index.js	/^    var o2 = {}$/;"	O
rfdcCircles	nvim/plugged/coc.nvim/build/index.js	/^function rfdcCircles (opts) {$/;"	F
refs	nvim/plugged/coc.nvim/build/index.js	/^  var refs = []$/;"	A
refsNew	nvim/plugged/coc.nvim/build/index.js	/^  var refsNew = []$/;"	A
cloneArray	nvim/plugged/coc.nvim/build/index.js	/^  function cloneArray (a, fn) {$/;"	F
a2	nvim/plugged/coc.nvim/build/index.js	/^    var a2 = new Array(keys.length)$/;"	V
clone	nvim/plugged/coc.nvim/build/index.js	/^  function clone (o) {$/;"	F
o2	nvim/plugged/coc.nvim/build/index.js	/^    var o2 = {}$/;"	O
cloneProto	nvim/plugged/coc.nvim/build/index.js	/^  function cloneProto (o) {$/;"	F
o2	nvim/plugged/coc.nvim/build/index.js	/^    var o2 = {}$/;"	O
preProcessingListeners	nvim/plugged/coc.nvim/build/index.js	/^const preProcessingListeners = [];$/;"	A
listeners	nvim/plugged/coc.nvim/build/index.js	/^const listeners = [];$/;"	A
not	nvim/plugged/coc.nvim/build/index.js	/^const not = thing => !thing;$/;"	F
anObject	nvim/plugged/coc.nvim/build/index.js	/^const anObject = thing => thing && typeof thing === 'object' && !Array.isArray(thing);$/;"	F
validIdentifier	nvim/plugged/coc.nvim/build/index.js	/^const validIdentifier = thing => \/^[A-Za-z][A-Za-z0-9_]*$\/g.test(thing);$/;"	F
anInteger	nvim/plugged/coc.nvim/build/index.js	/^const anInteger = thing => thing && typeof thing === 'number' && Number.isInteger(thing);$/;"	F
addListener	nvim/plugged/coc.nvim/build/index.js	/^const addListener = (fn) => {$/;"	F
addPreProcessingListener	nvim/plugged/coc.nvim/build/index.js	/^const addPreProcessingListener = (fn) => {$/;"	F
throwExceptionIf	nvim/plugged/coc.nvim/build/index.js	/^const throwExceptionIf = (config, checks, message) => {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^const configure = (candidate) => {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
styles	nvim/plugged/coc.nvim/build/index.js	/^const styles = {$/;"	O
bold	nvim/plugged/coc.nvim/build/index.js	/^  bold: [1, 22],$/;"	P
italic	nvim/plugged/coc.nvim/build/index.js	/^  italic: [3, 23],$/;"	P
underline	nvim/plugged/coc.nvim/build/index.js	/^  underline: [4, 24],$/;"	P
inverse	nvim/plugged/coc.nvim/build/index.js	/^  inverse: [7, 27],$/;"	P
white	nvim/plugged/coc.nvim/build/index.js	/^  white: [37, 39],$/;"	P
grey	nvim/plugged/coc.nvim/build/index.js	/^  grey: [90, 39],$/;"	P
black	nvim/plugged/coc.nvim/build/index.js	/^  black: [90, 39],$/;"	P
blue	nvim/plugged/coc.nvim/build/index.js	/^  blue: [34, 39],$/;"	P
cyan	nvim/plugged/coc.nvim/build/index.js	/^  cyan: [36, 39],$/;"	P
green	nvim/plugged/coc.nvim/build/index.js	/^  green: [32, 39],$/;"	P
magenta	nvim/plugged/coc.nvim/build/index.js	/^  magenta: [35, 39],$/;"	P
red	nvim/plugged/coc.nvim/build/index.js	/^  red: [91, 39],$/;"	P
yellow	nvim/plugged/coc.nvim/build/index.js	/^  yellow: [33, 39]$/;"	P
colorizeStart	nvim/plugged/coc.nvim/build/index.js	/^function colorizeStart(style) {$/;"	F
colorizeEnd	nvim/plugged/coc.nvim/build/index.js	/^function colorizeEnd(style) {$/;"	F
colorize	nvim/plugged/coc.nvim/build/index.js	/^function colorize(str, style) {$/;"	F
timestampLevelAndCategory	nvim/plugged/coc.nvim/build/index.js	/^function timestampLevelAndCategory(loggingEvent, colour) {$/;"	F
basicLayout	nvim/plugged/coc.nvim/build/index.js	/^function basicLayout(loggingEvent) {$/;"	F
colouredLayout	nvim/plugged/coc.nvim/build/index.js	/^function colouredLayout(loggingEvent) {$/;"	F
messagePassThroughLayout	nvim/plugged/coc.nvim/build/index.js	/^function messagePassThroughLayout(loggingEvent) {$/;"	F
dummyLayout	nvim/plugged/coc.nvim/build/index.js	/^function dummyLayout(loggingEvent) {$/;"	F
patternLayout	nvim/plugged/coc.nvim/build/index.js	/^function patternLayout(pattern, tokens) {$/;"	F
TTCC_CONVERSION_PATTERN	nvim/plugged/coc.nvim/build/index.js	/^  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';$/;"	V
regex	nvim/plugged/coc.nvim/build/index.js	/^  const regex = \/%(-?[0-9]+)?(\\.?[0-9]+)?([[\\]cdhmnprzxXyflos%])(\\{([^}]+)\\})?|([^%]+)\/;$/;"	V
categoryName	nvim/plugged/coc.nvim/build/index.js	/^  function categoryName(loggingEvent, specifier) {$/;"	F
formatAsDate	nvim/plugged/coc.nvim/build/index.js	/^  function formatAsDate(loggingEvent, specifier) {$/;"	F
hostname	nvim/plugged/coc.nvim/build/index.js	/^  function hostname() {$/;"	F
formatMessage	nvim/plugged/coc.nvim/build/index.js	/^  function formatMessage(loggingEvent) {$/;"	F
endOfLine	nvim/plugged/coc.nvim/build/index.js	/^  function endOfLine() {$/;"	F
logLevel	nvim/plugged/coc.nvim/build/index.js	/^  function logLevel(loggingEvent) {$/;"	F
startTime	nvim/plugged/coc.nvim/build/index.js	/^  function startTime(loggingEvent) {$/;"	F
startColour	nvim/plugged/coc.nvim/build/index.js	/^  function startColour(loggingEvent) {$/;"	F
endColour	nvim/plugged/coc.nvim/build/index.js	/^  function endColour(loggingEvent) {$/;"	F
percent	nvim/plugged/coc.nvim/build/index.js	/^  function percent() {$/;"	F
pid	nvim/plugged/coc.nvim/build/index.js	/^  function pid(loggingEvent) {$/;"	F
clusterInfo	nvim/plugged/coc.nvim/build/index.js	/^  function clusterInfo() {$/;"	F
userDefined	nvim/plugged/coc.nvim/build/index.js	/^  function userDefined(loggingEvent, specifier) {$/;"	F
contextDefined	nvim/plugged/coc.nvim/build/index.js	/^  function contextDefined(loggingEvent, specifier) {$/;"	F
fileName	nvim/plugged/coc.nvim/build/index.js	/^  function fileName(loggingEvent, specifier) {$/;"	F
lineNumber	nvim/plugged/coc.nvim/build/index.js	/^  function lineNumber(loggingEvent) {$/;"	F
columnNumber	nvim/plugged/coc.nvim/build/index.js	/^  function columnNumber(loggingEvent) {$/;"	F
callStack	nvim/plugged/coc.nvim/build/index.js	/^  function callStack(loggingEvent) {$/;"	F
replacers	nvim/plugged/coc.nvim/build/index.js	/^  const replacers = {$/;"	O
c	nvim/plugged/coc.nvim/build/index.js	/^    c: categoryName,$/;"	P
d	nvim/plugged/coc.nvim/build/index.js	/^    d: formatAsDate,$/;"	P
h	nvim/plugged/coc.nvim/build/index.js	/^    h: hostname,$/;"	P
m	nvim/plugged/coc.nvim/build/index.js	/^    m: formatMessage,$/;"	P
n	nvim/plugged/coc.nvim/build/index.js	/^    n: endOfLine,$/;"	P
p	nvim/plugged/coc.nvim/build/index.js	/^    p: logLevel,$/;"	P
r	nvim/plugged/coc.nvim/build/index.js	/^    r: startTime,$/;"	P
y	nvim/plugged/coc.nvim/build/index.js	/^    y: clusterInfo,$/;"	P
z	nvim/plugged/coc.nvim/build/index.js	/^    z: pid,$/;"	P
x	nvim/plugged/coc.nvim/build/index.js	/^    x: userDefined,$/;"	P
X	nvim/plugged/coc.nvim/build/index.js	/^    X: contextDefined,$/;"	P
f	nvim/plugged/coc.nvim/build/index.js	/^    f: fileName,$/;"	P
l	nvim/plugged/coc.nvim/build/index.js	/^    l: lineNumber,$/;"	P
o	nvim/plugged/coc.nvim/build/index.js	/^    o: columnNumber,$/;"	P
s	nvim/plugged/coc.nvim/build/index.js	/^    s: callStack$/;"	P
replaceToken	nvim/plugged/coc.nvim/build/index.js	/^  function replaceToken(conversionCharacter, loggingEvent, specifier) {$/;"	F
truncate	nvim/plugged/coc.nvim/build/index.js	/^  function truncate(truncation, toTruncate) {$/;"	F
len	nvim/plugged/coc.nvim/build/index.js	/^    let len;$/;"	V
pad	nvim/plugged/coc.nvim/build/index.js	/^  function pad(padding, toPad) {$/;"	F
len	nvim/plugged/coc.nvim/build/index.js	/^    let len;$/;"	V
truncateAndPad	nvim/plugged/coc.nvim/build/index.js	/^  function truncateAndPad(toTruncAndPad, truncation, padding) {$/;"	F
formattedString	nvim/plugged/coc.nvim/build/index.js	/^    let formattedString = '';$/;"	V
result	nvim/plugged/coc.nvim/build/index.js	/^    let result;$/;"	V
layoutMakers	nvim/plugged/coc.nvim/build/index.js	/^const layoutMakers = {$/;"	O
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
coloredLayout	nvim/plugged/coc.nvim/build/index.js	/^  coloredLayout: colouredLayout,$/;"	P
padWithZeros	nvim/plugged/coc.nvim/build/index.js	/^function padWithZeros(vNumber, width) {$/;"	F
addZero	nvim/plugged/coc.nvim/build/index.js	/^function addZero(vNumber) {$/;"	F
offset	nvim/plugged/coc.nvim/build/index.js	/^function offset(timezoneOffset) {$/;"	F
datePart	nvim/plugged/coc.nvim/build/index.js	/^function datePart(date, displayUTC, part) {$/;"	F
asString	nvim/plugged/coc.nvim/build/index.js	/^function asString(format, date) {$/;"	F
extractDateParts	nvim/plugged/coc.nvim/build/index.js	/^function extractDateParts(pattern, str, missingValuesDate) {$/;"	F
matchers	nvim/plugged/coc.nvim/build/index.js	/^  var matchers = [$/;"	A
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/y{1,4}\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d{1,4}",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/MM\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d{1,2}",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/dd\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d{1,2}",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/hh\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d{1,2}",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/mm\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d\\\\d",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/ss\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d\\\\d",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/SSS\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "\\\\d\\\\d\\\\d",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
pattern	nvim/plugged/coc.nvim/build/index.js	/^      pattern: \/O\/,$/;"	P
regexp	nvim/plugged/coc.nvim/build/index.js	/^      regexp: "[+-]\\\\d{3,4}|Z",$/;"	P
fn	nvim/plugged/coc.nvim/build/index.js	/^      fn: function(date, value) {$/;"	M
function	nvim/plugged/coc.nvim/build/index.js	/^    function(p, m) {$/;"	M
matcher	nvim/plugged/coc.nvim/build/index.js	/^  var matcher = new RegExp(parsedPattern.regexp);$/;"	V
parse	nvim/plugged/coc.nvim/build/index.js	/^function parse(pattern, str, missingValuesDate) {$/;"	F
now	nvim/plugged/coc.nvim/build/index.js	/^function now() {$/;"	F
validColours	nvim/plugged/coc.nvim/build/index.js	/^const validColours = [$/;"	A
Level	nvim/plugged/coc.nvim/build/index.js	/^class Level {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(level, levelStr, colour) {$/;"	M
toString	nvim/plugged/coc.nvim/build/index.js	/^  toString() {$/;"	M
getLevel	nvim/plugged/coc.nvim/build/index.js	/^  static getLevel(sArg, defaultLevel) {$/;"	M
addLevels	nvim/plugged/coc.nvim/build/index.js	/^  static addLevels(customLevels) {$/;"	M
existingLevelIndex	nvim/plugged/coc.nvim/build/index.js	/^        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);$/;"	F
isLessThanOrEqualTo	nvim/plugged/coc.nvim/build/index.js	/^  isLessThanOrEqualTo(otherLevel) {$/;"	M
isGreaterThanOrEqualTo	nvim/plugged/coc.nvim/build/index.js	/^  isGreaterThanOrEqualTo(otherLevel) {$/;"	M
isEqualTo	nvim/plugged/coc.nvim/build/index.js	/^  isEqualTo(otherLevel) {$/;"	M
ALL	nvim/plugged/coc.nvim/build/index.js	/^  ALL: { value: Number.MIN_VALUE, colour: 'grey' },$/;"	P
TRACE	nvim/plugged/coc.nvim/build/index.js	/^  TRACE: { value: 5000, colour: 'blue' },$/;"	P
DEBUG	nvim/plugged/coc.nvim/build/index.js	/^  DEBUG: { value: 10000, colour: 'cyan' },$/;"	P
INFO	nvim/plugged/coc.nvim/build/index.js	/^  INFO: { value: 20000, colour: 'green' },$/;"	P
WARN	nvim/plugged/coc.nvim/build/index.js	/^  WARN: { value: 30000, colour: 'yellow' },$/;"	P
ERROR	nvim/plugged/coc.nvim/build/index.js	/^  ERROR: { value: 40000, colour: 'red' },$/;"	P
FATAL	nvim/plugged/coc.nvim/build/index.js	/^  FATAL: { value: 50000, colour: 'magenta' },$/;"	P
MARK	nvim/plugged/coc.nvim/build/index.js	/^  MARK: { value: 9007199254740992, colour: 'grey' }, \/\/ 2^53$/;"	P
OFF	nvim/plugged/coc.nvim/build/index.js	/^  OFF: { value: Number.MAX_VALUE, colour: 'grey' }$/;"	P
coreAppenders	nvim/plugged/coc.nvim/build/index.js	/^const coreAppenders = new Map();$/;"	V
appenders	nvim/plugged/coc.nvim/build/index.js	/^const appenders = new Map();$/;"	V
tryLoading	nvim/plugged/coc.nvim/build/index.js	/^const tryLoading = (modulePath, config) => {$/;"	F
loadAppenderModule	nvim/plugged/coc.nvim/build/index.js	/^const loadAppenderModule = (type, config) => coreAppenders.get(type)$/;"	F
createAppender	nvim/plugged/coc.nvim/build/index.js	/^const createAppender = (name, config) => {$/;"	F
setup	nvim/plugged/coc.nvim/build/index.js	/^const setup = (config) => {$/;"	F
listeners	nvim/plugged/coc.nvim/build/index.js	/^const listeners = [];$/;"	A
pm2InstanceVar	nvim/plugged/coc.nvim/build/index.js	/^let pm2InstanceVar = "NODE_APP_INSTANCE";$/;"	V
isPM2Master	nvim/plugged/coc.nvim/build/index.js	/^const isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";$/;"	F
isMaster	nvim/plugged/coc.nvim/build/index.js	/^const isMaster = () => disabled || cluster.isMaster || isPM2Master();$/;"	F
sendToListeners	nvim/plugged/coc.nvim/build/index.js	/^const sendToListeners = logEvent => {$/;"	F
receiver	nvim/plugged/coc.nvim/build/index.js	/^const receiver = (worker, message) => {$/;"	F
disableClustering	nvim/plugged/coc.nvim/build/index.js	/^      disableClustering: disabled,$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
onlyOnMaster	nvim/plugged/coc.nvim/build/index.js	/^  onlyOnMaster: (fn, notMaster) => (isMaster() ? fn() : notMaster),$/;"	M
cluster	nvim/plugged/coc.nvim/build/index.js	/^        msg.cluster = {$/;"	P
LoggingEvent	nvim/plugged/coc.nvim/build/index.js	/^class LoggingEvent {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(categoryName, level, data, context, location) {$/;"	M
serialise	nvim/plugged/coc.nvim/build/index.js	/^  serialise() {$/;"	M
logData	nvim/plugged/coc.nvim/build/index.js	/^    const logData = this.data.map((e) => {$/;"	F
deserialise	nvim/plugged/coc.nvim/build/index.js	/^  static deserialise(serialised) {$/;"	M
event	nvim/plugged/coc.nvim/build/index.js	/^    let event;$/;"	V
fakeError	nvim/plugged/coc.nvim/build/index.js	/^          const fakeError = new Error(e);$/;"	V
Flatted	nvim/plugged/coc.nvim/build/index.js	/^  var Flatted = {$/;"	O
replace	nvim/plugged/coc.nvim/build/index.js	/^        replace = function (key, value) {$/;"	M
noop	nvim/plugged/coc.nvim/build/index.js	/^  function noop(key, value) {$/;"	F
revive	nvim/plugged/coc.nvim/build/index.js	/^  function revive(input, parsed, output, $) {$/;"	F
set	nvim/plugged/coc.nvim/build/index.js	/^  function set(known, input, value) {$/;"	F
primitives	nvim/plugged/coc.nvim/build/index.js	/^  function primitives(value) {$/;"	F
Primitives	nvim/plugged/coc.nvim/build/index.js	/^  function Primitives(key, value) {$/;"	F
maxFileSizeUnitTransform	nvim/plugged/coc.nvim/build/index.js	/^function maxFileSizeUnitTransform(maxLogSize) {$/;"	F
units	nvim/plugged/coc.nvim/build/index.js	/^  const units = {$/;"	O
K	nvim/plugged/coc.nvim/build/index.js	/^    K: 1024,$/;"	P
adapter	nvim/plugged/coc.nvim/build/index.js	/^function adapter(configAdapter, config) {$/;"	F
fileAppenderAdapter	nvim/plugged/coc.nvim/build/index.js	/^function fileAppenderAdapter(config) {$/;"	F
configAdapter	nvim/plugged/coc.nvim/build/index.js	/^  const configAdapter = {$/;"	O
maxLogSize	nvim/plugged/coc.nvim/build/index.js	/^    maxLogSize: maxFileSizeUnitTransform$/;"	P
adapters	nvim/plugged/coc.nvim/build/index.js	/^const adapters = {$/;"	O
file	nvim/plugged/coc.nvim/build/index.js	/^  file: fileAppenderAdapter,$/;"	P
fileSync	nvim/plugged/coc.nvim/build/index.js	/^  fileSync: fileAppenderAdapter$/;"	P
consoleAppender	nvim/plugged/coc.nvim/build/index.js	/^function consoleAppender(layout, timezoneOffset) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts) {$/;"	F
stdoutAppender	nvim/plugged/coc.nvim/build/index.js	/^function stdoutAppender(layout, timezoneOffset) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts) {$/;"	F
stderrAppender	nvim/plugged/coc.nvim/build/index.js	/^function stderrAppender(layout, timezoneOffset) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts) {$/;"	F
logLevelFilter	nvim/plugged/coc.nvim/build/index.js	/^function logLevelFilter(minLevelString, maxLevelString, appender, levels) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts, findAppender, levels) {$/;"	F
categoryFilter	nvim/plugged/coc.nvim/build/index.js	/^function categoryFilter(excludes, appender) {$/;"	F
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts, findAppender) {$/;"	F
removeNullOrEmptyRegexp	nvim/plugged/coc.nvim/build/index.js	/^function removeNullOrEmptyRegexp(regexp) {$/;"	F
filtered	nvim/plugged/coc.nvim/build/index.js	/^  const filtered = regexp.filter(el => ((el != null) && (el !== '')));$/;"	F
noLogFilter	nvim/plugged/coc.nvim/build/index.js	/^function noLogFilter(filters, appender) {$/;"	F
regex	nvim/plugged/coc.nvim/build/index.js	/^    const regex = new RegExp(filters.join('|'), 'i');$/;"	V
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts, findAppender) {$/;"	F
openTheStream	nvim/plugged/coc.nvim/build/index.js	/^function openTheStream(file, fileSize, numFiles, options) {$/;"	F
stream	nvim/plugged/coc.nvim/build/index.js	/^  const stream = new streams.RollingFileStream($/;"	V
fileAppender	nvim/plugged/coc.nvim/build/index.js	/^function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {$/;"	F
app	nvim/plugged/coc.nvim/build/index.js	/^  const app = function (loggingEvent) {$/;"	F
reopen	nvim/plugged/coc.nvim/build/index.js	/^  app.reopen = function () {$/;"	M
sighupHandler	nvim/plugged/coc.nvim/build/index.js	/^  app.sighupHandler = function () {$/;"	M
shutdown	nvim/plugged/coc.nvim/build/index.js	/^  app.shutdown = function (complete) {$/;"	M
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
RollingFileWriteStream	nvim/plugged/coc.nvim/build/index.js	/^class RollingFileWriteStream extends Writable {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(filePath, options) {$/;"	M
state	nvim/plugged/coc.nvim/build/index.js	/^    this.state = {$/;"	P
currentSize	nvim/plugged/coc.nvim/build/index.js	/^      currentSize: 0$/;"	P
index	nvim/plugged/coc.nvim/build/index.js	/^      index: 0,$/;"	P
_setExistingSizeAndDate	nvim/plugged/coc.nvim/build/index.js	/^  _setExistingSizeAndDate() {$/;"	M
_parseOption	nvim/plugged/coc.nvim/build/index.js	/^  _parseOption(rawOptions) {$/;"	M
defaultOptions	nvim/plugged/coc.nvim/build/index.js	/^    const defaultOptions = {$/;"	O
encoding	nvim/plugged/coc.nvim/build/index.js	/^      encoding: "utf8",$/;"	P
flags	nvim/plugged/coc.nvim/build/index.js	/^      flags: "a",$/;"	P
compress	nvim/plugged/coc.nvim/build/index.js	/^      compress: false,$/;"	P
keepFileExt	nvim/plugged/coc.nvim/build/index.js	/^      keepFileExt: false,$/;"	P
alwaysIncludePattern	nvim/plugged/coc.nvim/build/index.js	/^      alwaysIncludePattern: false$/;"	P
_final	nvim/plugged/coc.nvim/build/index.js	/^  _final(callback) {$/;"	M
_write	nvim/plugged/coc.nvim/build/index.js	/^  _write(chunk, encoding, callback) {$/;"	M
_dateChanged	nvim/plugged/coc.nvim/build/index.js	/^  _dateChanged() {$/;"	M
_tooBig	nvim/plugged/coc.nvim/build/index.js	/^  _tooBig() {$/;"	M
_roll	nvim/plugged/coc.nvim/build/index.js	/^  _roll() {$/;"	M
index	nvim/plugged/coc.nvim/build/index.js	/^        index: i$/;"	P
files	nvim/plugged/coc.nvim/build/index.js	/^    const files = await fs.readdir(this.fileObject.dir).catch(() => []);$/;"	F
getKey	nvim/plugged/coc.nvim/build/index.js	/^    const getKey = n =>$/;"	F
_renewWriteStream	nvim/plugged/coc.nvim/build/index.js	/^  _renewWriteStream() {$/;"	M
index	nvim/plugged/coc.nvim/build/index.js	/^      index: 0$/;"	P
ops	nvim/plugged/coc.nvim/build/index.js	/^    const ops = {$/;"	O
_tooManyFiles	nvim/plugged/coc.nvim/build/index.js	/^  _tooManyFiles(numFiles) {$/;"	M
deleteFiles	nvim/plugged/coc.nvim/build/index.js	/^const deleteFiles = fileNames => {$/;"	F
api	nvim/plugged/coc.nvim/build/index.js	/^const api = [$/;"	A
exists	nvim/plugged/coc.nvim/build/index.js	/^exports.exists = function (filename, callback) {$/;"	M
read	nvim/plugged/coc.nvim/build/index.js	/^exports.read = function (fd, buffer, offset, length, position, callback) {$/;"	M
write	nvim/plugged/coc.nvim/build/index.js	/^exports.write = function (fd, buffer, ...args) {$/;"	M
fromCallback	nvim/plugged/coc.nvim/build/index.js	/^exports.fromCallback = function (fn) {$/;"	M
fromPromise	nvim/plugged/coc.nvim/build/index.js	/^exports.fromPromise = function (fn) {$/;"	M
noop	nvim/plugged/coc.nvim/build/index.js	/^function noop () {}$/;"	F
debug	nvim/plugged/coc.nvim/build/index.js	/^  debug = function() {$/;"	M
queue	nvim/plugged/coc.nvim/build/index.js	/^  var queue = []$/;"	A
get	nvim/plugged/coc.nvim/build/index.js	/^    get: function() {$/;"	M
close	nvim/plugged/coc.nvim/build/index.js	/^  fs.close = (function (fs$close) {$/;"	M
close	nvim/plugged/coc.nvim/build/index.js	/^    function close (fd, cb) {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^      value: fs$close$/;"	P
closeSync	nvim/plugged/coc.nvim/build/index.js	/^  fs.closeSync = (function (fs$closeSync) {$/;"	M
closeSync	nvim/plugged/coc.nvim/build/index.js	/^    function closeSync (fd) {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^      value: fs$closeSync$/;"	P
patch	nvim/plugged/coc.nvim/build/index.js	/^function patch (fs) {$/;"	F
readFile	nvim/plugged/coc.nvim/build/index.js	/^  function readFile (path, options, cb) {$/;"	F
go$readFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$readFile (path, options, cb) {$/;"	F
writeFile	nvim/plugged/coc.nvim/build/index.js	/^  function writeFile (path, data, options, cb) {$/;"	F
go$writeFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$writeFile (path, data, options, cb) {$/;"	F
appendFile	nvim/plugged/coc.nvim/build/index.js	/^  function appendFile (path, data, options, cb) {$/;"	F
go$appendFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$appendFile (path, data, options, cb) {$/;"	F
readdir	nvim/plugged/coc.nvim/build/index.js	/^  function readdir (path, options, cb) {$/;"	F
args	nvim/plugged/coc.nvim/build/index.js	/^    var args = [path]$/;"	A
go$readdir$cb	nvim/plugged/coc.nvim/build/index.js	/^    function go$readdir$cb (err, files) {$/;"	F
go$readdir	nvim/plugged/coc.nvim/build/index.js	/^  function go$readdir (args) {$/;"	F
get	nvim/plugged/coc.nvim/build/index.js	/^    get: function () {$/;"	M
set	nvim/plugged/coc.nvim/build/index.js	/^    set: function (val) {$/;"	M
enumerable	nvim/plugged/coc.nvim/build/index.js	/^    enumerable: true,$/;"	P
configurable	nvim/plugged/coc.nvim/build/index.js	/^    configurable: true$/;"	P
get	nvim/plugged/coc.nvim/build/index.js	/^    get: function () {$/;"	M
set	nvim/plugged/coc.nvim/build/index.js	/^    set: function (val) {$/;"	M
enumerable	nvim/plugged/coc.nvim/build/index.js	/^    enumerable: true,$/;"	P
configurable	nvim/plugged/coc.nvim/build/index.js	/^    configurable: true$/;"	P
get	nvim/plugged/coc.nvim/build/index.js	/^    get: function () {$/;"	M
set	nvim/plugged/coc.nvim/build/index.js	/^    set: function (val) {$/;"	M
enumerable	nvim/plugged/coc.nvim/build/index.js	/^    enumerable: true,$/;"	P
configurable	nvim/plugged/coc.nvim/build/index.js	/^    configurable: true$/;"	P
get	nvim/plugged/coc.nvim/build/index.js	/^    get: function () {$/;"	M
set	nvim/plugged/coc.nvim/build/index.js	/^    set: function (val) {$/;"	M
enumerable	nvim/plugged/coc.nvim/build/index.js	/^    enumerable: true,$/;"	P
configurable	nvim/plugged/coc.nvim/build/index.js	/^    configurable: true$/;"	P
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream (path, options) {$/;"	F
ReadStream$open	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream$open () {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^    open(that.path, that.flags, that.mode, function (err, fd) {$/;"	M
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream (path, options) {$/;"	F
WriteStream$open	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream$open () {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^    open(that.path, that.flags, that.mode, function (err, fd) {$/;"	M
createReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function createReadStream (path, options) {$/;"	F
createWriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function createWriteStream (path, options) {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^  function open (path, flags, mode, cb) {$/;"	F
go$open	nvim/plugged/coc.nvim/build/index.js	/^    function go$open (path, flags, mode, cb) {$/;"	F
enqueue	nvim/plugged/coc.nvim/build/index.js	/^function enqueue (elem) {$/;"	F
retry	nvim/plugged/coc.nvim/build/index.js	/^function retry () {$/;"	F
cwd	nvim/plugged/coc.nvim/build/index.js	/^process.cwd = function() {$/;"	M
chdir	nvim/plugged/coc.nvim/build/index.js	/^process.chdir = function(d) {$/;"	M
patch	nvim/plugged/coc.nvim/build/index.js	/^function patch (fs) {$/;"	F
lchmod	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmod = function (path, mode, cb) {$/;"	M
lchmodSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmodSync = function () {}$/;"	M
lchown	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchown = function (path, uid, gid, cb) {$/;"	M
lchownSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchownSync = function () {}$/;"	M
rename	nvim/plugged/coc.nvim/build/index.js	/^    fs.rename = (function (fs$rename) { return function (from, to, cb) {$/;"	M
backoff	nvim/plugged/coc.nvim/build/index.js	/^      var backoff = 0;$/;"	V
fs$rename	nvim/plugged/coc.nvim/build/index.js	/^      fs$rename(from, to, function CB (er) {$/;"	M
setTimeout	nvim/plugged/coc.nvim/build/index.js	/^          setTimeout(function() {$/;"	M
read	nvim/plugged/coc.nvim/build/index.js	/^  fs.read = (function (fs$read) {$/;"	M
read	nvim/plugged/coc.nvim/build/index.js	/^    function read (fd, buffer, offset, length, position, callback_) {$/;"	F
eagCounter	nvim/plugged/coc.nvim/build/index.js	/^        var eagCounter = 0$/;"	V
callback	nvim/plugged/coc.nvim/build/index.js	/^        callback = function (er, _, __) {$/;"	M
readSync	nvim/plugged/coc.nvim/build/index.js	/^  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {$/;"	M
eagCounter	nvim/plugged/coc.nvim/build/index.js	/^    var eagCounter = 0$/;"	V
patchLchmod	nvim/plugged/coc.nvim/build/index.js	/^  function patchLchmod (fs) {$/;"	F
lchmod	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmod = function (path, mode, callback) {$/;"	M
lchmodSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmodSync = function (path, mode) {$/;"	M
patchLutimes	nvim/plugged/coc.nvim/build/index.js	/^  function patchLutimes (fs) {$/;"	F
lutimes	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimes = function (path, at, mt, cb) {$/;"	M
lutimesSync	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimesSync = function (path, at, mt) {$/;"	M
lutimes	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }$/;"	M
lutimesSync	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimesSync = function () {}$/;"	M
chmodFix	nvim/plugged/coc.nvim/build/index.js	/^  function chmodFix (orig) {$/;"	F
chmodFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function chmodFixSync (orig) {$/;"	F
chownFix	nvim/plugged/coc.nvim/build/index.js	/^  function chownFix (orig) {$/;"	F
chownFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function chownFixSync (orig) {$/;"	F
statFix	nvim/plugged/coc.nvim/build/index.js	/^  function statFix (orig) {$/;"	F
callback	nvim/plugged/coc.nvim/build/index.js	/^      function callback (er, stats) {$/;"	F
statFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function statFixSync (orig) {$/;"	F
chownErOk	nvim/plugged/coc.nvim/build/index.js	/^  function chownErOk (er) {$/;"	F
legacy	nvim/plugged/coc.nvim/build/index.js	/^function legacy (fs) {$/;"	F
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^    ReadStream: ReadStream,$/;"	P
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^    WriteStream: WriteStream$/;"	P
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream (path, options) {$/;"	F
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream (path, options) {$/;"	F
clone	nvim/plugged/coc.nvim/build/index.js	/^function clone (obj) {$/;"	F
copy	nvim/plugged/coc.nvim/build/index.js	/^    var copy = { __proto__: obj.__proto__ }$/;"	O
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
copySync	nvim/plugged/coc.nvim/build/index.js	/^function copySync (src, dest, opts) {$/;"	F
handleFilterAndCopy	nvim/plugged/coc.nvim/build/index.js	/^function handleFilterAndCopy (destStat, src, dest, opts) {$/;"	F
startCopy	nvim/plugged/coc.nvim/build/index.js	/^function startCopy (destStat, src, dest, opts) {$/;"	F
getStats	nvim/plugged/coc.nvim/build/index.js	/^function getStats (destStat, src, dest, opts) {$/;"	F
onFile	nvim/plugged/coc.nvim/build/index.js	/^function onFile (srcStat, destStat, src, dest, opts) {$/;"	F
mayCopyFile	nvim/plugged/coc.nvim/build/index.js	/^function mayCopyFile (srcStat, src, dest, opts) {$/;"	F
copyFile	nvim/plugged/coc.nvim/build/index.js	/^function copyFile (srcStat, src, dest, opts) {$/;"	F
copyFileFallback	nvim/plugged/coc.nvim/build/index.js	/^function copyFileFallback (srcStat, src, dest, opts) {$/;"	F
BUF_LENGTH	nvim/plugged/coc.nvim/build/index.js	/^  const BUF_LENGTH = 64 * 1024$/;"	V
pos	nvim/plugged/coc.nvim/build/index.js	/^  let pos = 0$/;"	V
onDir	nvim/plugged/coc.nvim/build/index.js	/^function onDir (srcStat, destStat, src, dest, opts) {$/;"	F
mkDirAndCopy	nvim/plugged/coc.nvim/build/index.js	/^function mkDirAndCopy (srcStat, src, dest, opts) {$/;"	F
copyDir	nvim/plugged/coc.nvim/build/index.js	/^function copyDir (src, dest, opts) {$/;"	F
copyDirItem	nvim/plugged/coc.nvim/build/index.js	/^function copyDirItem (item, src, dest, opts) {$/;"	F
onLink	nvim/plugged/coc.nvim/build/index.js	/^function onLink (destStat, src, dest, opts) {$/;"	F
copyLink	nvim/plugged/coc.nvim/build/index.js	/^function copyLink (resolvedSrc, dest) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
mkdirp	nvim/plugged/coc.nvim/build/index.js	/^  mkdirp: mkdirs,$/;"	P
mkdirpSync	nvim/plugged/coc.nvim/build/index.js	/^  mkdirpSync: mkdirsSync,$/;"	P
ensureDir	nvim/plugged/coc.nvim/build/index.js	/^  ensureDir: mkdirs,$/;"	P
ensureDirSync	nvim/plugged/coc.nvim/build/index.js	/^  ensureDirSync: mkdirsSync$/;"	P
mkdirs	nvim/plugged/coc.nvim/build/index.js	/^function mkdirs (p, opts, callback, made) {$/;"	F
errInval	nvim/plugged/coc.nvim/build/index.js	/^    const errInval = new Error(p + ' contains invalid WIN32 path characters.')$/;"	V
getRootPath	nvim/plugged/coc.nvim/build/index.js	/^function getRootPath (p) {$/;"	F
TODO	nvim/plugged/coc.nvim/build/index.js	/^\/\/ TODO: expand to include the rest$/;"	T
INVALID_PATH_CHARS	nvim/plugged/coc.nvim/build/index.js	/^const INVALID_PATH_CHARS = \/[<>:"|?*]\/$/;"	V
invalidWin32Path	nvim/plugged/coc.nvim/build/index.js	/^function invalidWin32Path (p) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
mkdirsSync	nvim/plugged/coc.nvim/build/index.js	/^function mkdirsSync (p, opts, made) {$/;"	F
errInval	nvim/plugged/coc.nvim/build/index.js	/^    const errInval = new Error(p + ' contains invalid WIN32 path characters.')$/;"	V
hasMillisResSync	nvim/plugged/coc.nvim/build/index.js	/^function hasMillisResSync () {$/;"	F
d	nvim/plugged/coc.nvim/build/index.js	/^  const d = new Date(1435410243862)$/;"	V
hasMillisRes	nvim/plugged/coc.nvim/build/index.js	/^function hasMillisRes (callback) {$/;"	F
d	nvim/plugged/coc.nvim/build/index.js	/^  const d = new Date(1435410243862)$/;"	V
timeRemoveMillis	nvim/plugged/coc.nvim/build/index.js	/^function timeRemoveMillis (timestamp) {$/;"	F
utimesMillis	nvim/plugged/coc.nvim/build/index.js	/^function utimesMillis (path, atime, mtime, callback) {$/;"	F
utimesMillisSync	nvim/plugged/coc.nvim/build/index.js	/^function utimesMillisSync (path, atime, mtime) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
NODE_VERSION_MAJOR_WITH_BIGINT	nvim/plugged/coc.nvim/build/index.js	/^const NODE_VERSION_MAJOR_WITH_BIGINT = 10$/;"	V
NODE_VERSION_MINOR_WITH_BIGINT	nvim/plugged/coc.nvim/build/index.js	/^const NODE_VERSION_MINOR_WITH_BIGINT = 5$/;"	V
NODE_VERSION_PATCH_WITH_BIGINT	nvim/plugged/coc.nvim/build/index.js	/^const NODE_VERSION_PATCH_WITH_BIGINT = 0$/;"	V
nodeSupportsBigInt	nvim/plugged/coc.nvim/build/index.js	/^function nodeSupportsBigInt () {$/;"	F
getStats	nvim/plugged/coc.nvim/build/index.js	/^function getStats (src, dest, cb) {$/;"	F
getStatsSync	nvim/plugged/coc.nvim/build/index.js	/^function getStatsSync (src, dest) {$/;"	F
srcStat	nvim/plugged/coc.nvim/build/index.js	/^  let srcStat, destStat$/;"	V
destStat	nvim/plugged/coc.nvim/build/index.js	/^  let srcStat, destStat$/;"	V
checkPaths	nvim/plugged/coc.nvim/build/index.js	/^function checkPaths (src, dest, funcName, cb) {$/;"	F
checkPathsSync	nvim/plugged/coc.nvim/build/index.js	/^function checkPathsSync (src, dest, funcName) {$/;"	F
checkParentPaths	nvim/plugged/coc.nvim/build/index.js	/^function checkParentPaths (src, srcStat, dest, funcName, cb) {$/;"	F
checkParentPathsSync	nvim/plugged/coc.nvim/build/index.js	/^function checkParentPathsSync (src, srcStat, dest, funcName) {$/;"	F
isSrcSubdir	nvim/plugged/coc.nvim/build/index.js	/^function isSrcSubdir (src, dest) {$/;"	F
srcArr	nvim/plugged/coc.nvim/build/index.js	/^  const srcArr = path.resolve(src).split(path.sep).filter(i => i)$/;"	F
destArr	nvim/plugged/coc.nvim/build/index.js	/^  const destArr = path.resolve(dest).split(path.sep).filter(i => i)$/;"	F
errMsg	nvim/plugged/coc.nvim/build/index.js	/^function errMsg (src, dest, funcName) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = function (size) {$/;"	M
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
copy	nvim/plugged/coc.nvim/build/index.js	/^function copy (src, dest, opts, cb) {$/;"	F
checkParentDir	nvim/plugged/coc.nvim/build/index.js	/^function checkParentDir (destStat, src, dest, opts, cb) {$/;"	F
handleFilter	nvim/plugged/coc.nvim/build/index.js	/^function handleFilter (onInclude, destStat, src, dest, opts, cb) {$/;"	F
startCopy	nvim/plugged/coc.nvim/build/index.js	/^function startCopy (destStat, src, dest, opts, cb) {$/;"	F
getStats	nvim/plugged/coc.nvim/build/index.js	/^function getStats (destStat, src, dest, opts, cb) {$/;"	F
onFile	nvim/plugged/coc.nvim/build/index.js	/^function onFile (srcStat, destStat, src, dest, opts, cb) {$/;"	F
mayCopyFile	nvim/plugged/coc.nvim/build/index.js	/^function mayCopyFile (srcStat, src, dest, opts, cb) {$/;"	F
copyFile	nvim/plugged/coc.nvim/build/index.js	/^function copyFile (srcStat, src, dest, opts, cb) {$/;"	F
copyFileFallback	nvim/plugged/coc.nvim/build/index.js	/^function copyFileFallback (srcStat, src, dest, opts, cb) {$/;"	F
setDestModeAndTimestamps	nvim/plugged/coc.nvim/build/index.js	/^function setDestModeAndTimestamps (srcStat, dest, opts, cb) {$/;"	F
onDir	nvim/plugged/coc.nvim/build/index.js	/^function onDir (srcStat, destStat, src, dest, opts, cb) {$/;"	F
mkDirAndCopy	nvim/plugged/coc.nvim/build/index.js	/^function mkDirAndCopy (srcStat, src, dest, opts, cb) {$/;"	F
copyDir	nvim/plugged/coc.nvim/build/index.js	/^function copyDir (src, dest, opts, cb) {$/;"	F
copyDirItems	nvim/plugged/coc.nvim/build/index.js	/^function copyDirItems (items, src, dest, opts, cb) {$/;"	F
copyDirItem	nvim/plugged/coc.nvim/build/index.js	/^function copyDirItem (items, item, src, dest, opts, cb) {$/;"	F
onLink	nvim/plugged/coc.nvim/build/index.js	/^function onLink (destStat, src, dest, opts, cb) {$/;"	F
copyLink	nvim/plugged/coc.nvim/build/index.js	/^function copyLink (resolvedSrc, dest, cb) {$/;"	F
pathExists	nvim/plugged/coc.nvim/build/index.js	/^function pathExists (path) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
deleteItem	nvim/plugged/coc.nvim/build/index.js	/^    function deleteItem () {$/;"	F
emptyDirSync	nvim/plugged/coc.nvim/build/index.js	/^function emptyDirSync (dir) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
emptydirSync	nvim/plugged/coc.nvim/build/index.js	/^  emptydirSync: emptyDirSync,$/;"	P
emptydir	nvim/plugged/coc.nvim/build/index.js	/^  emptydir: emptyDir$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
defaults	nvim/plugged/coc.nvim/build/index.js	/^function defaults (options) {$/;"	F
methods	nvim/plugged/coc.nvim/build/index.js	/^  const methods = [$/;"	A
rimraf	nvim/plugged/coc.nvim/build/index.js	/^function rimraf (p, options, cb) {$/;"	F
busyTries	nvim/plugged/coc.nvim/build/index.js	/^  let busyTries = 0$/;"	V
rimraf_	nvim/plugged/coc.nvim/build/index.js	/^  rimraf_(p, options, function CB (er) {$/;"	M
rimraf_	nvim/plugged/coc.nvim/build/index.js	/^function rimraf_ (p, options, cb) {$/;"	F
fixWinEPERM	nvim/plugged/coc.nvim/build/index.js	/^function fixWinEPERM (p, options, er, cb) {$/;"	F
fixWinEPERMSync	nvim/plugged/coc.nvim/build/index.js	/^function fixWinEPERMSync (p, options, er) {$/;"	F
rmdir	nvim/plugged/coc.nvim/build/index.js	/^function rmdir (p, options, originalEr, cb) {$/;"	F
rmkids	nvim/plugged/coc.nvim/build/index.js	/^function rmkids (p, options, cb) {$/;"	F
rimrafSync	nvim/plugged/coc.nvim/build/index.js	/^function rimrafSync (p, options) {$/;"	F
rmdirSync	nvim/plugged/coc.nvim/build/index.js	/^function rmdirSync (p, options, originalEr) {$/;"	F
rmkidsSync	nvim/plugged/coc.nvim/build/index.js	/^function rmkidsSync (p, options) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
createFile	nvim/plugged/coc.nvim/build/index.js	/^function createFile (file, callback) {$/;"	F
makeFile	nvim/plugged/coc.nvim/build/index.js	/^  function makeFile () {$/;"	F
createFileSync	nvim/plugged/coc.nvim/build/index.js	/^function createFileSync (file) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
createLink	nvim/plugged/coc.nvim/build/index.js	/^function createLink (srcpath, dstpath, callback) {$/;"	F
makeLink	nvim/plugged/coc.nvim/build/index.js	/^  function makeLink (srcpath, dstpath) {$/;"	F
createLinkSync	nvim/plugged/coc.nvim/build/index.js	/^function createLinkSync (srcpath, dstpath) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
createSymlink	nvim/plugged/coc.nvim/build/index.js	/^function createSymlink (srcpath, dstpath, type, callback) {$/;"	F
callback	nvim/plugged/coc.nvim/build/index.js	/^  callback = (typeof type === 'function') ? type : callback$/;"	M
type	nvim/plugged/coc.nvim/build/index.js	/^  type = (typeof type === 'function') ? false : type$/;"	M
createSymlinkSync	nvim/plugged/coc.nvim/build/index.js	/^function createSymlinkSync (srcpath, dstpath, type) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
symlinkPaths	nvim/plugged/coc.nvim/build/index.js	/^function symlinkPaths (srcpath, dstpath, callback) {$/;"	F
symlinkPathsSync	nvim/plugged/coc.nvim/build/index.js	/^function symlinkPathsSync (srcpath, dstpath) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
symlinkType	nvim/plugged/coc.nvim/build/index.js	/^function symlinkType (srcpath, type, callback) {$/;"	F
callback	nvim/plugged/coc.nvim/build/index.js	/^  callback = (typeof type === 'function') ? type : callback$/;"	M
type	nvim/plugged/coc.nvim/build/index.js	/^  type = (typeof type === 'function') ? false : type$/;"	M
type	nvim/plugged/coc.nvim/build/index.js	/^    type = (stats && stats.isDirectory()) ? 'dir' : 'file'$/;"	M
symlinkTypeSync	nvim/plugged/coc.nvim/build/index.js	/^function symlinkTypeSync (srcpath, type) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
readFile	nvim/plugged/coc.nvim/build/index.js	/^function readFile (file, options, callback) {$/;"	F
readFileSync	nvim/plugged/coc.nvim/build/index.js	/^function readFileSync (file, options) {$/;"	F
stringify	nvim/plugged/coc.nvim/build/index.js	/^function stringify (obj, options) {$/;"	F
EOL	nvim/plugged/coc.nvim/build/index.js	/^  var EOL = '\\n'$/;"	V
writeFile	nvim/plugged/coc.nvim/build/index.js	/^function writeFile (file, obj, options, callback) {$/;"	F
str	nvim/plugged/coc.nvim/build/index.js	/^  var str = ''$/;"	V
writeFileSync	nvim/plugged/coc.nvim/build/index.js	/^function writeFileSync (file, obj, options) {$/;"	F
stripBom	nvim/plugged/coc.nvim/build/index.js	/^function stripBom (content) {$/;"	F
jsonfile	nvim/plugged/coc.nvim/build/index.js	/^var jsonfile = {$/;"	O
readFile	nvim/plugged/coc.nvim/build/index.js	/^  readFile: readFile,$/;"	P
readFileSync	nvim/plugged/coc.nvim/build/index.js	/^  readFileSync: readFileSync,$/;"	P
writeFile	nvim/plugged/coc.nvim/build/index.js	/^  writeFile: writeFile,$/;"	P
writeFileSync	nvim/plugged/coc.nvim/build/index.js	/^  writeFileSync: writeFileSync$/;"	P
queue	nvim/plugged/coc.nvim/build/index.js	/^var queue = []$/;"	A
noop	nvim/plugged/coc.nvim/build/index.js	/^function noop () {}$/;"	F
debug	nvim/plugged/coc.nvim/build/index.js	/^  debug = function() {$/;"	M
close	nvim/plugged/coc.nvim/build/index.js	/^module.exports.close = (function (fs$close) { return function (fd, cb) {$/;"	M
closeSync	nvim/plugged/coc.nvim/build/index.js	/^module.exports.closeSync = (function (fs$closeSync) { return function (fd) {$/;"	M
patch	nvim/plugged/coc.nvim/build/index.js	/^function patch (fs) {$/;"	F
readFile	nvim/plugged/coc.nvim/build/index.js	/^  function readFile (path, options, cb) {$/;"	F
go$readFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$readFile (path, options, cb) {$/;"	F
writeFile	nvim/plugged/coc.nvim/build/index.js	/^  function writeFile (path, data, options, cb) {$/;"	F
go$writeFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$writeFile (path, data, options, cb) {$/;"	F
appendFile	nvim/plugged/coc.nvim/build/index.js	/^  function appendFile (path, data, options, cb) {$/;"	F
go$appendFile	nvim/plugged/coc.nvim/build/index.js	/^    function go$appendFile (path, data, options, cb) {$/;"	F
readdir	nvim/plugged/coc.nvim/build/index.js	/^  function readdir (path, options, cb) {$/;"	F
args	nvim/plugged/coc.nvim/build/index.js	/^    var args = [path]$/;"	A
go$readdir$cb	nvim/plugged/coc.nvim/build/index.js	/^    function go$readdir$cb (err, files) {$/;"	F
go$readdir	nvim/plugged/coc.nvim/build/index.js	/^  function go$readdir (args) {$/;"	F
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream (path, options) {$/;"	F
ReadStream$open	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream$open () {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^    open(that.path, that.flags, that.mode, function (err, fd) {$/;"	M
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream (path, options) {$/;"	F
WriteStream$open	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream$open () {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^    open(that.path, that.flags, that.mode, function (err, fd) {$/;"	M
createReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function createReadStream (path, options) {$/;"	F
createWriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function createWriteStream (path, options) {$/;"	F
open	nvim/plugged/coc.nvim/build/index.js	/^  function open (path, flags, mode, cb) {$/;"	F
go$open	nvim/plugged/coc.nvim/build/index.js	/^    function go$open (path, flags, mode, cb) {$/;"	F
enqueue	nvim/plugged/coc.nvim/build/index.js	/^function enqueue (elem) {$/;"	F
retry	nvim/plugged/coc.nvim/build/index.js	/^function retry () {$/;"	F
cwd	nvim/plugged/coc.nvim/build/index.js	/^process.cwd = function() {$/;"	M
chdir	nvim/plugged/coc.nvim/build/index.js	/^process.chdir = function(d) {$/;"	M
patch	nvim/plugged/coc.nvim/build/index.js	/^function patch (fs) {$/;"	F
lchmod	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmod = function (path, mode, cb) {$/;"	M
lchmodSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmodSync = function () {}$/;"	M
lchown	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchown = function (path, uid, gid, cb) {$/;"	M
lchownSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchownSync = function () {}$/;"	M
rename	nvim/plugged/coc.nvim/build/index.js	/^    fs.rename = (function (fs$rename) { return function (from, to, cb) {$/;"	M
backoff	nvim/plugged/coc.nvim/build/index.js	/^      var backoff = 0;$/;"	V
fs$rename	nvim/plugged/coc.nvim/build/index.js	/^      fs$rename(from, to, function CB (er) {$/;"	M
setTimeout	nvim/plugged/coc.nvim/build/index.js	/^          setTimeout(function() {$/;"	M
read	nvim/plugged/coc.nvim/build/index.js	/^  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {$/;"	M
eagCounter	nvim/plugged/coc.nvim/build/index.js	/^      var eagCounter = 0$/;"	V
callback	nvim/plugged/coc.nvim/build/index.js	/^      callback = function (er, _, __) {$/;"	M
readSync	nvim/plugged/coc.nvim/build/index.js	/^  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {$/;"	M
eagCounter	nvim/plugged/coc.nvim/build/index.js	/^    var eagCounter = 0$/;"	V
patchLchmod	nvim/plugged/coc.nvim/build/index.js	/^  function patchLchmod (fs) {$/;"	F
lchmod	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmod = function (path, mode, callback) {$/;"	M
lchmodSync	nvim/plugged/coc.nvim/build/index.js	/^    fs.lchmodSync = function (path, mode) {$/;"	M
patchLutimes	nvim/plugged/coc.nvim/build/index.js	/^  function patchLutimes (fs) {$/;"	F
lutimes	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimes = function (path, at, mt, cb) {$/;"	M
lutimesSync	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimesSync = function (path, at, mt) {$/;"	M
lutimes	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }$/;"	M
lutimesSync	nvim/plugged/coc.nvim/build/index.js	/^      fs.lutimesSync = function () {}$/;"	M
chmodFix	nvim/plugged/coc.nvim/build/index.js	/^  function chmodFix (orig) {$/;"	F
chmodFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function chmodFixSync (orig) {$/;"	F
chownFix	nvim/plugged/coc.nvim/build/index.js	/^  function chownFix (orig) {$/;"	F
chownFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function chownFixSync (orig) {$/;"	F
statFix	nvim/plugged/coc.nvim/build/index.js	/^  function statFix (orig) {$/;"	F
statFixSync	nvim/plugged/coc.nvim/build/index.js	/^  function statFixSync (orig) {$/;"	F
chownErOk	nvim/plugged/coc.nvim/build/index.js	/^  function chownErOk (er) {$/;"	F
legacy	nvim/plugged/coc.nvim/build/index.js	/^function legacy (fs) {$/;"	F
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^    ReadStream: ReadStream,$/;"	P
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^    WriteStream: WriteStream$/;"	P
ReadStream	nvim/plugged/coc.nvim/build/index.js	/^  function ReadStream (path, options) {$/;"	F
WriteStream	nvim/plugged/coc.nvim/build/index.js	/^  function WriteStream (path, options) {$/;"	F
clone	nvim/plugged/coc.nvim/build/index.js	/^function clone (obj) {$/;"	F
copy	nvim/plugged/coc.nvim/build/index.js	/^    var copy = { __proto__: obj.__proto__ }$/;"	O
outputJson	nvim/plugged/coc.nvim/build/index.js	/^function outputJson (file, data, options, callback) {$/;"	F
outputJsonSync	nvim/plugged/coc.nvim/build/index.js	/^function outputJsonSync (file, data, options) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
moveSync	nvim/plugged/coc.nvim/build/index.js	/^function moveSync (src, dest, opts) {$/;"	F
doRename	nvim/plugged/coc.nvim/build/index.js	/^function doRename (src, dest, overwrite) {$/;"	F
rename	nvim/plugged/coc.nvim/build/index.js	/^function rename (src, dest, overwrite) {$/;"	F
moveAcrossDevice	nvim/plugged/coc.nvim/build/index.js	/^function moveAcrossDevice (src, dest, overwrite) {$/;"	F
opts	nvim/plugged/coc.nvim/build/index.js	/^  const opts = {$/;"	O
errorOnExist	nvim/plugged/coc.nvim/build/index.js	/^    errorOnExist: true$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
move	nvim/plugged/coc.nvim/build/index.js	/^function move (src, dest, opts, cb) {$/;"	F
doRename	nvim/plugged/coc.nvim/build/index.js	/^function doRename (src, dest, overwrite, cb) {$/;"	F
rename	nvim/plugged/coc.nvim/build/index.js	/^function rename (src, dest, overwrite, cb) {$/;"	F
moveAcrossDevice	nvim/plugged/coc.nvim/build/index.js	/^function moveAcrossDevice (src, dest, overwrite, cb) {$/;"	F
opts	nvim/plugged/coc.nvim/build/index.js	/^  const opts = {$/;"	O
errorOnExist	nvim/plugged/coc.nvim/build/index.js	/^    errorOnExist: true$/;"	P
outputFile	nvim/plugged/coc.nvim/build/index.js	/^function outputFile (file, data, encoding, callback) {$/;"	F
outputFileSync	nvim/plugged/coc.nvim/build/index.js	/^function outputFileSync (file, ...args) {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = () => new Date();$/;"	M
FILENAME_SEP	nvim/plugged/coc.nvim/build/index.js	/^const FILENAME_SEP = ".";$/;"	V
ZIP_EXT	nvim/plugged/coc.nvim/build/index.js	/^const ZIP_EXT = ".gz";$/;"	V
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = ({$/;"	M
ext	nvim/plugged/coc.nvim/build/index.js	/^  const ext = f => f + file.ext;$/;"	F
index	nvim/plugged/coc.nvim/build/index.js	/^  const index = (f, i, d) =>$/;"	F
date	nvim/plugged/coc.nvim/build/index.js	/^  const date = (f, i, d) => {$/;"	F
gzip	nvim/plugged/coc.nvim/build/index.js	/^  const gzip = (f, i) => (i && compress ? f + ZIP_EXT : f);$/;"	F
FILENAME_SEP	nvim/plugged/coc.nvim/build/index.js	/^const FILENAME_SEP = ".";$/;"	V
ZIP_EXT	nvim/plugged/coc.nvim/build/index.js	/^const ZIP_EXT = ".gz";$/;"	V
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = ({ file, keepFileExt, pattern }) => {$/;"	M
zip	nvim/plugged/coc.nvim/build/index.js	/^  const zip = (f, p) => {$/;"	F
extAtEnd	nvim/plugged/coc.nvim/build/index.js	/^  const extAtEnd = f => {$/;"	F
extInMiddle	nvim/plugged/coc.nvim/build/index.js	/^  const extInMiddle = f => {$/;"	F
dateAndIndex	nvim/plugged/coc.nvim/build/index.js	/^  const dateAndIndex = (f, p) => {$/;"	F
index	nvim/plugged/coc.nvim/build/index.js	/^  const index = (f, p) => {$/;"	F
parts	nvim/plugged/coc.nvim/build/index.js	/^  let parts = [$/;"	A
result	nvim/plugged/coc.nvim/build/index.js	/^    let result = { filename, index: 0, isCompressed: false };$/;"	O
RollingFileStream	nvim/plugged/coc.nvim/build/index.js	/^class RollingFileStream extends RollingFileWriteStream {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(filename, size, backups, options) {$/;"	M
DateRollingFileStream	nvim/plugged/coc.nvim/build/index.js	/^class DateRollingFileStream extends RollingFileWriteStream {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(filename, pattern, options) {$/;"	M
appender	nvim/plugged/coc.nvim/build/index.js	/^function appender($/;"	F
logFile	nvim/plugged/coc.nvim/build/index.js	/^  const logFile = new streams.DateRollingFileStream($/;"	V
app	nvim/plugged/coc.nvim/build/index.js	/^  const app = function (logEvent) {$/;"	F
shutdown	nvim/plugged/coc.nvim/build/index.js	/^  app.shutdown = function (complete) {$/;"	M
configure	nvim/plugged/coc.nvim/build/index.js	/^function configure(config, layouts) {$/;"	F
webpackEmptyContext	nvim/plugged/coc.nvim/build/index.js	/^function webpackEmptyContext(req) {$/;"	F
e	nvim/plugged/coc.nvim/build/index.js	/^	var e = new Error("Cannot find module '" + req + "'");$/;"	V
keys	nvim/plugged/coc.nvim/build/index.js	/^webpackEmptyContext.keys = function() { return []; };$/;"	M
categories	nvim/plugged/coc.nvim/build/index.js	/^const categories = new Map();$/;"	V
inheritFromParent	nvim/plugged/coc.nvim/build/index.js	/^function inheritFromParent(config, category, categoryName) {$/;"	F
addCategoryInheritance	nvim/plugged/coc.nvim/build/index.js	/^function addCategoryInheritance(config) {$/;"	F
setup	nvim/plugged/coc.nvim/build/index.js	/^const setup = (config) => {$/;"	F
categoryAppenders	nvim/plugged/coc.nvim/build/index.js	/^    const categoryAppenders = [];$/;"	A
appenders	nvim/plugged/coc.nvim/build/index.js	/^          appenders: categoryAppenders,$/;"	P
configForCategory	nvim/plugged/coc.nvim/build/index.js	/^const configForCategory = (category) => {$/;"	F
appendersForCategory	nvim/plugged/coc.nvim/build/index.js	/^const appendersForCategory = category => configForCategory(category).appenders;$/;"	F
getLevelForCategory	nvim/plugged/coc.nvim/build/index.js	/^const getLevelForCategory = category => configForCategory(category).level;$/;"	F
setLevelForCategory	nvim/plugged/coc.nvim/build/index.js	/^const setLevelForCategory = (category, level) => {$/;"	F
getEnableCallStackForCategory	nvim/plugged/coc.nvim/build/index.js	/^const getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;$/;"	F
setEnableCallStackForCategory	nvim/plugged/coc.nvim/build/index.js	/^const setEnableCallStackForCategory = (category, useCallStack) => {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = {$/;"	P
stackReg	nvim/plugged/coc.nvim/build/index.js	/^const stackReg = \/at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?\/;$/;"	V
defaultParseCallStack	nvim/plugged/coc.nvim/build/index.js	/^function defaultParseCallStack(data, skipIdx = 4) {$/;"	F
Logger	nvim/plugged/coc.nvim/build/index.js	/^class Logger {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^  constructor(name) {$/;"	M
context	nvim/plugged/coc.nvim/build/index.js	/^    this.context = {};$/;"	P
log	nvim/plugged/coc.nvim/build/index.js	/^  log(level, ...args) {$/;"	M
isLevelEnabled	nvim/plugged/coc.nvim/build/index.js	/^  isLevelEnabled(otherLevel) {$/;"	M
_log	nvim/plugged/coc.nvim/build/index.js	/^  _log(level, data) {$/;"	M
loggingEvent	nvim/plugged/coc.nvim/build/index.js	/^    const loggingEvent = new LoggingEvent($/;"	V
addContext	nvim/plugged/coc.nvim/build/index.js	/^  addContext(key, value) {$/;"	M
removeContext	nvim/plugged/coc.nvim/build/index.js	/^  removeContext(key) {$/;"	M
clearContext	nvim/plugged/coc.nvim/build/index.js	/^  clearContext() {$/;"	M
context	nvim/plugged/coc.nvim/build/index.js	/^    this.context = {};$/;"	P
setParseCallStackFunction	nvim/plugged/coc.nvim/build/index.js	/^  setParseCallStackFunction(parseFunction) {$/;"	M
addLevelMethods	nvim/plugged/coc.nvim/build/index.js	/^function addLevelMethods(target) {$/;"	F
levelMethod	nvim/plugged/coc.nvim/build/index.js	/^  const levelMethod = levelStrLower.replace(\/_([a-z])\/g, g =>$/;"	F
getUrl	nvim/plugged/coc.nvim/build/index.js	/^function getUrl(req) {$/;"	F
assembleTokens	nvim/plugged/coc.nvim/build/index.js	/^function assembleTokens(req, res, customTokens) {$/;"	F
arrayUniqueTokens	nvim/plugged/coc.nvim/build/index.js	/^  const arrayUniqueTokens = array => {$/;"	F
defaultTokens	nvim/plugged/coc.nvim/build/index.js	/^  const defaultTokens = [];$/;"	A
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":status",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":response-time",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":referrer",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":http-version",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":remote-addr",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":user-agent",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: ":content-length",$/;"	P
token	nvim/plugged/coc.nvim/build/index.js	/^    token: \/:req\\[([^\\]]+)]\/g,$/;"	P
replacement	nvim/plugged/coc.nvim/build/index.js	/^    replacement(_, field) {$/;"	M
token	nvim/plugged/coc.nvim/build/index.js	/^    token: \/:res\\[([^\\]]+)]\/g,$/;"	P
replacement	nvim/plugged/coc.nvim/build/index.js	/^    replacement(_, field) {$/;"	M
format	nvim/plugged/coc.nvim/build/index.js	/^function format(str, tokens) {$/;"	F
createNoLogCondition	nvim/plugged/coc.nvim/build/index.js	/^function createNoLogCondition(nolog) {$/;"	F
regexpsAsStrings	nvim/plugged/coc.nvim/build/index.js	/^    const regexpsAsStrings = nolog.map(reg => (reg.source ? reg.source : reg));$/;"	F
matchRules	nvim/plugged/coc.nvim/build/index.js	/^function matchRules(statusCode, currentLevel, ruleSet) {$/;"	F
matchedRule	nvim/plugged/coc.nvim/build/index.js	/^    const matchedRule = ruleSet.find(rule => {$/;"	F
exports	nvim/plugged/coc.nvim/build/index.js	/^module.exports = function getLogger(logger4js, options) {$/;"	M
start	nvim/plugged/coc.nvim/build/index.js	/^      const start = new Date();$/;"	V
writeHead	nvim/plugged/coc.nvim/build/index.js	/^      res.writeHead = (code, headers) => {$/;"	M
line	nvim/plugged/coc.nvim/build/index.js	/^          const line = fmt(req, res, str => format(str, combinedTokens));$/;"	F
isTest	nvim/plugged/coc.nvim/build/index.js	/^const isTest = "none" == 'test';$/;"	V
default	nvim/plugged/coc.nvim/build/index.js	/^exports.default = (opts, requestApi = true) => {$/;"	M
file	nvim/plugged/coc.nvim/build/index.js	/^        vscode_uri_1.URI.file = (path) => {$/;"	M
plugin	nvim/plugged/coc.nvim/build/index.js	/^    const plugin = new plugin_1.default(nvim);$/;"	V
attach	nvim/plugged/coc.nvim/build/index.js	/^function attach({ reader: _reader, writer: _writer, proc, socket, }, _logger = null, requestApi = true) {$/;"	F
writer	nvim/plugged/coc.nvim/build/index.js	/^    let writer;$/;"	V
reader	nvim/plugged/coc.nvim/build/index.js	/^    let reader;$/;"	V
neovim	nvim/plugged/coc.nvim/build/index.js	/^    let neovim;$/;"	V
fulfilled	nvim/plugged/coc.nvim/build/index.js	/^        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }$/;"	F
rejected	nvim/plugged/coc.nvim/build/index.js	/^        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }$/;"	F
AsyncResponse	nvim/plugged/coc.nvim/build/index.js	/^class AsyncResponse {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(requestId, cb) {$/;"	M
finish	nvim/plugged/coc.nvim/build/index.js	/^    finish(err, res) {$/;"	M
NeovimClient	nvim/plugged/coc.nvim/build/index.js	/^class NeovimClient extends Neovim_1.Neovim {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
value	nvim/plugged/coc.nvim/build/index.js	/^            value: this$/;"	P
createBuffer	nvim/plugged/coc.nvim/build/index.js	/^    createBuffer(id) {$/;"	M
data	nvim/plugged/coc.nvim/build/index.js	/^            data: id,$/;"	P
client	nvim/plugged/coc.nvim/build/index.js	/^            client: this$/;"	P
createWindow	nvim/plugged/coc.nvim/build/index.js	/^    createWindow(id) {$/;"	M
data	nvim/plugged/coc.nvim/build/index.js	/^            data: id,$/;"	P
client	nvim/plugged/coc.nvim/build/index.js	/^            client: this$/;"	P
createTabpage	nvim/plugged/coc.nvim/build/index.js	/^    createTabpage(id) {$/;"	M
data	nvim/plugged/coc.nvim/build/index.js	/^            data: id,$/;"	P
client	nvim/plugged/coc.nvim/build/index.js	/^            client: this$/;"	P
attach	nvim/plugged/coc.nvim/build/index.js	/^    attach({ reader, writer, }, requestApi = true) {$/;"	M
detach	nvim/plugged/coc.nvim/build/index.js	/^    detach() {$/;"	M
isAttached	nvim/plugged/coc.nvim/build/index.js	/^    isAttached(bufnr) {$/;"	M
handleRequest	nvim/plugged/coc.nvim/build/index.js	/^    handleRequest(method, args, resp) {$/;"	M
sendAsyncRequest	nvim/plugged/coc.nvim/build/index.js	/^    sendAsyncRequest(method, args) {$/;"	M
response	nvim/plugged/coc.nvim/build/index.js	/^            let response = new AsyncResponse(id, (err, res) => {$/;"	F
response	nvim/plugged/coc.nvim/build/index.js	/^            let response = new AsyncResponse(id, (err, res) => {$/;"	V
emitNotification	nvim/plugged/coc.nvim/build/index.js	/^    emitNotification(method, args) {$/;"	M
send	nvim/plugged/coc.nvim/build/index.js	/^                    send: (resp, isError) => {$/;"	M
handleNotification	nvim/plugged/coc.nvim/build/index.js	/^    handleNotification(method, args) {$/;"	M
setupTransport	nvim/plugged/coc.nvim/build/index.js	/^    setupTransport(requestApi = true) {$/;"	M
requestApi	nvim/plugged/coc.nvim/build/index.js	/^    requestApi() {$/;"	M
generateApi	nvim/plugged/coc.nvim/build/index.js	/^    generateApi() {$/;"	M
results	nvim/plugged/coc.nvim/build/index.js	/^            let results;$/;"	V
attachBufferEvent	nvim/plugged/coc.nvim/build/index.js	/^    attachBufferEvent(buffer, eventName, cb) {$/;"	M
detachBufferEvent	nvim/plugged/coc.nvim/build/index.js	/^    detachBufferEvent(buffer, eventName, cb) {$/;"	M
handlers	nvim/plugged/coc.nvim/build/index.js	/^        const handlers = (bufferMap.get(eventName) || []).filter(handler => handler !== cb);$/;"	F
pauseNotification	nvim/plugged/coc.nvim/build/index.js	/^    pauseNotification() {$/;"	M
resumeNotification	nvim/plugged/coc.nvim/build/index.js	/^    resumeNotification(cancel, notify) {$/;"	M
hasFunction	nvim/plugged/coc.nvim/build/index.js	/^    hasFunction(name) {$/;"	M
result	nvim/plugged/coc.nvim/build/index.js	/^    var result = {};$/;"	O
NvimTransport	nvim/plugged/coc.nvim/build/index.js	/^class NvimTransport extends base_1.default {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
parseMessage	nvim/plugged/coc.nvim/build/index.js	/^    parseMessage(msg) {$/;"	M
setupCodec	nvim/plugged/coc.nvim/build/index.js	/^    setupCodec() {$/;"	M
transport	nvim/plugged/coc.nvim/build/index.js	/^                transport: this,$/;"	P
attach	nvim/plugged/coc.nvim/build/index.js	/^    attach(writer, reader, client) {$/;"	M
buffered	nvim/plugged/coc.nvim/build/index.js	/^        const buffered = new buffered_1.default();$/;"	V
detach	nvim/plugged/coc.nvim/build/index.js	/^    detach() {$/;"	M
request	nvim/plugged/coc.nvim/build/index.js	/^    request(method, args, cb) {$/;"	M
notify	nvim/plugged/coc.nvim/build/index.js	/^    notify(method, args) {$/;"	M
createResponse	nvim/plugged/coc.nvim/build/index.js	/^    createResponse(requestId) {$/;"	M
send	nvim/plugged/coc.nvim/build/index.js	/^            send: (resp, isError) => {$/;"	M
encode	nvim/plugged/coc.nvim/build/index.js	/^function encode(input, options) {$/;"	F
encoder	nvim/plugged/coc.nvim/build/index.js	/^  var encoder = new EncodeBuffer(options);$/;"	V
EncodeBuffer	nvim/plugged/coc.nvim/build/index.js	/^function EncodeBuffer(options) {$/;"	F
write	nvim/plugged/coc.nvim/build/index.js	/^EncodeBuffer.prototype.write = function(input) {$/;"	M
addExtPacker	nvim/plugged/coc.nvim/build/index.js	/^  addExtPacker: addExtPacker,$/;"	P
getExtPacker	nvim/plugged/coc.nvim/build/index.js	/^  getExtPacker: getExtPacker,$/;"	P
init	nvim/plugged/coc.nvim/build/index.js	/^  init: init$/;"	P
getEncoder	nvim/plugged/coc.nvim/build/index.js	/^function getEncoder(options) {$/;"	F
encode	nvim/plugged/coc.nvim/build/index.js	/^  function encode(encoder, value) {$/;"	F
init	nvim/plugged/coc.nvim/build/index.js	/^function init() {$/;"	F
addExtPacker	nvim/plugged/coc.nvim/build/index.js	/^function addExtPacker(etype, Class, packer) {$/;"	F
extPacker	nvim/plugged/coc.nvim/build/index.js	/^  function extPacker(value) {$/;"	F
getExtPacker	nvim/plugged/coc.nvim/build/index.js	/^function getExtPacker(value) {$/;"	F
ExtBuffer	nvim/plugged/coc.nvim/build/index.js	/^function ExtBuffer(buffer, type) {$/;"	F
from	nvim/plugged/coc.nvim/build/index.js	/^function from(value) {$/;"	F
alloc	nvim/plugged/coc.nvim/build/index.js	/^function alloc(size) {$/;"	F
concat	nvim/plugged/coc.nvim/build/index.js	/^function concat(list, length) {$/;"	F
offset	nvim/plugged/coc.nvim/build/index.js	/^  var offset = 0;$/;"	V
dryrun	nvim/plugged/coc.nvim/build/index.js	/^  function dryrun(buffer) {$/;"	F
append	nvim/plugged/coc.nvim/build/index.js	/^  function append(buffer) {$/;"	F
isArrayBuffer	nvim/plugged/coc.nvim/build/index.js	/^function isArrayBuffer(value) {$/;"	F
fromString	nvim/plugged/coc.nvim/build/index.js	/^function fromString(value) {$/;"	F
auto	nvim/plugged/coc.nvim/build/index.js	/^function auto(that) {$/;"	F
_false	nvim/plugged/coc.nvim/build/index.js	/^function _false() {$/;"	F
_is	nvim/plugged/coc.nvim/build/index.js	/^function _is(name, key) {$/;"	F
c	nvim/plugged/coc.nvim/build/index.js	/^function c(B) {$/;"	F
toString	nvim/plugged/coc.nvim/build/index.js	/^var toString = {}.toString;$/;"	O
alloc	nvim/plugged/coc.nvim/build/index.js	/^function alloc(size) {$/;"	F
from	nvim/plugged/coc.nvim/build/index.js	/^function from(value) {$/;"	F
alloc	nvim/plugged/coc.nvim/build/index.js	/^function alloc(size) {$/;"	F
from	nvim/plugged/coc.nvim/build/index.js	/^function from(value) {$/;"	F
alloc	nvim/plugged/coc.nvim/build/index.js	/^function alloc(size) {$/;"	F
from	nvim/plugged/coc.nvim/build/index.js	/^function from(value) {$/;"	F
copy	nvim/plugged/coc.nvim/build/index.js	/^function copy(target, targetStart, start, end) {$/;"	F
slice	nvim/plugged/coc.nvim/build/index.js	/^function slice(start, end) {$/;"	F
toString	nvim/plugged/coc.nvim/build/index.js	/^function toString(encoding, start, end) {$/;"	F
gen	nvim/plugged/coc.nvim/build/index.js	/^function gen(method) {$/;"	F
wrap	nvim/plugged/coc.nvim/build/index.js	/^  function wrap() {$/;"	F
MAXBUFLEN	nvim/plugged/coc.nvim/build/index.js	/^var MAXBUFLEN = 8192;$/;"	V
write	nvim/plugged/coc.nvim/build/index.js	/^function write(string, offset) {$/;"	F
chr	nvim/plugged/coc.nvim/build/index.js	/^  var chr = 0;$/;"	V
i	nvim/plugged/coc.nvim/build/index.js	/^  var i = 0;$/;"	V
chr	nvim/plugged/coc.nvim/build/index.js	/^      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;$/;"	M
toString	nvim/plugged/coc.nvim/build/index.js	/^function toString(encoding, start, end) {$/;"	F
string	nvim/plugged/coc.nvim/build/index.js	/^  var string = '';$/;"	V
chr	nvim/plugged/coc.nvim/build/index.js	/^  var chr = 0;$/;"	V
chr	nvim/plugged/coc.nvim/build/index.js	/^      chr = (chr & 0x1F) << 6 |$/;"	M
chr	nvim/plugged/coc.nvim/build/index.js	/^      chr = (chr & 0x0F)             << 12 |$/;"	M
chr	nvim/plugged/coc.nvim/build/index.js	/^      chr = (chr & 0x07)             << 18 |$/;"	M
copy	nvim/plugged/coc.nvim/build/index.js	/^function copy(target, targetStart, start, end) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^  var i;$/;"	V
_encode	nvim/plugged/coc.nvim/build/index.js	/^var _encode;$/;"	V
ERROR_COLUMNS	nvim/plugged/coc.nvim/build/index.js	/^var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};$/;"	O
setExtPackers	nvim/plugged/coc.nvim/build/index.js	/^function setExtPackers(codec) {$/;"	F
encode	nvim/plugged/coc.nvim/build/index.js	/^function encode(input) {$/;"	F
packValueOf	nvim/plugged/coc.nvim/build/index.js	/^function packValueOf(value) {$/;"	F
packRegExp	nvim/plugged/coc.nvim/build/index.js	/^function packRegExp(value) {$/;"	F
out	nvim/plugged/coc.nvim/build/index.js	/^  var out = [value.pop()];$/;"	A
packError	nvim/plugged/coc.nvim/build/index.js	/^function packError(value) {$/;"	F
out	nvim/plugged/coc.nvim/build/index.js	/^  var out = {};$/;"	O
extmap	nvim/plugged/coc.nvim/build/index.js	/^var extmap = [];$/;"	A
getWriteType	nvim/plugged/coc.nvim/build/index.js	/^function getWriteType(options) {$/;"	F
writeType	nvim/plugged/coc.nvim/build/index.js	/^  var writeType = {$/;"	O
bool	nvim/plugged/coc.nvim/build/index.js	/^  function bool(encoder, value) {$/;"	F
number	nvim/plugged/coc.nvim/build/index.js	/^  function number(encoder, value) {$/;"	F
type	nvim/plugged/coc.nvim/build/index.js	/^    var type;$/;"	V
type	nvim/plugged/coc.nvim/build/index.js	/^      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;$/;"	M
type	nvim/plugged/coc.nvim/build/index.js	/^      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;$/;"	M
uint64	nvim/plugged/coc.nvim/build/index.js	/^  function uint64(encoder, value) {$/;"	F
type	nvim/plugged/coc.nvim/build/index.js	/^    var type = 0xcf;$/;"	V
int64	nvim/plugged/coc.nvim/build/index.js	/^  function int64(encoder, value) {$/;"	F
type	nvim/plugged/coc.nvim/build/index.js	/^    var type = 0xd3;$/;"	V
str_head_size	nvim/plugged/coc.nvim/build/index.js	/^  function str_head_size(length) {$/;"	F
raw_head_size	nvim/plugged/coc.nvim/build/index.js	/^  function raw_head_size(length) {$/;"	F
_string	nvim/plugged/coc.nvim/build/index.js	/^  function _string(head_size) {$/;"	F
string	nvim/plugged/coc.nvim/build/index.js	/^    function string(encoder, value) {$/;"	F
maxsize	nvim/plugged/coc.nvim/build/index.js	/^      var maxsize = 5 + length * 3;$/;"	V
object	nvim/plugged/coc.nvim/build/index.js	/^  function object(encoder, value) {$/;"	F
object_raw	nvim/plugged/coc.nvim/build/index.js	/^  function object_raw(encoder, value) {$/;"	F
nil	nvim/plugged/coc.nvim/build/index.js	/^  function nil(encoder, value) {$/;"	F
type	nvim/plugged/coc.nvim/build/index.js	/^    var type = 0xc0;$/;"	V
array	nvim/plugged/coc.nvim/build/index.js	/^  function array(encoder, value) {$/;"	F
bin_buffer	nvim/plugged/coc.nvim/build/index.js	/^  function bin_buffer(encoder, value) {$/;"	F
bin_arraybuffer	nvim/plugged/coc.nvim/build/index.js	/^  function bin_arraybuffer(encoder, value) {$/;"	F
ext	nvim/plugged/coc.nvim/build/index.js	/^  function ext(encoder, value) {$/;"	F
obj_to_map	nvim/plugged/coc.nvim/build/index.js	/^  function obj_to_map(encoder, value) {$/;"	F
map_to_map	nvim/plugged/coc.nvim/build/index.js	/^  function map_to_map(encoder, value) {$/;"	F
raw	nvim/plugged/coc.nvim/build/index.js	/^  function raw(encoder, value) {$/;"	F
Uint64BE	nvim/plugged/coc.nvim/build/index.js	/^var Uint64BE, Int64BE, Uint64LE, Int64LE;$/;"	V
Int64BE	nvim/plugged/coc.nvim/build/index.js	/^var Uint64BE, Int64BE, Uint64LE, Int64LE;$/;"	V
Uint64LE	nvim/plugged/coc.nvim/build/index.js	/^var Uint64BE, Int64BE, Uint64LE, Int64LE;$/;"	V
UNDEFINED	nvim/plugged/coc.nvim/build/index.js	/^  var UNDEFINED = "undefined";$/;"	V
ZERO	nvim/plugged/coc.nvim/build/index.js	/^  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];$/;"	A
BIT32	nvim/plugged/coc.nvim/build/index.js	/^  var BIT32 = 4294967296;$/;"	V
BIT24	nvim/plugged/coc.nvim/build/index.js	/^  var BIT24 = 16777216;$/;"	V
storage	nvim/plugged/coc.nvim/build/index.js	/^  var storage; \/\/ Array;$/;"	V
factory	nvim/plugged/coc.nvim/build/index.js	/^  function factory(name, bigendian, unsigned) {$/;"	F
isName	nvim/plugged/coc.nvim/build/index.js	/^    var isName = "is" + name;$/;"	V
_isInt64	nvim/plugged/coc.nvim/build/index.js	/^    var _isInt64 = "_" + isName;$/;"	V
Int64	nvim/plugged/coc.nvim/build/index.js	/^    function Int64(buffer, offset, value, raddix) {$/;"	F
isInt64	nvim/plugged/coc.nvim/build/index.js	/^    function isInt64(b) {$/;"	F
init	nvim/plugged/coc.nvim/build/index.js	/^    function init(that, buffer, offset, value, raddix) {$/;"	F
fromString	nvim/plugged/coc.nvim/build/index.js	/^    function fromString(buffer, offset, str, raddix) {$/;"	F
pos	nvim/plugged/coc.nvim/build/index.js	/^      var pos = 0;$/;"	V
high	nvim/plugged/coc.nvim/build/index.js	/^      var high = 0;$/;"	V
low	nvim/plugged/coc.nvim/build/index.js	/^      var low = 0;$/;"	V
toNumber	nvim/plugged/coc.nvim/build/index.js	/^    function toNumber() {$/;"	F
toString	nvim/plugged/coc.nvim/build/index.js	/^    function toString(radix) {$/;"	F
str	nvim/plugged/coc.nvim/build/index.js	/^      var str = "";$/;"	V
str	nvim/plugged/coc.nvim/build/index.js	/^        str = (mod % radix).toString(radix) + str;$/;"	M
writeInt32	nvim/plugged/coc.nvim/build/index.js	/^    function writeInt32(buffer, offset, value) {$/;"	F
readInt32	nvim/plugged/coc.nvim/build/index.js	/^    function readInt32(buffer, offset) {$/;"	F
toArray	nvim/plugged/coc.nvim/build/index.js	/^  function toArray(raw) {$/;"	F
toBuffer	nvim/plugged/coc.nvim/build/index.js	/^  function toBuffer(raw) {$/;"	F
dest	nvim/plugged/coc.nvim/build/index.js	/^    var dest = new BUFFER(8);$/;"	V
toArrayBuffer	nvim/plugged/coc.nvim/build/index.js	/^  function toArrayBuffer(raw) {$/;"	F
dest	nvim/plugged/coc.nvim/build/index.js	/^    var dest = new UINT8ARRAY(8);$/;"	V
isValidBuffer	nvim/plugged/coc.nvim/build/index.js	/^  function isValidBuffer(buffer, offset) {$/;"	F
fromArray	nvim/plugged/coc.nvim/build/index.js	/^  function fromArray(destbuf, destoff, srcbuf, srcoff) {$/;"	F
newArray	nvim/plugged/coc.nvim/build/index.js	/^  function newArray(buffer, offset) {$/;"	F
fromPositiveBE	nvim/plugged/coc.nvim/build/index.js	/^  function fromPositiveBE(buffer, offset, value) {$/;"	F
fromNegativeBE	nvim/plugged/coc.nvim/build/index.js	/^  function fromNegativeBE(buffer, offset, value) {$/;"	F
fromPositiveLE	nvim/plugged/coc.nvim/build/index.js	/^  function fromPositiveLE(buffer, offset, value) {$/;"	F
fromNegativeLE	nvim/plugged/coc.nvim/build/index.js	/^  function fromNegativeLE(buffer, offset, value) {$/;"	F
_isArray	nvim/plugged/coc.nvim/build/index.js	/^  function _isArray(val) {$/;"	F
getWriteToken	nvim/plugged/coc.nvim/build/index.js	/^function getWriteToken(options) {$/;"	F
init_uint8array	nvim/plugged/coc.nvim/build/index.js	/^function init_uint8array() {$/;"	F
init_token	nvim/plugged/coc.nvim/build/index.js	/^function init_token() {$/;"	F
init_safe	nvim/plugged/coc.nvim/build/index.js	/^function init_safe() {$/;"	F
write1	nvim/plugged/coc.nvim/build/index.js	/^function write1(type) {$/;"	F
write2	nvim/plugged/coc.nvim/build/index.js	/^function write2(type) {$/;"	F
write4	nvim/plugged/coc.nvim/build/index.js	/^function write4(type) {$/;"	F
writeN	nvim/plugged/coc.nvim/build/index.js	/^function writeN(type, len, method, noAssert) {$/;"	F
writeUInt64BE	nvim/plugged/coc.nvim/build/index.js	/^function writeUInt64BE(value, offset) {$/;"	F
writeInt64BE	nvim/plugged/coc.nvim/build/index.js	/^function writeInt64BE(value, offset) {$/;"	F
writeFloatBE	nvim/plugged/coc.nvim/build/index.js	/^function writeFloatBE(value, offset) {$/;"	F
writeDoubleBE	nvim/plugged/coc.nvim/build/index.js	/^function writeDoubleBE(value, offset) {$/;"	F
read	nvim/plugged/coc.nvim/build/index.js	/^exports.read = function (buffer, offset, isLE, mLen, nBytes) {$/;"	M
e	nvim/plugged/coc.nvim/build/index.js	/^  var e, m$/;"	V
m	nvim/plugged/coc.nvim/build/index.js	/^  var e, m$/;"	V
write	nvim/plugged/coc.nvim/build/index.js	/^exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {$/;"	M
e	nvim/plugged/coc.nvim/build/index.js	/^  var e, m, c$/;"	V
m	nvim/plugged/coc.nvim/build/index.js	/^  var e, m, c$/;"	V
c	nvim/plugged/coc.nvim/build/index.js	/^  var e, m, c$/;"	V
m	nvim/plugged/coc.nvim/build/index.js	/^      m = ((value * c) - 1) * Math.pow(2, mLen)$/;"	M
e	nvim/plugged/coc.nvim/build/index.js	/^  e = (e << mLen) | m$/;"	M
write0	nvim/plugged/coc.nvim/build/index.js	/^function write0(type) {$/;"	F
Codec	nvim/plugged/coc.nvim/build/index.js	/^function Codec(options) {$/;"	F
init	nvim/plugged/coc.nvim/build/index.js	/^Codec.prototype.init = function() {$/;"	M
install	nvim/plugged/coc.nvim/build/index.js	/^function install(props) {$/;"	F
add	nvim/plugged/coc.nvim/build/index.js	/^function add(a, b) {$/;"	F
ab	nvim/plugged/coc.nvim/build/index.js	/^  function ab() {$/;"	F
join	nvim/plugged/coc.nvim/build/index.js	/^function join(filters) {$/;"	F
iterator	nvim/plugged/coc.nvim/build/index.js	/^  function iterator(value, filter) {$/;"	F
filter	nvim/plugged/coc.nvim/build/index.js	/^function filter(filter) {$/;"	F
createCodec	nvim/plugged/coc.nvim/build/index.js	/^function createCodec(options) {$/;"	F
MIN_BUFFER_SIZE	nvim/plugged/coc.nvim/build/index.js	/^var MIN_BUFFER_SIZE = 2048;$/;"	V
MAX_BUFFER_SIZE	nvim/plugged/coc.nvim/build/index.js	/^var MAX_BUFFER_SIZE = 65536;$/;"	V
BUFFER_SHORTAGE	nvim/plugged/coc.nvim/build/index.js	/^var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";$/;"	V
FlexDecoder	nvim/plugged/coc.nvim/build/index.js	/^function FlexDecoder() {$/;"	F
FlexEncoder	nvim/plugged/coc.nvim/build/index.js	/^function FlexEncoder() {$/;"	F
getDecoderMethods	nvim/plugged/coc.nvim/build/index.js	/^function getDecoderMethods() {$/;"	F
bufferish	nvim/plugged/coc.nvim/build/index.js	/^    bufferish: Bufferish,$/;"	P
write	nvim/plugged/coc.nvim/build/index.js	/^    write: write,$/;"	P
fetch	nvim/plugged/coc.nvim/build/index.js	/^    fetch: fetch,$/;"	P
flush	nvim/plugged/coc.nvim/build/index.js	/^    flush: flush,$/;"	P
push	nvim/plugged/coc.nvim/build/index.js	/^    push: push,$/;"	P
pull	nvim/plugged/coc.nvim/build/index.js	/^    pull: pull,$/;"	P
read	nvim/plugged/coc.nvim/build/index.js	/^    read: read,$/;"	P
reserve	nvim/plugged/coc.nvim/build/index.js	/^    reserve: reserve,$/;"	P
offset	nvim/plugged/coc.nvim/build/index.js	/^    offset: 0$/;"	P
write	nvim/plugged/coc.nvim/build/index.js	/^  function write(chunk) {$/;"	F
flush	nvim/plugged/coc.nvim/build/index.js	/^  function flush() {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^      var value;$/;"	V
reserve	nvim/plugged/coc.nvim/build/index.js	/^  function reserve(length) {$/;"	F
getEncoderMethods	nvim/plugged/coc.nvim/build/index.js	/^function getEncoderMethods() {$/;"	F
bufferish	nvim/plugged/coc.nvim/build/index.js	/^    bufferish: Bufferish,$/;"	P
write	nvim/plugged/coc.nvim/build/index.js	/^    write: write,$/;"	P
fetch	nvim/plugged/coc.nvim/build/index.js	/^    fetch: fetch,$/;"	P
flush	nvim/plugged/coc.nvim/build/index.js	/^    flush: flush,$/;"	P
push	nvim/plugged/coc.nvim/build/index.js	/^    push: push,$/;"	P
pull	nvim/plugged/coc.nvim/build/index.js	/^    pull: pull,$/;"	P
read	nvim/plugged/coc.nvim/build/index.js	/^    read: read,$/;"	P
reserve	nvim/plugged/coc.nvim/build/index.js	/^    reserve: reserve,$/;"	P
send	nvim/plugged/coc.nvim/build/index.js	/^    send: send,$/;"	P
maxBufferSize	nvim/plugged/coc.nvim/build/index.js	/^    maxBufferSize: MAX_BUFFER_SIZE,$/;"	P
minBufferSize	nvim/plugged/coc.nvim/build/index.js	/^    minBufferSize: MIN_BUFFER_SIZE,$/;"	P
offset	nvim/plugged/coc.nvim/build/index.js	/^    offset: 0,$/;"	P
start	nvim/plugged/coc.nvim/build/index.js	/^    start: 0$/;"	P
fetch	nvim/plugged/coc.nvim/build/index.js	/^  function fetch() {$/;"	F
flush	nvim/plugged/coc.nvim/build/index.js	/^  function flush() {$/;"	F
pull	nvim/plugged/coc.nvim/build/index.js	/^  function pull() {$/;"	F
reserve	nvim/plugged/coc.nvim/build/index.js	/^  function reserve(length) {$/;"	F
send	nvim/plugged/coc.nvim/build/index.js	/^  function send(buffer) {$/;"	F
write	nvim/plugged/coc.nvim/build/index.js	/^function write() {$/;"	F
fetch	nvim/plugged/coc.nvim/build/index.js	/^function fetch() {$/;"	F
read	nvim/plugged/coc.nvim/build/index.js	/^function read() {$/;"	F
push	nvim/plugged/coc.nvim/build/index.js	/^function push(chunk) {$/;"	F
pull	nvim/plugged/coc.nvim/build/index.js	/^function pull() {$/;"	F
mixinFactory	nvim/plugged/coc.nvim/build/index.js	/^function mixinFactory(source) {$/;"	F
mixin	nvim/plugged/coc.nvim/build/index.js	/^  function mixin(target) {$/;"	F
decode	nvim/plugged/coc.nvim/build/index.js	/^function decode(input, options) {$/;"	F
decoder	nvim/plugged/coc.nvim/build/index.js	/^  var decoder = new DecodeBuffer(options);$/;"	V
DecodeBuffer	nvim/plugged/coc.nvim/build/index.js	/^function DecodeBuffer(options) {$/;"	F
fetch	nvim/plugged/coc.nvim/build/index.js	/^DecodeBuffer.prototype.fetch = function() {$/;"	M
addExtUnpacker	nvim/plugged/coc.nvim/build/index.js	/^  addExtUnpacker: addExtUnpacker,$/;"	P
getExtUnpacker	nvim/plugged/coc.nvim/build/index.js	/^  getExtUnpacker: getExtUnpacker,$/;"	P
init	nvim/plugged/coc.nvim/build/index.js	/^  init: init$/;"	P
getDecoder	nvim/plugged/coc.nvim/build/index.js	/^function getDecoder(options) {$/;"	F
decode	nvim/plugged/coc.nvim/build/index.js	/^  function decode(decoder) {$/;"	F
init	nvim/plugged/coc.nvim/build/index.js	/^function init() {$/;"	F
addExtUnpacker	nvim/plugged/coc.nvim/build/index.js	/^function addExtUnpacker(etype, unpacker) {$/;"	F
getExtUnpacker	nvim/plugged/coc.nvim/build/index.js	/^function getExtUnpacker(type) {$/;"	F
extUnpacker	nvim/plugged/coc.nvim/build/index.js	/^  function extUnpacker(buffer) {$/;"	F
_decode	nvim/plugged/coc.nvim/build/index.js	/^var _decode;$/;"	V
ERROR_COLUMNS	nvim/plugged/coc.nvim/build/index.js	/^var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};$/;"	O
setExtUnpackers	nvim/plugged/coc.nvim/build/index.js	/^function setExtUnpackers(codec) {$/;"	F
decode	nvim/plugged/coc.nvim/build/index.js	/^function decode(input) {$/;"	F
unpackRegExp	nvim/plugged/coc.nvim/build/index.js	/^function unpackRegExp(value) {$/;"	F
unpackError	nvim/plugged/coc.nvim/build/index.js	/^function unpackError(Class) {$/;"	F
out	nvim/plugged/coc.nvim/build/index.js	/^    var out = new Class();$/;"	V
unpackClass	nvim/plugged/coc.nvim/build/index.js	/^function unpackClass(Class) {$/;"	F
unpackArrayBuffer	nvim/plugged/coc.nvim/build/index.js	/^function unpackArrayBuffer(value) {$/;"	F
getReadFormat	nvim/plugged/coc.nvim/build/index.js	/^function getReadFormat(options) {$/;"	F
readFormat	nvim/plugged/coc.nvim/build/index.js	/^  var readFormat = {$/;"	O
map	nvim/plugged/coc.nvim/build/index.js	/^    map: (usemap ? map_to_map : map_to_obj),$/;"	M
array	nvim/plugged/coc.nvim/build/index.js	/^    array: array,$/;"	P
str	nvim/plugged/coc.nvim/build/index.js	/^    str: str,$/;"	P
bin	nvim/plugged/coc.nvim/build/index.js	/^    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),$/;"	M
ext	nvim/plugged/coc.nvim/build/index.js	/^    ext: ext,$/;"	P
uint8	nvim/plugged/coc.nvim/build/index.js	/^    uint8: uint8,$/;"	P
uint16	nvim/plugged/coc.nvim/build/index.js	/^    uint16: uint16,$/;"	P
uint32	nvim/plugged/coc.nvim/build/index.js	/^    uint32: uint32,$/;"	P
int8	nvim/plugged/coc.nvim/build/index.js	/^    int8: int8,$/;"	P
int16	nvim/plugged/coc.nvim/build/index.js	/^    int16: int16,$/;"	P
int32	nvim/plugged/coc.nvim/build/index.js	/^    int32: int32,$/;"	P
map_to_obj	nvim/plugged/coc.nvim/build/index.js	/^function map_to_obj(decoder, len) {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^  var value = {};$/;"	O
i	nvim/plugged/coc.nvim/build/index.js	/^  var i;$/;"	V
k	nvim/plugged/coc.nvim/build/index.js	/^  var k = new Array(len);$/;"	V
v	nvim/plugged/coc.nvim/build/index.js	/^  var v = new Array(len);$/;"	V
map_to_map	nvim/plugged/coc.nvim/build/index.js	/^function map_to_map(decoder, len) {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^  var value = new Map();$/;"	V
i	nvim/plugged/coc.nvim/build/index.js	/^  var i;$/;"	V
k	nvim/plugged/coc.nvim/build/index.js	/^  var k = new Array(len);$/;"	V
v	nvim/plugged/coc.nvim/build/index.js	/^  var v = new Array(len);$/;"	V
array	nvim/plugged/coc.nvim/build/index.js	/^function array(decoder, len) {$/;"	F
value	nvim/plugged/coc.nvim/build/index.js	/^  var value = new Array(len);$/;"	V
str	nvim/plugged/coc.nvim/build/index.js	/^function str(decoder, len) {$/;"	F
bin_buffer	nvim/plugged/coc.nvim/build/index.js	/^function bin_buffer(decoder, len) {$/;"	F
bin_arraybuffer	nvim/plugged/coc.nvim/build/index.js	/^function bin_arraybuffer(decoder, len) {$/;"	F
ext	nvim/plugged/coc.nvim/build/index.js	/^function ext(decoder, len) {$/;"	F
uint8	nvim/plugged/coc.nvim/build/index.js	/^function uint8(decoder) {$/;"	F
int8	nvim/plugged/coc.nvim/build/index.js	/^function int8(decoder) {$/;"	F
uint16	nvim/plugged/coc.nvim/build/index.js	/^function uint16(decoder) {$/;"	F
int16	nvim/plugged/coc.nvim/build/index.js	/^function int16(decoder) {$/;"	F
uint32	nvim/plugged/coc.nvim/build/index.js	/^function uint32(decoder) {$/;"	F
int32	nvim/plugged/coc.nvim/build/index.js	/^function int32(decoder) {$/;"	F
read	nvim/plugged/coc.nvim/build/index.js	/^function read(len, method) {$/;"	F
readUInt64BE	nvim/plugged/coc.nvim/build/index.js	/^function readUInt64BE(start) {$/;"	F
readInt64BE	nvim/plugged/coc.nvim/build/index.js	/^function readInt64BE(start) {$/;"	F
readUInt64BE_int64	nvim/plugged/coc.nvim/build/index.js	/^function readUInt64BE_int64(start) {$/;"	F
readInt64BE_int64	nvim/plugged/coc.nvim/build/index.js	/^function readInt64BE_int64(start) {$/;"	F
readFloatBE	nvim/plugged/coc.nvim/build/index.js	/^function readFloatBE(start) {$/;"	F
readDoubleBE	nvim/plugged/coc.nvim/build/index.js	/^function readDoubleBE(start) {$/;"	F
getReadToken	nvim/plugged/coc.nvim/build/index.js	/^function getReadToken(options) {$/;"	F
init_token	nvim/plugged/coc.nvim/build/index.js	/^function init_token(format) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^  var i;$/;"	V
token	nvim/plugged/coc.nvim/build/index.js	/^  var token = new Array(256);$/;"	V
init_useraw	nvim/plugged/coc.nvim/build/index.js	/^function init_useraw(format) {$/;"	F
i	nvim/plugged/coc.nvim/build/index.js	/^  var i;$/;"	V
constant	nvim/plugged/coc.nvim/build/index.js	/^function constant(value) {$/;"	F
flex	nvim/plugged/coc.nvim/build/index.js	/^function flex(lenFunc, decodeFunc) {$/;"	F
fix	nvim/plugged/coc.nvim/build/index.js	/^function fix(len, method) {$/;"	F
Encoder	nvim/plugged/coc.nvim/build/index.js	/^function Encoder(options) {$/;"	F
encode	nvim/plugged/coc.nvim/build/index.js	/^Encoder.prototype.encode = function(chunk) {$/;"	M
end	nvim/plugged/coc.nvim/build/index.js	/^Encoder.prototype.end = function(chunk) {$/;"	M
EventLite	nvim/plugged/coc.nvim/build/index.js	/^function EventLite() {$/;"	F
LISTENERS	nvim/plugged/coc.nvim/build/index.js	/^  var LISTENERS = "listeners";$/;"	V
methods	nvim/plugged/coc.nvim/build/index.js	/^  var methods = {$/;"	O
on	nvim/plugged/coc.nvim/build/index.js	/^    on: on,$/;"	P
once	nvim/plugged/coc.nvim/build/index.js	/^    once: once,$/;"	P
off	nvim/plugged/coc.nvim/build/index.js	/^    off: off,$/;"	P
emit	nvim/plugged/coc.nvim/build/index.js	/^    emit: emit$/;"	P
mixin	nvim/plugged/coc.nvim/build/index.js	/^  function mixin(target) {$/;"	F
on	nvim/plugged/coc.nvim/build/index.js	/^  function on(type, func) {$/;"	F
once	nvim/plugged/coc.nvim/build/index.js	/^  function once(type, func) {$/;"	F
wrap	nvim/plugged/coc.nvim/build/index.js	/^    function wrap() {$/;"	F
off	nvim/plugged/coc.nvim/build/index.js	/^  function off(type, func) {$/;"	F
listners	nvim/plugged/coc.nvim/build/index.js	/^    var listners;$/;"	V
ne	nvim/plugged/coc.nvim/build/index.js	/^    function ne(test) {$/;"	F
emit	nvim/plugged/coc.nvim/build/index.js	/^  function emit(type, value) {$/;"	F
zeroarg	nvim/plugged/coc.nvim/build/index.js	/^    function zeroarg(func) {$/;"	F
onearg	nvim/plugged/coc.nvim/build/index.js	/^    function onearg(func) {$/;"	F
moreargs	nvim/plugged/coc.nvim/build/index.js	/^    function moreargs(func) {$/;"	F
getListeners	nvim/plugged/coc.nvim/build/index.js	/^  function getListeners(that, type, readonly) {$/;"	F
Decoder	nvim/plugged/coc.nvim/build/index.js	/^function Decoder(options) {$/;"	F
decode	nvim/plugged/coc.nvim/build/index.js	/^Decoder.prototype.decode = function(chunk) {$/;"	M
push	nvim/plugged/coc.nvim/build/index.js	/^Decoder.prototype.push = function(chunk) {$/;"	M
end	nvim/plugged/coc.nvim/build/index.js	/^Decoder.prototype.end = function(chunk) {$/;"	M
DEFAULT_OPTIONS	nvim/plugged/coc.nvim/build/index.js	/^var DEFAULT_OPTIONS = {objectMode: true};$/;"	O
EncodeStream	nvim/plugged/coc.nvim/build/index.js	/^function EncodeStream(options) {$/;"	F
push	nvim/plugged/coc.nvim/build/index.js	/^  encoder.push = function(chunk) {$/;"	M
_transform	nvim/plugged/coc.nvim/build/index.js	/^EncodeStream.prototype._transform = function(chunk, encoding, callback) {$/;"	M
_flush	nvim/plugged/coc.nvim/build/index.js	/^EncodeStream.prototype._flush = function(callback) {$/;"	M
DEFAULT_OPTIONS	nvim/plugged/coc.nvim/build/index.js	/^var DEFAULT_OPTIONS = {objectMode: true};$/;"	O
DecodeStream	nvim/plugged/coc.nvim/build/index.js	/^function DecodeStream(options) {$/;"	F
push	nvim/plugged/coc.nvim/build/index.js	/^  decoder.push = function(chunk) {$/;"	M
_transform	nvim/plugged/coc.nvim/build/index.js	/^DecodeStream.prototype._transform = function(chunk, encoding, callback) {$/;"	M
codec	nvim/plugged/coc.nvim/build/index.js	/^exports.codec = {$/;"	P
Buffered	nvim/plugged/coc.nvim/build/index.js	/^class Buffered extends stream_1.Transform {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
sendData	nvim/plugged/coc.nvim/build/index.js	/^    sendData() {$/;"	M
_transform	nvim/plugged/coc.nvim/build/index.js	/^    _transform(chunk, _encoding, callback) {$/;"	M
_flush	nvim/plugged/coc.nvim/build/index.js	/^    _flush(callback) {$/;"	M
ExtType	nvim/plugged/coc.nvim/build/index.js	/^var ExtType;$/;"	V
fulfilled	nvim/plugged/coc.nvim/build/index.js	/^        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }$/;"	F
rejected	nvim/plugged/coc.nvim/build/index.js	/^        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }$/;"	F
Buffer	nvim/plugged/coc.nvim/build/index.js	/^class Buffer extends Base_1.BaseApi {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
attach	nvim/plugged/coc.nvim/build/index.js	/^    attach(sendBuffer = false, options = {}) {$/;"	M
detach	nvim/plugged/coc.nvim/build/index.js	/^    detach() {$/;"	M
getCommands	nvim/plugged/coc.nvim/build/index.js	/^    getCommands(options = {}) {$/;"	M
getLines	nvim/plugged/coc.nvim/build/index.js	/^    getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {$/;"	M
strictIndexing	nvim/plugged/coc.nvim/build/index.js	/^        strictIndexing: true,$/;"	P
TODO	nvim/plugged/coc.nvim/build/index.js	/^        \/\/ TODO: Error checking$/;"	T
setVirtualText	nvim/plugged/coc.nvim/build/index.js	/^    setVirtualText(src_id, line, chunks, opts = {}) {$/;"	M
insert	nvim/plugged/coc.nvim/build/index.js	/^    insert(lines, start) {$/;"	M
end	nvim/plugged/coc.nvim/build/index.js	/^            end: start,$/;"	P
strictIndexing	nvim/plugged/coc.nvim/build/index.js	/^            strictIndexing: true,$/;"	P
replace	nvim/plugged/coc.nvim/build/index.js	/^    replace(_lines, start) {$/;"	M
strictIndexing	nvim/plugged/coc.nvim/build/index.js	/^            strictIndexing: false,$/;"	P
remove	nvim/plugged/coc.nvim/build/index.js	/^    remove(start, end, strictIndexing = false) {$/;"	M
append	nvim/plugged/coc.nvim/build/index.js	/^    append(lines) {$/;"	M
strictIndexing	nvim/plugged/coc.nvim/build/index.js	/^            strictIndexing: false,$/;"	P
setName	nvim/plugged/coc.nvim/build/index.js	/^    setName(value) {$/;"	M
mark	nvim/plugged/coc.nvim/build/index.js	/^    mark(name) {$/;"	M
getKeymap	nvim/plugged/coc.nvim/build/index.js	/^    getKeymap(mode) {$/;"	M
getOffset	nvim/plugged/coc.nvim/build/index.js	/^    getOffset(index) {$/;"	M
addHighlight	nvim/plugged/coc.nvim/build/index.js	/^    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }) {$/;"	M
clearHighlight	nvim/plugged/coc.nvim/build/index.js	/^    clearHighlight(args = {}) {$/;"	M
defaults	nvim/plugged/coc.nvim/build/index.js	/^        const defaults = {$/;"	O
lineStart	nvim/plugged/coc.nvim/build/index.js	/^            lineStart: 0,$/;"	P
clearNamespace	nvim/plugged/coc.nvim/build/index.js	/^    clearNamespace(id, lineStart = 0, lineEnd = -1) {$/;"	M
listen	nvim/plugged/coc.nvim/build/index.js	/^    listen(eventName, cb) {$/;"	M
unlisten	nvim/plugged/coc.nvim/build/index.js	/^    unlisten(eventName, cb) {$/;"	M
fulfilled	nvim/plugged/coc.nvim/build/index.js	/^        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }$/;"	F
rejected	nvim/plugged/coc.nvim/build/index.js	/^        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }$/;"	F
BaseApi	nvim/plugged/coc.nvim/build/index.js	/^class BaseApi extends events_1.EventEmitter {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor({ transport, data, client, }) {$/;"	M
setTransport	nvim/plugged/coc.nvim/build/index.js	/^    setTransport(transport) {$/;"	M
equals	nvim/plugged/coc.nvim/build/index.js	/^    equals(other) {$/;"	M
request	nvim/plugged/coc.nvim/build/index.js	/^    request(name, args = []) {$/;"	M
getArgsByPrefix	nvim/plugged/coc.nvim/build/index.js	/^    getArgsByPrefix(args) {$/;"	M
getVar	nvim/plugged/coc.nvim/build/index.js	/^    getVar(name) {$/;"	M
setVar	nvim/plugged/coc.nvim/build/index.js	/^    setVar(name, value, isNotify = false) {$/;"	M
deleteVar	nvim/plugged/coc.nvim/build/index.js	/^    deleteVar(name) {$/;"	M
getOption	nvim/plugged/coc.nvim/build/index.js	/^    getOption(name) {$/;"	M
setOption	nvim/plugged/coc.nvim/build/index.js	/^    setOption(name, value, isNotify) {$/;"	M
notify	nvim/plugged/coc.nvim/build/index.js	/^    notify(name, args = []) {$/;"	M
Window	nvim/plugged/coc.nvim/build/index.js	/^class Window extends Base_1.BaseApi {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
setCursor	nvim/plugged/coc.nvim/build/index.js	/^    setCursor(pos, isNotify = false) {$/;"	M
setHeight	nvim/plugged/coc.nvim/build/index.js	/^    setHeight(height, isNotify = false) {$/;"	M
setWidth	nvim/plugged/coc.nvim/build/index.js	/^    setWidth(width, isNotify = false) {$/;"	M
setConfig	nvim/plugged/coc.nvim/build/index.js	/^    setConfig(options, isNotify) {$/;"	M
getConfig	nvim/plugged/coc.nvim/build/index.js	/^    getConfig() {$/;"	M
close	nvim/plugged/coc.nvim/build/index.js	/^    close(force, isNotify) {$/;"	M
count	nvim/plugged/coc.nvim/build/index.js	/^            let count = 0;$/;"	V
interval	nvim/plugged/coc.nvim/build/index.js	/^            let interval = setInterval(() => {$/;"	F
Tabpage	nvim/plugged/coc.nvim/build/index.js	/^class Tabpage extends Base_1.BaseApi {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
getOption	nvim/plugged/coc.nvim/build/index.js	/^    getOption() {$/;"	M
setOption	nvim/plugged/coc.nvim/build/index.js	/^    setOption() {$/;"	M
Transport	nvim/plugged/coc.nvim/build/index.js	/^class Transport extends events_1.EventEmitter {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
debug	nvim/plugged/coc.nvim/build/index.js	/^    debug(key, ...meta) {$/;"	M
debugMessage	nvim/plugged/coc.nvim/build/index.js	/^    debugMessage(msg) {$/;"	M
pauseNotification	nvim/plugged/coc.nvim/build/index.js	/^    pauseNotification() {$/;"	M
resumeNotification	nvim/plugged/coc.nvim/build/index.js	/^    resumeNotification(isNotify = false) {$/;"	M
getLogFile	nvim/plugged/coc.nvim/build/index.js	/^function getLogFile() {$/;"	F
toObject	nvim/plugged/coc.nvim/build/index.js	/^function toObject(arg) {$/;"	F
toString	nvim/plugged/coc.nvim/build/index.js	/^function toString(arg) {$/;"	F
Logger	nvim/plugged/coc.nvim/build/index.js	/^class Logger {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(name) {$/;"	M
getText	nvim/plugged/coc.nvim/build/index.js	/^    getText(level, data, meta) {$/;"	M
more	nvim/plugged/coc.nvim/build/index.js	/^        let more = '';$/;"	V
debug	nvim/plugged/coc.nvim/build/index.js	/^    debug(data, ...meta) {$/;"	M
info	nvim/plugged/coc.nvim/build/index.js	/^    info(data, ...meta) {$/;"	M
error	nvim/plugged/coc.nvim/build/index.js	/^    error(data, ...meta) {$/;"	M
trace	nvim/plugged/coc.nvim/build/index.js	/^    trace(data, ...meta) {$/;"	M
createLogger	nvim/plugged/coc.nvim/build/index.js	/^function createLogger(name) {$/;"	F
VimTransport	nvim/plugged/coc.nvim/build/index.js	/^class VimTransport extends base_1.default {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
attach	nvim/plugged/coc.nvim/build/index.js	/^    attach(writer, reader, client) {$/;"	M
detach	nvim/plugged/coc.nvim/build/index.js	/^    detach() {$/;"	M
request	nvim/plugged/coc.nvim/build/index.js	/^    request(method, args, cb) {$/;"	M
req	nvim/plugged/coc.nvim/build/index.js	/^        let req = new request_1.default(this.connection, cb, this.nextRequestId);$/;"	V
notify	nvim/plugged/coc.nvim/build/index.js	/^    notify(method, args) {$/;"	M
createResponse	nvim/plugged/coc.nvim/build/index.js	/^    createResponse(requestId) {$/;"	M
send	nvim/plugged/coc.nvim/build/index.js	/^            send: (resp, isError) => {$/;"	M
Connection	nvim/plugged/coc.nvim/build/index.js	/^class Connection extends events_1.default {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(readable, writeable) {$/;"	M
parseData	nvim/plugged/coc.nvim/build/index.js	/^    parseData(str) {$/;"	M
arr	nvim/plugged/coc.nvim/build/index.js	/^        let arr;$/;"	V
response	nvim/plugged/coc.nvim/build/index.js	/^    response(requestId, data) {$/;"	M
notify	nvim/plugged/coc.nvim/build/index.js	/^    notify(event, data) {$/;"	M
send	nvim/plugged/coc.nvim/build/index.js	/^    send(arr) {$/;"	M
redraw	nvim/plugged/coc.nvim/build/index.js	/^    redraw(force = false) {$/;"	M
commmand	nvim/plugged/coc.nvim/build/index.js	/^    commmand(cmd) {$/;"	M
expr	nvim/plugged/coc.nvim/build/index.js	/^    expr(expr) {$/;"	M
call	nvim/plugged/coc.nvim/build/index.js	/^    call(func, args, requestId) {$/;"	M
dispose	nvim/plugged/coc.nvim/build/index.js	/^    dispose() {$/;"	M
Request	nvim/plugged/coc.nvim/build/index.js	/^class Request {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(connection, cb, id) {$/;"	M
request	nvim/plugged/coc.nvim/build/index.js	/^    request(method, args = []) {$/;"	M
callback	nvim/plugged/coc.nvim/build/index.js	/^    callback(client, err, result) {$/;"	M
fulfilled	nvim/plugged/coc.nvim/build/index.js	/^        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }$/;"	F
rejected	nvim/plugged/coc.nvim/build/index.js	/^        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }$/;"	F
step	nvim/plugged/coc.nvim/build/index.js	/^        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }$/;"	F
Neovim	nvim/plugged/coc.nvim/build/index.js	/^class Neovim extends Base_1.BaseApi {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
getArgs	nvim/plugged/coc.nvim/build/index.js	/^    getArgs(args) {$/;"	M
setBuffer	nvim/plugged/coc.nvim/build/index.js	/^    setBuffer(buffer) {$/;"	M
getChanInfo	nvim/plugged/coc.nvim/build/index.js	/^    getChanInfo(chan) {$/;"	M
createNamespace	nvim/plugged/coc.nvim/build/index.js	/^    createNamespace(name = "") {$/;"	M
getCommands	nvim/plugged/coc.nvim/build/index.js	/^    getCommands(options = {}) {$/;"	M
setTabpage	nvim/plugged/coc.nvim/build/index.js	/^    setTabpage(tabpage) {$/;"	M
getWindows	nvim/plugged/coc.nvim/build/index.js	/^    getWindows() {$/;"	M
setWindow	nvim/plugged/coc.nvim/build/index.js	/^    setWindow(win) {$/;"	M
setDirectory	nvim/plugged/coc.nvim/build/index.js	/^    setDirectory(dir) {$/;"	M
createNewBuffer	nvim/plugged/coc.nvim/build/index.js	/^    createNewBuffer(listed = false, scratch = false) {$/;"	M
openFloatWindow	nvim/plugged/coc.nvim/build/index.js	/^    openFloatWindow(buffer, enter, options) {$/;"	M
getLine	nvim/plugged/coc.nvim/build/index.js	/^    getLine() {$/;"	M
setLine	nvim/plugged/coc.nvim/build/index.js	/^    setLine(line) {$/;"	M
getKeymap	nvim/plugged/coc.nvim/build/index.js	/^    getKeymap(mode) {$/;"	M
getColorByName	nvim/plugged/coc.nvim/build/index.js	/^    getColorByName(name) {$/;"	M
getHighlight	nvim/plugged/coc.nvim/build/index.js	/^    getHighlight(nameOrId, isRgb = true) {$/;"	M
getHighlightByName	nvim/plugged/coc.nvim/build/index.js	/^    getHighlightByName(name, isRgb = true) {$/;"	M
getHighlightById	nvim/plugged/coc.nvim/build/index.js	/^    getHighlightById(id, isRgb = true) {$/;"	M
deleteCurrentLine	nvim/plugged/coc.nvim/build/index.js	/^    deleteCurrentLine() {$/;"	M
eval	nvim/plugged/coc.nvim/build/index.js	/^    eval(expr) {$/;"	M
lua	nvim/plugged/coc.nvim/build/index.js	/^    lua(code, args = []) {$/;"	M
executeLua	nvim/plugged/coc.nvim/build/index.js	/^    executeLua(code, args = []) {$/;"	M
callDictFunction	nvim/plugged/coc.nvim/build/index.js	/^    callDictFunction(dict, fname, args = []) {$/;"	M
call	nvim/plugged/coc.nvim/build/index.js	/^    call(fname, args = [], isNotify) {$/;"	M
callTimer	nvim/plugged/coc.nvim/build/index.js	/^    callTimer(fname, args = [], isNotify) {$/;"	M
callAsync	nvim/plugged/coc.nvim/build/index.js	/^    callAsync(fname, args = []) {$/;"	M
callFunction	nvim/plugged/coc.nvim/build/index.js	/^    callFunction(fname, args = []) {$/;"	M
callAtomic	nvim/plugged/coc.nvim/build/index.js	/^    callAtomic(calls) {$/;"	M
command	nvim/plugged/coc.nvim/build/index.js	/^    command(arg, isNotify) {$/;"	M
commandOutput	nvim/plugged/coc.nvim/build/index.js	/^    commandOutput(arg) {$/;"	M
getVvar	nvim/plugged/coc.nvim/build/index.js	/^    getVvar(name) {$/;"	M
feedKeys	nvim/plugged/coc.nvim/build/index.js	/^    feedKeys(keys, mode, escapeCsi) {$/;"	M
input	nvim/plugged/coc.nvim/build/index.js	/^    input(keys) {$/;"	M
parseExpression	nvim/plugged/coc.nvim/build/index.js	/^    parseExpression(expr, flags, highlight) {$/;"	M
getProc	nvim/plugged/coc.nvim/build/index.js	/^    getProc(pid) {$/;"	M
getProcChildren	nvim/plugged/coc.nvim/build/index.js	/^    getProcChildren(pid) {$/;"	M
replaceTermcodes	nvim/plugged/coc.nvim/build/index.js	/^    replaceTermcodes(str, fromPart, doIt, special) {$/;"	M
strWidth	nvim/plugged/coc.nvim/build/index.js	/^    strWidth(str) {$/;"	M
outWrite	nvim/plugged/coc.nvim/build/index.js	/^    outWrite(str) {$/;"	M
outWriteLine	nvim/plugged/coc.nvim/build/index.js	/^    outWriteLine(str) {$/;"	M
errWrite	nvim/plugged/coc.nvim/build/index.js	/^    errWrite(str) {$/;"	M
errWriteLine	nvim/plugged/coc.nvim/build/index.js	/^    errWriteLine(str) {$/;"	M
TODO	nvim/plugged/coc.nvim/build/index.js	/^    \/\/ TODO: add type$/;"	T
uiAttach	nvim/plugged/coc.nvim/build/index.js	/^    uiAttach(width, height, options) {$/;"	M
uiDetach	nvim/plugged/coc.nvim/build/index.js	/^    uiDetach() {$/;"	M
uiTryResize	nvim/plugged/coc.nvim/build/index.js	/^    uiTryResize(width, height) {$/;"	M
uiSetOption	nvim/plugged/coc.nvim/build/index.js	/^    uiSetOption(name, value) {$/;"	M
subscribe	nvim/plugged/coc.nvim/build/index.js	/^    subscribe(event) {$/;"	M
unsubscribe	nvim/plugged/coc.nvim/build/index.js	/^    unsubscribe(event) {$/;"	M
setClientInfo	nvim/plugged/coc.nvim/build/index.js	/^    setClientInfo(name, version, type, methods, attributes) {$/;"	M
quit	nvim/plugged/coc.nvim/build/index.js	/^    quit() {$/;"	M
Events	nvim/plugged/coc.nvim/build/index.js	/^class Events {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor() {$/;"	M
_cursor	nvim/plugged/coc.nvim/build/index.js	/^            this._cursor = {$/;"	P
on	nvim/plugged/coc.nvim/build/index.js	/^    on(event, handler, thisArg, disposables) {$/;"	M
disposables	nvim/plugged/coc.nvim/build/index.js	/^            let disposables = [];$/;"	A
disposable	nvim/plugged/coc.nvim/build/index.js	/^            let disposable = vscode_languageserver_protocol_1.Disposable.create(() => {$/;"	F
__export	nvim/plugged/coc.nvim/build/index.js	/^function __export(m) {$/;"	F
Proposed	nvim/plugged/coc.nvim/build/index.js	/^var Proposed;$/;"	V
CallHierarchyRequest	nvim/plugged/coc.nvim/build/index.js	/^    let CallHierarchyRequest;$/;"	V
CallHierarchyDirection	nvim/plugged/coc.nvim/build/index.js	/^    let CallHierarchyDirection;$/;"	V
ProgressStartNotification	nvim/plugged/coc.nvim/build/index.js	/^    let ProgressStartNotification;$/;"	V
ProgressReportNotification	nvim/plugged/coc.nvim/build/index.js	/^    let ProgressReportNotification;$/;"	V
ProgressDoneNotification	nvim/plugged/coc.nvim/build/index.js	/^    let ProgressDoneNotification;$/;"	V
ProgressCancelNotification	nvim/plugged/coc.nvim/build/index.js	/^    let ProgressCancelNotification;$/;"	V
createProtocolConnection	nvim/plugged/coc.nvim/build/index.js	/^function createProtocolConnection(reader, writer, logger, strategy) {$/;"	F
__export	nvim/plugged/coc.nvim/build/index.js	/^function __export(m) {$/;"	F
CancelNotification	nvim/plugged/coc.nvim/build/index.js	/^var CancelNotification;$/;"	V
error	nvim/plugged/coc.nvim/build/index.js	/^    error: () => { },$/;"	M
warn	nvim/plugged/coc.nvim/build/index.js	/^    warn: () => { },$/;"	M
info	nvim/plugged/coc.nvim/build/index.js	/^    info: () => { },$/;"	M
log	nvim/plugged/coc.nvim/build/index.js	/^    log: () => { }$/;"	M
Trace	nvim/plugged/coc.nvim/build/index.js	/^var Trace;$/;"	V
fromString	nvim/plugged/coc.nvim/build/index.js	/^    function fromString(value) {$/;"	F
toString	nvim/plugged/coc.nvim/build/index.js	/^    function toString(value) {$/;"	F
TraceFormat	nvim/plugged/coc.nvim/build/index.js	/^var TraceFormat;$/;"	V
fromString	nvim/plugged/coc.nvim/build/index.js	/^    function fromString(value) {$/;"	F
SetTraceNotification	nvim/plugged/coc.nvim/build/index.js	/^var SetTraceNotification;$/;"	V
LogTraceNotification	nvim/plugged/coc.nvim/build/index.js	/^var LogTraceNotification;$/;"	V
ConnectionErrors	nvim/plugged/coc.nvim/build/index.js	/^var ConnectionErrors;$/;"	V
ConnectionError	nvim/plugged/coc.nvim/build/index.js	/^class ConnectionError extends Error {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(code, message) {$/;"	M
ConnectionStrategy	nvim/plugged/coc.nvim/build/index.js	/^var ConnectionStrategy;$/;"	V
is	nvim/plugged/coc.nvim/build/index.js	/^    function is(value) {$/;"	F
ConnectionState	nvim/plugged/coc.nvim/build/index.js	/^var ConnectionState;$/;"	V
_createMessageConnection	nvim/plugged/coc.nvim/build/index.js	/^function _createMessageConnection(messageReader, messageWriter, logger, strategy) {$/;"	F
sequenceNumber	nvim/plugged/coc.nvim/build/index.js	/^    let sequenceNumber = 0;$/;"	V
notificationSquenceNumber	nvim/plugged/coc.nvim/build/index.js	/^    let notificationSquenceNumber = 0;$/;"	V
unknownResponseSquenceNumber	nvim/plugged/coc.nvim/build/index.js	/^    let unknownResponseSquenceNumber = 0;$/;"	V
version	nvim/plugged/coc.nvim/build/index.js	/^    const version = '2.0';$/;"	V
timer	nvim/plugged/coc.nvim/build/index.js	/^    let timer;$/;"	V
messageQueue	nvim/plugged/coc.nvim/build/index.js	/^    let messageQueue = new linkedMap_1.LinkedMap();$/;"	V
tracer	nvim/plugged/coc.nvim/build/index.js	/^    let tracer;$/;"	V
errorEmitter	nvim/plugged/coc.nvim/build/index.js	/^    let errorEmitter = new events_1.Emitter();$/;"	V
closeEmitter	nvim/plugged/coc.nvim/build/index.js	/^    let closeEmitter = new events_1.Emitter();$/;"	V
unhandledNotificationEmitter	nvim/plugged/coc.nvim/build/index.js	/^    let unhandledNotificationEmitter = new events_1.Emitter();$/;"	V
disposeEmitter	nvim/plugged/coc.nvim/build/index.js	/^    let disposeEmitter = new events_1.Emitter();$/;"	V
createRequestQueueKey	nvim/plugged/coc.nvim/build/index.js	/^    function createRequestQueueKey(id) {$/;"	F
createResponseQueueKey	nvim/plugged/coc.nvim/build/index.js	/^    function createResponseQueueKey(id) {$/;"	F
createNotificationQueueKey	nvim/plugged/coc.nvim/build/index.js	/^    function createNotificationQueueKey() {$/;"	F
addMessageToQueue	nvim/plugged/coc.nvim/build/index.js	/^    function addMessageToQueue(queue, message) {$/;"	F
cancelUndispatched	nvim/plugged/coc.nvim/build/index.js	/^    function cancelUndispatched(_message) {$/;"	F
isListening	nvim/plugged/coc.nvim/build/index.js	/^    function isListening() {$/;"	F
isClosed	nvim/plugged/coc.nvim/build/index.js	/^    function isClosed() {$/;"	F
isDisposed	nvim/plugged/coc.nvim/build/index.js	/^    function isDisposed() {$/;"	F
closeHandler	nvim/plugged/coc.nvim/build/index.js	/^    function closeHandler() {$/;"	F
readErrorHandler	nvim/plugged/coc.nvim/build/index.js	/^    function readErrorHandler(error) {$/;"	F
writeErrorHandler	nvim/plugged/coc.nvim/build/index.js	/^    function writeErrorHandler(data) {$/;"	F
triggerMessageQueue	nvim/plugged/coc.nvim/build/index.js	/^    function triggerMessageQueue() {$/;"	F
processMessageQueue	nvim/plugged/coc.nvim/build/index.js	/^    function processMessageQueue() {$/;"	F
callback	nvim/plugged/coc.nvim/build/index.js	/^    let callback = (message) => {$/;"	F
handleRequest	nvim/plugged/coc.nvim/build/index.js	/^    function handleRequest(requestMessage) {$/;"	F
reply	nvim/plugged/coc.nvim/build/index.js	/^        function reply(resultOrError, method, startTime) {$/;"	F
message	nvim/plugged/coc.nvim/build/index.js	/^            let message = {$/;"	O
jsonrpc	nvim/plugged/coc.nvim/build/index.js	/^                jsonrpc: version,$/;"	P
replyError	nvim/plugged/coc.nvim/build/index.js	/^        function replyError(error, method, startTime) {$/;"	F
message	nvim/plugged/coc.nvim/build/index.js	/^            let message = {$/;"	O
jsonrpc	nvim/plugged/coc.nvim/build/index.js	/^                jsonrpc: version,$/;"	P
replySuccess	nvim/plugged/coc.nvim/build/index.js	/^        function replySuccess(result, method, startTime) {$/;"	F
message	nvim/plugged/coc.nvim/build/index.js	/^            let message = {$/;"	O
jsonrpc	nvim/plugged/coc.nvim/build/index.js	/^                jsonrpc: version,$/;"	P
result	nvim/plugged/coc.nvim/build/index.js	/^                result: result$/;"	P
type	nvim/plugged/coc.nvim/build/index.js	/^        let type;$/;"	V
requestHandler	nvim/plugged/coc.nvim/build/index.js	/^        let requestHandler;$/;"	V
cancellationSource	nvim/plugged/coc.nvim/build/index.js	/^            let cancellationSource = new cancellation_1.CancellationTokenSource();$/;"	V
handlerResult	nvim/plugged/coc.nvim/build/index.js	/^                let handlerResult;$/;"	V
handleResponse	nvim/plugged/coc.nvim/build/index.js	/^    function handleResponse(responseMessage) {$/;"	F
handleNotification	nvim/plugged/coc.nvim/build/index.js	/^    function handleNotification(message) {$/;"	F
notificationHandler	nvim/plugged/coc.nvim/build/index.js	/^        let notificationHandler;$/;"	V
notificationHandler	nvim/plugged/coc.nvim/build/index.js	/^            notificationHandler = (params) => {$/;"	M
handleInvalidMessage	nvim/plugged/coc.nvim/build/index.js	/^    function handleInvalidMessage(message) {$/;"	F
traceSendingRequest	nvim/plugged/coc.nvim/build/index.js	/^    function traceSendingRequest(message) {$/;"	F
traceSendingNotification	nvim/plugged/coc.nvim/build/index.js	/^    function traceSendingNotification(message) {$/;"	F
traceSendingResponse	nvim/plugged/coc.nvim/build/index.js	/^    function traceSendingResponse(message, method, startTime) {$/;"	F
traceReceivedRequest	nvim/plugged/coc.nvim/build/index.js	/^    function traceReceivedRequest(message) {$/;"	F
traceReceivedNotification	nvim/plugged/coc.nvim/build/index.js	/^    function traceReceivedNotification(message) {$/;"	F
traceReceivedResponse	nvim/plugged/coc.nvim/build/index.js	/^    function traceReceivedResponse(message, responsePromise) {$/;"	F
logLSPMessage	nvim/plugged/coc.nvim/build/index.js	/^    function logLSPMessage(type, message) {$/;"	F
lspMessage	nvim/plugged/coc.nvim/build/index.js	/^        const lspMessage = {$/;"	O
isLSPMessage	nvim/plugged/coc.nvim/build/index.js	/^            isLSPMessage: true,$/;"	P
throwIfClosedOrDisposed	nvim/plugged/coc.nvim/build/index.js	/^    function throwIfClosedOrDisposed() {$/;"	F
throwIfListening	nvim/plugged/coc.nvim/build/index.js	/^    function throwIfListening() {$/;"	F
throwIfNotListening	nvim/plugged/coc.nvim/build/index.js	/^    function throwIfNotListening() {$/;"	F
undefinedToNull	nvim/plugged/coc.nvim/build/index.js	/^    function undefinedToNull(param) {$/;"	F
computeMessageParams	nvim/plugged/coc.nvim/build/index.js	/^    function computeMessageParams(type, params) {$/;"	F
result	nvim/plugged/coc.nvim/build/index.js	/^        let result;$/;"	V
connection	nvim/plugged/coc.nvim/build/index.js	/^    let connection = {$/;"	O
sendNotification	nvim/plugged/coc.nvim/build/index.js	/^        sendNotification: (type, ...params) => {$/;"	M
method	nvim/plugged/coc.nvim/build/index.js	/^            let method;$/;"	V
messageParams	nvim/plugged/coc.nvim/build/index.js	/^            let messageParams;$/;"	V
notificationMessage	nvim/plugged/coc.nvim/build/index.js	/^            let notificationMessage = {$/;"	O
jsonrpc	nvim/plugged/coc.nvim/build/index.js	/^                jsonrpc: version,$/;"	P
method	nvim/plugged/coc.nvim/build/index.js	/^                method: method,$/;"	P
params	nvim/plugged/coc.nvim/build/index.js	/^                params: messageParams$/;"	P
onNotification	nvim/plugged/coc.nvim/build/index.js	/^        onNotification: (type, handler) => {$/;"	M
sendRequest	nvim/plugged/coc.nvim/build/index.js	/^        sendRequest: (type, ...params) => {$/;"	M
method	nvim/plugged/coc.nvim/build/index.js	/^            let method;$/;"	V
messageParams	nvim/plugged/coc.nvim/build/index.js	/^            let messageParams;$/;"	V
result	nvim/plugged/coc.nvim/build/index.js	/^            let result = new Promise((resolve, reject) => {$/;"	F
result	nvim/plugged/coc.nvim/build/index.js	/^            let result = new Promise((resolve, reject) => {$/;"	V
requestMessage	nvim/plugged/coc.nvim/build/index.js	/^                let requestMessage = {$/;"	O
jsonrpc	nvim/plugged/coc.nvim/build/index.js	/^                    jsonrpc: version,$/;"	P
id	nvim/plugged/coc.nvim/build/index.js	/^                    id: id,$/;"	P
method	nvim/plugged/coc.nvim/build/index.js	/^                    method: method,$/;"	P
params	nvim/plugged/coc.nvim/build/index.js	/^                    params: messageParams$/;"	P
responsePromise	nvim/plugged/coc.nvim/build/index.js	/^                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };$/;"	O
onRequest	nvim/plugged/coc.nvim/build/index.js	/^        onRequest: (type, handler) => {$/;"	M
trace	nvim/plugged/coc.nvim/build/index.js	/^        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {$/;"	M
dispose	nvim/plugged/coc.nvim/build/index.js	/^        dispose: () => {$/;"	M
error	nvim/plugged/coc.nvim/build/index.js	/^            let error = new Error('Connection got disposed.');$/;"	V
listen	nvim/plugged/coc.nvim/build/index.js	/^        listen: () => {$/;"	M
inspect	nvim/plugged/coc.nvim/build/index.js	/^        inspect: () => {$/;"	M
isMessageReader	nvim/plugged/coc.nvim/build/index.js	/^function isMessageReader(value) {$/;"	F
isMessageWriter	nvim/plugged/coc.nvim/build/index.js	/^function isMessageWriter(value) {$/;"	F
createMessageConnection	nvim/plugged/coc.nvim/build/index.js	/^function createMessageConnection(input, output, logger, strategy) {$/;"	F
boolean	nvim/plugged/coc.nvim/build/index.js	/^function boolean(value) {$/;"	F
string	nvim/plugged/coc.nvim/build/index.js	/^function string(value) {$/;"	F
number	nvim/plugged/coc.nvim/build/index.js	/^function number(value) {$/;"	F
error	nvim/plugged/coc.nvim/build/index.js	/^function error(value) {$/;"	F
func	nvim/plugged/coc.nvim/build/index.js	/^function func(value) {$/;"	F
array	nvim/plugged/coc.nvim/build/index.js	/^function array(value) {$/;"	F
stringArray	nvim/plugged/coc.nvim/build/index.js	/^function stringArray(value) {$/;"	F
ErrorCodes	nvim/plugged/coc.nvim/build/index.js	/^var ErrorCodes;$/;"	V
ResponseError	nvim/plugged/coc.nvim/build/index.js	/^class ResponseError extends Error {$/;"	C
constructor	nvim/plugged/coc.nvim/build/index.js	/^    constructor(code, message, data) {$/;"	M
toJson	nvim/plugged/c